<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>周末摄影之旅</title>
    <url>/2024/05/03/life-weekend-photography-trip/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>城市风光</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客文章发布教程</title>
    <url>/2025/05/03/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Hexo-博客文章发布教程"><a href="#Hexo-博客文章发布教程" class="headerlink" title="Hexo 博客文章发布教程"></a>Hexo 博客文章发布教程</h1><p>本教程将详细介绍如何在 Hexo 博客中创建和发布文章，包括文章的基本结构、常用配置和发布流程。</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><h3 id="1-使用命令行创建"><a href="#1-使用命令行创建" class="headerlink" title="1. 使用命令行创建"></a>1. 使用命令行创建</h3><p>在博客根目录下，使用以下命令创建新文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将在 <code>source/_posts</code> 目录下创建一个新的 Markdown 文件，文件名格式为：<code>年-月-日-文章标题.md</code></p>
<h3 id="2-手动创建"><a href="#2-手动创建" class="headerlink" title="2. 手动创建"></a>2. 手动创建</h3><p>你也可以直接在 <code>source/_posts</code> 目录下手动创建 Markdown 文件，但需要确保文件名格式正确。</p>
<h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>每篇文章都包含两个主要部分：</p>
<ol>
<li><strong>Front-matter</strong>：文章头部配置</li>
<li><strong>正文内容</strong>：文章主体内容</li>
</ol>
<h3 id="Front-matter-配置"><a href="#Front-matter-配置" class="headerlink" title="Front-matter 配置"></a>Front-matter 配置</h3><p>Front-matter 是文章开头的配置部分，使用 <code>---</code> 包裹。常用配置项包括：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">年-月-日</span> <span class="string">时:分:秒</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">封面图片路径</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>常用配置项说明：</p>
<ul>
<li><code>title</code>: 文章标题</li>
<li><code>date</code>: 文章创建时间</li>
<li><code>tags</code>: 文章标签，可以设置多个</li>
<li><code>categories</code>: 文章分类</li>
<li><code>cover</code>: 文章封面图片</li>
<li><code>comments</code>: 是否开启评论（默认为 true）</li>
</ul>
<h3 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h3><p>正文使用 Markdown 语法编写，支持：</p>
<ul>
<li>标题</li>
<li>段落</li>
<li>列表</li>
<li>代码块</li>
<li>图片</li>
<li>表格</li>
<li>等等</li>
</ul>
<h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>在发布文章前，建议先在本地预览：</p>
<ol>
<li><p>启动本地服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</p>
</li>
</ol>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="1-生成静态文件"><a href="#1-生成静态文件" class="headerlink" title="1. 生成静态文件"></a>1. 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="2-部署到服务器"><a href="#2-部署到服务器" class="headerlink" title="2. 部署到服务器"></a>2. 部署到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一键生成并部署</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="文章写作建议"><a href="#文章写作建议" class="headerlink" title="文章写作建议"></a>文章写作建议</h2><ol>
<li><strong>保持结构清晰</strong>：使用合适的标题层级</li>
<li><strong>添加适当的标签</strong>：便于文章分类和检索</li>
<li><strong>使用图片</strong>：适当添加图片使文章更生动</li>
<li><strong>代码格式化</strong>：使用代码块展示代码</li>
<li><strong>预览检查</strong>：发布前务必预览检查</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p><strong>文章不显示</strong>：</p>
<ul>
<li>检查文件名格式是否正确</li>
<li>确保 Front-matter 格式正确</li>
<li>尝试清理缓存后重新生成</li>
</ul>
</li>
<li><p><strong>图片不显示</strong>：</p>
<ul>
<li>检查图片路径是否正确</li>
<li>确保图片文件存在</li>
</ul>
</li>
<li><p><strong>格式问题</strong>：</p>
<ul>
<li>检查 Markdown 语法是否正确</li>
<li>确保缩进正确</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，你应该已经掌握了在 Hexo 博客中创建和发布文章的基本方法。记住，好的文章不仅需要好的内容，还需要正确的格式和配置。如果你有任何问题，欢迎在评论区留言讨论！ </p>
]]></content>
      <categories>
        <category>博客</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>教程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 使用教程</title>
    <url>/2025/05/03/Markdown-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Markdown-使用教程"><a href="#Markdown-使用教程" class="headerlink" title="Markdown 使用教程"></a>Markdown 使用教程</h1><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。由于其易读性、易写性及格式转换的便利性，Markdown 被广泛用于博客、文档编写等领域。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>使用 <code>#</code> 号可表示 1-6 级标题，一级标题对应一个 <code>#</code> 号，二级标题对应两个 <code>#</code> 号，以此类推。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h3 id="2-段落和换行"><a href="#2-段落和换行" class="headerlink" title="2. 段落和换行"></a>2. 段落和换行</h3><p>段落的前后要有空行，所谓的空行是指没有内容的行。若想在段内强制换行的方式是使用两个以上空格加上回车。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是第一段。</span><br><span class="line"></span><br><span class="line">这是第二段，  </span><br><span class="line">这里强制换行。</span><br></pre></td></tr></table></figure>

<h3 id="3-强调"><a href="#3-强调" class="headerlink" title="3. 强调"></a>3. 强调</h3><p>使用 <code>*</code> 或 <code>_</code> 包裹文本可以表示强调：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure>

<h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4. 列表"></a>4. 列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用 <code>-</code>、<code>+</code> 或 <code>*</code> 标记无序列表：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"><span class="bullet">*</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">+</span> 第三项</span><br></pre></td></tr></table></figure>

<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>使用数字加点标记有序列表：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure>

<h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p>使用 <code>&gt;</code> 标记引用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是引用的内容</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 这是第二行引用</span></span><br></pre></td></tr></table></figure>

<h3 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a>6. 代码</h3><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>使用反引号 <code>`</code> 包裹代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 <span class="code">`print()`</span> 函数输出内容</span><br></pre></td></tr></table></figure>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>使用三个反引号 &#96;&#96;&#96; 包裹代码块，并指定语言：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def hello():</span></span><br><span class="line"><span class="code">    print(&quot;Hello, World!&quot;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 7. 链接和图片</span><br><span class="line"></span><br><span class="line">#### 链接</span><br><span class="line"></span><br><span class="line">```markdown</span><br><span class="line">[链接文字](链接地址)</span><br><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">图片地址</span>)</span><br><span class="line">![<span class="string">示例图片</span>](<span class="link">https://example.com/image.jpg</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h3><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 表头1 | 表头2 |</span><br><span class="line">|-------|-------|</span><br><span class="line">| 单元格1 | 单元格2 |</span><br><span class="line">| 单元格3 | 单元格4 |</span><br></pre></td></tr></table></figure>

<h3 id="9-分割线"><a href="#9-分割线" class="headerlink" title="9. 分割线"></a>9. 分割线</h3><p>使用三个或以上的 <code>-</code>、<code>*</code> 或 <code>_</code> 来创建分割线：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_</span></span></span><br></pre></td></tr></table></figure>

<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="1-任务列表"><a href="#1-任务列表" class="headerlink" title="1. 任务列表"></a>1. 任务列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务</span><br></pre></td></tr></table></figure>

<h3 id="2-脚注"><a href="#2-脚注" class="headerlink" title="2. 脚注"></a>2. 脚注</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个脚注[^1]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">这是脚注的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="3-目录"><a href="#3-目录" class="headerlink" title="3. 目录"></a>3. 目录</h3><p>使用 <code>[TOC]</code> 可以自动生成目录（部分编辑器支持）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Markdown 是一种简单而强大的标记语言，它让写作变得更加简单和高效。通过掌握这些基本语法，你就可以开始使用 Markdown 来编写文档、博客等内容了。</p>
<p>如果你有任何问题，欢迎在评论区留言讨论！ </p>
]]></content>
      <categories>
        <category>工具</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>工具</tag>
        <tag>Markdown</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>周末摄影之旅：寻找城市之美</title>
    <url>/2024/05/04/life-weekend-photography-trip/</url>
    <content><![CDATA[<h1 id="周末摄影之旅：寻找城市之美"><a href="#周末摄影之旅：寻找城市之美" class="headerlink" title="周末摄影之旅：寻找城市之美"></a>周末摄影之旅：寻找城市之美</h1><p>这个周末，我带着相机走遍城市的角落，捕捉那些容易被忽视的美好瞬间。</p>
<h2 id="清晨的街道"><a href="#清晨的街道" class="headerlink" title="清晨的街道"></a>清晨的街道</h2>
<p><em>早晨6点的街道，阳光斜射在建筑物上，形成独特的光影效果</em></p>
<h2 id="城市建筑"><a href="#城市建筑" class="headerlink" title="城市建筑"></a>城市建筑</h2><h3 id="现代建筑"><a href="#现代建筑" class="headerlink" title="现代建筑"></a>现代建筑</h3>
<p><em>玻璃幕墙映射着天空的颜色，仿佛一面巨大的镜子</em></p>
<h3 id="老街区"><a href="#老街区" class="headerlink" title="老街区"></a>老街区</h3>
<p><em>保留着历史痕迹的老街区，每一面墙都在诉说着故事</em></p>
<h2 id="街头生活"><a href="#街头生活" class="headerlink" title="街头生活"></a>街头生活</h2>
<p><em>街边小店的烟火气息，是城市最真实的一面</em></p>
<h2 id="视频分享"><a href="#视频分享" class="headerlink" title="视频分享"></a>视频分享</h2><div class="video-container">https://youtu.be/your-video-id  </div>
<p><em>城市延时摄影，记录24小时的城市变迁</em></p>
<h2 id="拍摄技巧分享"><a href="#拍摄技巧分享" class="headerlink" title="拍摄技巧分享"></a>拍摄技巧分享</h2><ol>
<li>黄金时段的利用</li>
<li>构图要点</li>
<li>相机参数设置<ul>
<li>光圈：f&#x2F;8</li>
<li>快门：1&#x2F;125s</li>
<li>ISO：100</li>
</ul>
</li>
</ol>
<h2 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h2><p>使用Lightroom进行后期调整：</p>
<ul>
<li>提亮阴影</li>
<li>调整色温</li>
<li>局部锐化</li>
</ul>
<span id="more"></span>

<h2 id="器材分享"><a href="#器材分享" class="headerlink" title="器材分享"></a>器材分享</h2><ul>
<li>相机：Sony A7III</li>
<li>镜头：<ul>
<li>24-70mm f&#x2F;2.8</li>
<li>50mm f&#x2F;1.8</li>
</ul>
</li>
<li>三脚架：Manfrotto</li>
</ul>
<h2 id="拍摄心得"><a href="#拍摄心得" class="headerlink" title="拍摄心得"></a>拍摄心得</h2><p>在城市摄影中，最重要的不是器材，而是发现美的眼睛…</p>
<hr>
<p>欢迎关注我的摄影账号：</p>
<ul>
<li>Instagram: @your_photo_account</li>
<li>500px: @your_500px_account</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>城市风光</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud OpenFeign 学习笔记</title>
    <url>/2025/08/26/Spring-Cloud-OpenFeign-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一、服务调用方式对比<br>在 Spring Cloud 中，引入 OpenFeign 之前，常使用 Ribbon（负载均衡器）与 RestTemplate 进行服务间调用。但此方式代码耦合性强，维护性与可读性差，修改不便。而 Spring Cloud OpenFeign 采用依赖注入方式调用，如同调用本地 service，极大提升了代码的简洁性与可维护性。</p>
<p>二、OpenFeign 使用步骤</p>
<ol>
<li>引入依赖：在项目中引入 OpenFeign 的相关 Maven 依赖。</li>
<li>添加注解：在 Spring Boot 启动类上添加 @EnableFeignClients 注解，开启 Feign 客户端功能。</li>
<li>定义接口：</li>
</ol>
<ul>
<li>方式一：在自定义的 SDK 中定义带有 @FeignClient 注解的接口。</li>
<li>方式二：自行定义 OpenFeign 接口，该接口用于声明服务调用方法。</li>
</ul>
<ol start="4">
<li>注入使用：将定义好的 Feign 接口注入到需要调用的地方，即可实现服务间的远程调用。<br>三、OpenFeign 接口参数处理</li>
</ol>
<ul>
<li>默认 <strong>@RequestBody</strong>：若接口参数未添加其他注解，OpenFeign 默认添加 @RequestBody 注解。但 @RequestBody 通常只能接收一个对象，传入多个对象会报错。</li>
<li>GET 请求参数：对于 GET 类型请求，可写多个基本类型参数，这些参数会自动拼接到 URL 上。若想用 form 表单形式传递参数，可使用 @SpringQueryMap 注解，同样会将参数拼接到 URL 上。<br>四、OpenFeign 结构与原理</li>
<li>服务端与调用端：<ul>
<li>服务提供端：通过在接口方法上添加 @FeignClient 注解，将服务封装成接口方法，并打包成 SDK。</li>
<li>服务调用端：引入服务提供端的 SDK，在 Spring Boot 启动时，利用 JDK 动态代理生成代理对象，并注入到 Bean 容器中。当调用接口方法时，通过 InvocationHandler 调用处理器进行远程调用。</li>
</ul>
</li>
<li>处理流程：<ul>
<li>调用接口方法后，<strong>Contract</strong> 根据注解声明的规则解析底层的 <strong>MethodHandler</strong>。</li>
<li>MethodHandler 底层调用 <strong>RequestTemplate</strong>，<strong>RequestTemplate</strong> 内部实现了编码和解码功能。服务发起端对请求进行编码，服务调用端在解析返回结果时进行解码。</li>
<li>最外层有 Interceptors 拦截器，用于对请求和响应进行拦截，例如记录日志等操作。</li>
<li>Feign Client 基于负载均衡器和重试器进行策略调控。请求到达服务调用端后，经过解码，<strong>MethodHandler</strong> 根据规则映射找到调用的方法，通过处理器获取 InvocationHandler 的调用结果，并解析成 Response 的 Bean。<br>五、OpenFeign 增强方式<br>（一）日志增强</li>
</ul>
</li>
<li>配置 Feign 的 Config Bean 对象：通过配置该 Bean 对象可实现日志增强。</li>
<li>YAML 文件配置：在 YAML 文件中进行配置，更为灵活且支持配置中心实时更改。</li>
<li>日志级别：<ul>
<li>NONE：不记录日志。</li>
<li>BASIC：仅记录请求方法、URL、响应状态代码及执行时间。</li>
<li>HEADERS：在 BASIC 基础上记录请求和响应的 Header。</li>
<li>FULL：全量记录请求、响应的 Header、Body 及原始数据。<br>（二）HTTP 连接优化</li>
</ul>
</li>
<li>引入 Feign HC5：OpenFeign 默认的 HTTP 连接无连接池，性能较差。引入 <strong>Feign HC5</strong>（Apache HTTP5 的实现）依赖，其内部自带连接池，可优化调用效率，减少连接的频繁创建与销毁。由于 OpenFeign 的自动配置类已将相关属性默认配置为启用状态，因此即便不在 YAML 中配置，引入依赖后也会生效。</li>
<li>替换为 OKHTTP：除 Feign HC5 外，还可引入 OKHTTP 依赖，并在 YAML 中开启 OKHTTP 配置，将底层 HTTP 请求替换为 OKHTTP。<br>（三）压缩配置</li>
<li>gzip 压缩：OpenFeign 支持 gzip 压缩配置，当请求超过某个阈值（如 1024 字节），可在 YAML 中开启 gzip 压缩，并配置需要压缩的请求类型及最小压缩阈值等参数，以优化请求体大小和传输效率。</li>
<li>OKHTTP 特殊情况：若使用 OKHTTP 作为底层 HTTP 请求，因其内部默认使用 transparent 压缩方式，一般无需额外配置 gzip 压缩。<br>（四）自定义编解码器<br>OpenFeign 提供扩展点，可通过实现 Encoder 和 Decoder 接口来自定义编解码器，并在 YAML 中进行配置。</li>
</ul>
<p>（五）拦截器实现</p>
<ul>
<li>BasicAuthRequestInterceptor：通过注入该 Bean 并进行配置来实现拦截器功能，但此方式灵活性欠佳。</li>
<li>实现 RequestInterceptor 接口：推荐使用此方式，通过实现接口来定义拦截逻辑，更加灵活。<br>六、YAML 基本配置示例<br>feign:<br>client:<br>config:<br>default:<br>loggerLevel: FULL # 日志级别设置为 FULL<br>httpclient:<br>enabled: true # 启用 Feign HC5 连接池<br>max-connections: 200 # 最大连接数<br>max-connections-per-route: 50 # 每个路由的最大连接数<br>compression:<br>request:<br>enabled: true # 开启请求压缩<br>mime-types: text&#x2F;xml,application&#x2F;xml,application&#x2F;json # 需要压缩的请求类型<br>min-request-size: 1024 # 最小压缩阈值<br>okhttp:<br>enabled: true # 启用 OKHTTP</li>
</ul>
<p>在对 OpenFeign 进行配置时，优先考虑 YAML 配置方式，因其可</p>
]]></content>
  </entry>
  <entry>
    <title>Nacos 核心源码学习笔记</title>
    <url>/2025/08/26/Nacos-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nacos-核心源码学习笔记"><a href="#Nacos-核心源码学习笔记" class="headerlink" title="Nacos 核心源码学习笔记"></a>Nacos 核心源码学习笔记</h1><p>Nacos 作为微服务架构中核心的服务注册发现与配置中心，其底层设计与实现逻辑对理解微服务治理至关重要。本文从源码入口、服务注册、心跳检测、集群一致性四个核心维度，梳理 Nacos 关键机制的实现原理。</p>
<h2 id="一、源码入口与初始化机制"><a href="#一、源码入口与初始化机制" class="headerlink" title="一、源码入口与初始化机制"></a>一、源码入口与初始化机制</h2><h3 id="1-源码入口定位"><a href="#1-源码入口定位" class="headerlink" title="1. 源码入口定位"></a>1. 源码入口定位</h3><p>分析 Nacos 源码时，可通过启动脚本定位启动类，或直接聚焦服务发现核心 Jar 包（如 <code>nacos-discovery</code>）。其初始化逻辑依赖 <strong>Spring Boot SPI 机制</strong>，核心流程如下：</p>
<ul>
<li>在 <code>META-INF/spring.factories</code> 中配置自动配置类（如服务发现场景的 <code>NacosDiscoveryAutoConfiguration</code>）；</li>
<li>启用 Jar 包时，Spring 容器通过 <code>@EnableAutoConfiguration</code> 触发自动配置类加载；</li>
<li>自动配置类初始化 <code>NacosServiceRegistry</code>（服务注册）、<code>NacosDiscoveryClient</code>（服务发现）等核心组件，并向 Nacos 服务端发起请求，建立基础通信链路。</li>
</ul>
<h2 id="二、服务注册流程与高并发设计"><a href="#二、服务注册流程与高并发设计" class="headerlink" title="二、服务注册流程与高并发设计"></a>二、服务注册流程与高并发设计</h2><h3 id="1-核心注册流程"><a href="#1-核心注册流程" class="headerlink" title="1. 核心注册流程"></a>1. 核心注册流程</h3><ol>
<li>客户端封装服务信息（IP、端口、服务名等）为 <code>Instance</code> 对象，发送注册请求至服务端；</li>
<li>服务端接收请求后，先将 <code>Instance</code> 存入 <code>BlockingQueue</code> 阻塞队列，作为请求缓冲层；</li>
<li>后台专用线程从队列中持续取出 <code>Instance</code>，写入注册表（嵌套 <code>Map</code> 结构：<code>serviceName -&gt; cluster -&gt; Instance</code>）。</li>
</ol>
<h3 id="2-高并发支撑策略"><a href="#2-高并发支撑策略" class="headerlink" title="2. 高并发支撑策略"></a>2. 高并发支撑策略</h3><ul>
<li><strong>阻塞队列缓冲</strong>：通过“生产者-消费者”模式解耦请求接收与数据写入，避免直接操作注册表导致的锁竞争；</li>
<li><strong>读写分离架构</strong>：<ul>
<li>写操作（注册&#x2F;更新）：拷贝目标服务的 <code>Instance</code> 集合（<code>Set</code>），在副本中修改，不影响原集合；</li>
<li>读操作（服务发现）：直接从原 <code>Set</code> 读取数据，保证查询无阻塞；</li>
</ul>
</li>
<li><strong>原子替换</strong>：修改完成后，用新 <code>Set</code> 原子替换原 <code>Set</code>，兼顾数据一致性与并发效率。</li>
</ul>
<h2 id="三、心跳检测机制"><a href="#三、心跳检测机制" class="headerlink" title="三、心跳检测机制"></a>三、心跳检测机制</h2><h3 id="1-客户端心跳发送"><a href="#1-客户端心跳发送" class="headerlink" title="1. 客户端心跳发送"></a>1. 客户端心跳发送</h3><p>服务实例注册成功后，客户端默认每 <strong>5 秒</strong> 向 Nacos 服务端发送心跳请求，携带实例 ID 等唯一标识信息。</p>
<h3 id="2-服务端健康检查"><a href="#2-服务端健康检查" class="headerlink" title="2. 服务端健康检查"></a>2. 服务端健康检查</h3><p>服务端维护每个实例的“最后心跳时间”，通过时间差判断实例健康状态：</p>
<ul>
<li>若 <code>当前时间 - 最后心跳时间 &gt; 15 秒</code>：标记实例为不健康（<code>healthy = false</code>），服务发现时不返回该实例；</li>
<li>若 <code>当前时间 - 最后心跳时间 &gt; 30 秒</code>：直接从注册表中移除实例，视为服务下线。</li>
</ul>
<h2 id="四、集群-CP-模式与-Raft-协议"><a href="#四、集群-CP-模式与-Raft-协议" class="headerlink" title="四、集群 CP 模式与 Raft 协议"></a>四、集群 CP 模式与 Raft 协议</h2><h3 id="1-CP-模式适用场景"><a href="#1-CP-模式适用场景" class="headerlink" title="1. CP 模式适用场景"></a>1. CP 模式适用场景</h3><p>通过配置 <code>nacos.core.protocol=cp</code> 开启 CP 模式，适用于数据一致性要求极高的场景（如金融领域服务注册）。</p>
<h3 id="2-Raft-协议核心作用"><a href="#2-Raft-协议核心作用" class="headerlink" title="2. Raft 协议核心作用"></a>2. Raft 协议核心作用</h3><p>服务注册、实例状态变更等操作会触发 Raft 协议，保障集群数据一致性：</p>
<ul>
<li><strong>Leader 选举</strong>：集群节点通过 Raft 选举产生 Leader，由 Leader 统一处理客户端请求并协调数据同步；</li>
<li><strong>日志复制</strong>：Leader 将数据变更记录为日志，同步至所有 Follower 节点，待多数节点确认后才提交变更（如写入注册表）；</li>
<li>基于 Raft 协议，Nacos 集群在节点故障、网络分区时仍能保证数据一致，实现高可靠服务治理。</li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
        <tag>微服务</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/08/27/Nacos2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nacos-2-X-核心源码学习笔记"><a href="#Nacos-2-X-核心源码学习笔记" class="headerlink" title="Nacos 2.X 核心源码学习笔记"></a>Nacos 2.X 核心源码学习笔记</h1><hr>
<h2 id="title-Nacos-2-X-核心源码学习笔记date-2025-08-27-23-11-00categories-中间件tags-Nacos-源码剖析-分布式服务治理"><a href="#title-Nacos-2-X-核心源码学习笔记date-2025-08-27-23-11-00categories-中间件tags-Nacos-源码剖析-分布式服务治理" class="headerlink" title="title: Nacos 2.X 核心源码学习笔记date: 2025-08-27 23:11:00categories: 中间件tags:- Nacos- 源码剖析- 分布式服务治理"></a>title: Nacos 2.X 核心源码学习笔记<br>date: 2025-08-27 23:11:00<br>categories: 中间件<br>tags:<br>- Nacos<br>- 源码剖析<br>- 分布式服务治理</h2><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Nacos 作为阿里开源的分布式服务发现与配置管理平台，2.X 版本在架构上进行了协议升级（HTTP→gRPC）、存储结构优化（嵌套 Map→扁平分层）、一致性增强（Distro→Raft）</p>
<p>Nacos 2.X 主要核心优化：</p>
<ol>
<li>协议升级：gRPC 长连接替代 HTTP，降低通信开销，提升实时性；</li>
<li>存储优化：扁平分层注册表替代嵌套 Map，提升查询与同步效率；</li>
<li>事件驱动：解耦模块依赖，增强扩展性；</li>
<li>健康检查：服务端主动探活替代客户端心跳，减少客户端负担；</li>
<li>一致性增强：Raft+Distro 混合协议，平衡一致性与性能。</li>
</ol>
<h2 id="二、服务注册核心源码剖析"><a href="#二、服务注册核心源码剖析" class="headerlink" title="二、服务注册核心源码剖析"></a>二、服务注册核心源码剖析</h2><p>服务注册是 Nacos 的基础能力，2.X 版本通过 gRPC 长连接异步通信替代 1.X 的 HTTP 短连接，同时优化了实例存储与一致性逻辑。</p>
<h3 id="（一）客户端：发起注册请求"><a href="#（一）客户端：发起注册请求" class="headerlink" title="（一）客户端：发起注册请求"></a>（一）客户端：发起注册请求</h3><p>客户端核心是封装实例信息、建立 gRPC 连接并发送注册请求，关键类集中在 <code>nacos-naming-client</code> 模块。</p>
<ol>
<li>入口类：<code>NacosNamingService</code></li>
</ol>
<p>客户端对外暴露的注册入口，负责参数预处理与代理分发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务唯一标识：group@@serviceName（Nacos 服务的核心命名规则）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 补全实例默认值（如集群名默认值、命名空间）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.getClusterName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setClusterName(ClusterUtils.getDefaultClusterName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instance.getNamespaceId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setNamespaceId(<span class="built_in">this</span>.namespace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 委托 gRPC 代理发送注册请求（核心逻辑）</span></span><br><span class="line">    namingClientProxy.registerInstance(groupedServiceName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>gRPC 代理：<code>NamingGrpcClientProxy</code></li>
</ol>
<p>负责将注册请求封装为 gRPC 协议格式，通过长连接发送至服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 gRPC 注册请求（ProtoBuf 格式，适配 gRPC 传输）</span></span><br><span class="line">    <span class="type">RegisterInstanceRequest</span> <span class="variable">request</span> <span class="operator">=</span> RegisterInstanceRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setInstance(GrpcUtils.convertInstanceToProto(instance)) <span class="comment">// 实例信息转 Proto</span></span><br><span class="line">            .setNamespace(instance.getNamespaceId())</span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口（失败重试由底层 GrpcUtils 实现）</span></span><br><span class="line">    GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.registerInstance(request), <span class="comment">// namingStub 是 gRPC 自动生成的客户端存根</span></span><br><span class="line">        <span class="string">&quot;registerInstance&quot;</span>, </span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关键细节：客户端初始化时会与服务端建立 gRPC 长连接（默认端口 9848），后续注册、心跳、订阅均复用该连接，减少 TCP 握手开销。</li>
</ul>
<h3 id="（二）服务端：处理注册请求"><a href="#（二）服务端：处理注册请求" class="headerlink" title="（二）服务端：处理注册请求"></a>（二）服务端：处理注册请求</h3><p>服务端核心是接收 gRPC 请求、校验参数、分层存储实例，并触发事件通知与集群同步，关键类集中在 <code>nacos-naming-core</code> 模块。</p>
<ol>
<li>gRPC 请求入口：<code>NamingGrpcService</code></li>
</ol>
<p>服务端 gRPC 服务实现类，负责接收客户端请求并转发至业务逻辑层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.controllers.v2.grpc.NamingGrpcService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(RegisterInstanceRequest request, StreamObserver&lt;CommonResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="type">CommonResponse</span> <span class="variable">response</span> <span class="operator">=</span> CommonResponse.newBuilder().build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 解析请求参数（服务名、命名空间、实例信息）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> GrpcUtils.convertProtoToInstance(request.getInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 委托 ServiceManager 处理注册核心逻辑</span></span><br><span class="line">        serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回成功响应</span></span><br><span class="line">        response.setSuccess(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;注册失败：&quot;</span> + e.getMessage());</span><br><span class="line">        log.error(<span class="string">&quot;Instance register failed&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        responseObserver.onNext(response);</span><br><span class="line">        responseObserver.onCompleted(); <span class="comment">// 结束 gRPC 流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>服务管理核心：<code>ServiceManager</code></li>
</ol>
<p>负责创建&#x2F;获取服务、调度实例注册，是服务端的”服务中枢”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 生成服务唯一 Key：namespaceId@@group@@serviceName（避免同名冲突）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 不存在则创建 Service（懒加载模式，减少内存占用）</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getOrCreateService(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将实例注册到对应集群（核心：分层存储的入口）</span></span><br><span class="line">    service.registerInstance(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 发布服务注册事件（触发后续健康检查、集群同步）</span></span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载创建 Service</span></span><br><span class="line"><span class="keyword">private</span> Service <span class="title function_">getOrCreateService</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">return</span> serviceMap.computeIfAbsent(serviceKey, key -&gt; &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">newService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">        newService.setNamespaceId(namespaceId);</span><br><span class="line">        newService.setServiceName(serviceName);</span><br><span class="line">        newService.setId(IdGenerator.generateServiceId(namespaceId, serviceName));</span><br><span class="line">        <span class="keyword">return</span> newService;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分层存储：<code>Service</code> → <code>Cluster</code> → <code>Instance</code></li>
</ol>
<p>2.X 采用”服务-集群-实例”三层结构，替代 1.X 的嵌套 Map，每个层级独立管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取/创建实例所属集群（默认集群名：DEFAULT）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> instance.getClusterName();</span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> clusters.computeIfAbsent(clusterName, key -&gt; <span class="keyword">new</span> <span class="title class_">Cluster</span>(clusterName, <span class="built_in">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将实例注册到集群（集群维护实例集合）</span></span><br><span class="line">    cluster.addInstance(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Cluster</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 实例存储容器：线程安全的 ConcurrentHashMap（key=instanceId，避免重复注册）</span></span><br><span class="line">    ConcurrentHashMap&lt;String, Instance&gt; instanceMap = getInstanceMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分临时实例与持久化实例（核心差异：是否依赖心跳）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">        <span class="comment">// 临时实例：内存存储 + 心跳绑定</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        <span class="comment">// 注册心跳检测任务（服务端主动探活）</span></span><br><span class="line">        healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, <span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 持久化实例：内存 + 本地文件持久化（重启不丢失）</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        persistInstance(instance); <span class="comment">// 持久化到 data/nacos/naming/ 目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>请求校验：隐式在业务逻辑中</li>
</ol>
<p>2.X 未单独封装 <code>InstanceValidator</code>，而是在实例注册前通过 参数非空校验+格式校验 确保合法性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cluster.addInstance 中隐含的校验逻辑（简化）</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(instance.getIp()) || instance.getPort() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;IP/端口不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instance.getWeight() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;权重不能为负数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、事件驱动架构剖析"><a href="#三、事件驱动架构剖析" class="headerlink" title="三、事件驱动架构剖析"></a>三、事件驱动架构剖析</h2><p>Nacos 2.X 基于 “事件发布-订阅”模式 解耦模块依赖，核心由「事件、事件总线、发布者、订阅者」四部分组成，所有核心流程（注册、健康检查、同步）均通过事件触发。</p>
<h3 id="（一）事件：状态变化的载体"><a href="#（一）事件：状态变化的载体" class="headerlink" title="（一）事件：状态变化的载体"></a>（一）事件：状态变化的载体</h3><p>事件是系统状态变化的封装，所有事件均继承自顶层接口 <code>Event</code>，核心事件类如下：</p>
<table>
<thead>
<tr>
<th>事件类</th>
<th>触发场景</th>
<th>核心属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServiceInstanceEvent</code></td>
<td>服务实例注册&#x2F;更新&#x2F;删除</td>
<td><code>service</code>（服务）、<code>instance</code>（实例）</td>
</tr>
<tr>
<td><code>HealthStateChangeEvent</code></td>
<td>实例健康状态变更（健康→不健康）</td>
<td><code>instanceId</code>、<code>newHealthyState</code></td>
</tr>
<tr>
<td><code>ConfigDataChangeEvent</code></td>
<td>配置中心数据变更</td>
<td><code>dataId</code>、<code>group</code>、<code>content</code></td>
</tr>
</tbody></table>
<p>示例：服务实例注册事件定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.event.ServiceInstanceRegisteredEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInstanceRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">AbstractEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service service;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInstanceRegisteredEvent</span><span class="params">(Service service, Instance instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）事件总线：事件路由的核心"><a href="#（二）事件总线：事件路由的核心" class="headerlink" title="（二）事件总线：事件路由的核心"></a>（二）事件总线：事件路由的核心</h3><p>事件总线负责连接发布者与订阅者，提供事件注册、发布、路由能力，核心实现类为 <code>NacosEventBus</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.common.event.NacosEventBus</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosEventBus</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventBus</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：事件类型 → 订阅者列表（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;, CopyOnWriteArrayList&lt;Subscriber&gt;&gt; subscriberMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 注册订阅者（根据事件类型关联）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Subscriber subscriber)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = subscriber.getSubscribeType();</span><br><span class="line">        subscriberMap.computeIfAbsent(eventType, key -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;())</span><br><span class="line">                     .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发布事件（路由到对应订阅者）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = event.getClass();</span><br><span class="line">        <span class="comment">// 找到订阅该事件的所有订阅者</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscriber&gt; subscribers = subscriberMap.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscribers == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步触发订阅者的事件处理（默认线程池：EventExecutor）</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            EventExecutor.execute(() -&gt; subscriber.onEvent(event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）发布者：事件的产生者"><a href="#（三）发布者：事件的产生者" class="headerlink" title="（三）发布者：事件的产生者"></a>（三）发布者：事件的产生者</h3><p>发布者在特定业务逻辑完成后发布事件，核心实现是 <code>EventPublisher</code> 接口，默认实现为 <code>DefaultEventPublisher</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServiceManager 中发布注册事件的逻辑（前文已提及）</span></span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br></pre></td></tr></table></figure>

<p>常见发布场景：</p>
<ul>
<li>服务注册完成 → 发布 <code>ServiceInstanceRegisteredEvent</code></li>
<li>实例健康状态变更 → 发布 <code>HealthStateChangeEvent</code></li>
<li>配置数据更新 → 发布 <code>ConfigDataChangeEvent</code></li>
</ul>
<h3 id="（四）订阅者：事件的消费者"><a href="#（四）订阅者：事件的消费者" class="headerlink" title="（四）订阅者：事件的消费者"></a>（四）订阅者：事件的消费者</h3><p>订阅者通过 实现 <code>Subscriber</code> 接口 或 添加 <code>@EventListener</code> 注解 订阅事件，核心是编写事件处理逻辑。</p>
<p>示例：健康检查订阅者（监听注册事件，初始化探活任务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.subscriber.InstanceRegisteredSubscriber</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceRegisteredSubscriber</span> <span class="keyword">implements</span> <span class="title class_">Subscriber</span>&lt;ServiceInstanceRegisteredEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckReactor healthCheckReactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅的事件类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; getSubscribeType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceRegisteredEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ServiceInstanceRegisteredEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> event.getInstance();</span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> event.getService().getCluster(instance.getClusterName());</span><br><span class="line">        <span class="comment">// 为临时实例添加 gRPC 探活任务</span></span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, cluster));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关键优势：模块间无需硬编码依赖（如注册模块不直接调用健康检查模块），只需通过事件交互，扩展性极强。</li>
</ul>
<h2 id="四、注册表结构变动剖析"><a href="#四、注册表结构变动剖析" class="headerlink" title="四、注册表结构变动剖析"></a>四、注册表结构变动剖析</h2><p>Nacos 2.X 对注册表的优化是性能提升的核心，主要解决 1.X 嵌套 Map 带来的 深拷贝开销大、查询效率低 问题。</p>
<h3 id="（一）旧结构（1-X）：嵌套-Map-的痛点"><a href="#（一）旧结构（1-X）：嵌套-Map-的痛点" class="headerlink" title="（一）旧结构（1.X）：嵌套 Map 的痛点"></a>（一）旧结构（1.X）：嵌套 Map 的痛点</h3><p>1.X 注册表采用 四层嵌套 Map，结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.X 注册表结构（简化）</span></span><br><span class="line">Map&lt;String, Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Instance&gt;&gt;&gt;&gt;&gt; registry;</span><br><span class="line"><span class="comment">// 层级：namespace → group → service → cluster → instanceList</span></span><br></pre></td></tr></table></figure>

<ul>
<li>痛点：</li>
</ul>
<ol>
<li>查询实例需逐层遍历（如 <code>registry.get(namespace).get(group).get(service).get(cluster)</code>），效率低；</li>
<li>数据同步&#x2F;备份时需深拷贝整个嵌套结构，内存与时间开销大；</li>
<li>新增维度（如元数据）需修改多层结构，扩展性差。</li>
</ol>
<h3 id="（二）新结构（2-X）：扁平分层存储"><a href="#（二）新结构（2-X）：扁平分层存储" class="headerlink" title="（二）新结构（2.X）：扁平分层存储"></a>（二）新结构（2.X）：扁平分层存储</h3><p>2.X 将注册表拆分为 独立的分层存储单元，通过 唯一 Key 关联，核心实现类为 <code>ServiceStorage</code>：</p>
<ol>
<li>核心存储结构</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.storage.ServiceStorage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceStorage</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式（注册表全局唯一）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ServiceStorage</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStorage</span>();</span><br><span class="line">    <span class="comment">// 存储：namespace → (serviceKey → ServiceInfo)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Namespace, ConcurrentHashMap&lt;Service, ServiceInfo&gt;&gt; namespaceServiceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务实例列表（通过 namespace + service 直接定位）</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(Namespace namespace, Service service)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;Service, ServiceInfo&gt; serviceInfoMap = namespaceServiceInfoMap.get(namespace);</span><br><span class="line">        <span class="keyword">if</span> (serviceInfoMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增/更新服务实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putServiceInfo</span><span class="params">(Namespace namespace, Service service, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        namespaceServiceInfoMap.computeIfAbsent(namespace, key -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;())</span><br><span class="line">                               .put(service, serviceInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>联合 Key 设计</li>
</ol>
<p>通过 <code>ServiceKeyGenerator</code> 生成 全局唯一 Key，替代多层嵌套的定位逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceKeyGenerator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceKeyGenerator</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 serviceKey：namespaceId@@groupName@@serviceName</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateServiceKey</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 serviceName 中解析出 groupName（serviceName 格式：group@@service）</span></span><br><span class="line">        String[] parts = serviceName.split(<span class="string">&quot;@@&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">0</span>] : Constants.DEFAULT_GROUP;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pureServiceName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">1</span>] : parts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s@@%s@@%s&quot;</span>, namespaceId, groupName, pureServiceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>优化效果</li>
</ol>
<ul>
<li>查询效率：从 O(n^4) 嵌套遍历降至 O(1) 哈希查询；</li>
<li>同步开销：数据同步时只需传输单个 <code>ServiceInfo</code> 对象，无需深拷贝；</li>
<li>扩展性：新增维度（如实例标签）只需在 <code>Instance</code> 类加字段，不影响存储结构。</li>
</ul>
<h2 id="五、服务发现与订阅核心源码剖析"><a href="#五、服务发现与订阅核心源码剖析" class="headerlink" title="五、服务发现与订阅核心源码剖析"></a>五、服务发现与订阅核心源码剖析</h2><p>服务发现是客户端获取健康实例的过程，2.X 通过 gRPC 长连接+主动推送 替代 1.X 的 HTTP 轮询，实时性与效率大幅提升。</p>
<h3 id="（一）通信方式转变：HTTP-→-gRPC"><a href="#（一）通信方式转变：HTTP-→-gRPC" class="headerlink" title="（一）通信方式转变：HTTP → gRPC"></a>（一）通信方式转变：HTTP → gRPC</h3><p>2.X 客户端默认使用 <code>RpcNamingClientProxy</code>（gRPC 代理），仅在兼容模式下使用 <code>HttpNamingClientProxy</code>，核心优势：</p>
<ul>
<li>长连接复用：减少 TCP 握手与挥手开销；</li>
<li>二进制传输：ProtoBuf 格式比 JSON 体积小 30%+；</li>
<li>主动推送：服务变动时服务端主动推送，无需客户端轮询。</li>
</ul>
<h3 id="（二）服务发现逻辑"><a href="#（二）服务发现逻辑" class="headerlink" title="（二）服务发现逻辑"></a>（二）服务发现逻辑</h3><p>客户端通过 gRPC 向服务端查询实例，服务端从注册表过滤健康实例后返回。</p>
<ol>
<li>客户端查询入口：<code>NacosNamingService</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 委托 gRPC 代理查询</span></span><br><span class="line">    <span class="keyword">return</span> namingClientProxy.selectInstances(groupedServiceName, healthy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>gRPC 代理查询实现：<code>RpcNamingClientProxy</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.RpcNamingClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建查询请求（指定服务名、健康状态过滤）</span></span><br><span class="line">    <span class="type">QueryInstancesRequest</span> <span class="variable">request</span> <span class="operator">=</span> QueryInstancesRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setNamespace(namespace)</span><br><span class="line">            .setHealthyOnly(healthy) <span class="comment">// 只返回健康实例</span></span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口</span></span><br><span class="line">    <span class="type">QueryInstancesResponse</span> <span class="variable">response</span> <span class="operator">=</span> GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.queryInstances(request),</span><br><span class="line">        <span class="string">&quot;queryInstances&quot;</span>,</span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 解析响应，返回实例列表</span></span><br><span class="line">    <span class="keyword">return</span> response.getInstancesList().stream()</span><br><span class="line">            .map(GrpcUtils::convertProtoToInstance)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>服务端查询处理：<code>InstanceQueryHandler</code></li>
</ol>
<p>服务端接收查询请求后，从注册表过滤实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.remote.rpc.handler.InstanceQueryHandler</span></span><br><span class="line"><span class="keyword">public</span> QueryInstancesResponse <span class="title function_">handle</span><span class="params">(QueryInstancesRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">healthyOnly</span> <span class="operator">=</span> request.isHealthyOnly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取服务信息</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> QueryInstancesResponse.newBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 过滤实例（健康状态、权重&gt;0）</span></span><br><span class="line">    List&lt;Instance&gt; filteredInstances = service.getAllInstances().stream()</span><br><span class="line">            .filter(instance -&gt; !healthyOnly || instance.isHealthy()) <span class="comment">// 健康状态过滤</span></span><br><span class="line">            .filter(instance -&gt; instance.getWeight() &gt; <span class="number">0</span>) <span class="comment">// 权重过滤</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 构建响应</span></span><br><span class="line">    <span class="keyword">return</span> QueryInstancesResponse.newBuilder()</span><br><span class="line">            .addAllInstances(GrpcUtils.convertInstancesToProtos(filteredInstances))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）服务订阅逻辑"><a href="#（三）服务订阅逻辑" class="headerlink" title="（三）服务订阅逻辑"></a>（三）服务订阅逻辑</h3><p>订阅是”一次订阅，持续接收更新”的机制，客户端注册监听器，服务端变动时主动推送。</p>
<ol>
<li>客户端订阅入口：<code>NacosNamingService</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String groupName, EventListener listener)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 1. 本地注册监听器（避免重复订阅）</span></span><br><span class="line">    subscriptionManager.subscribe(groupedServiceName, listener);</span><br><span class="line">    <span class="comment">// 2. 向服务端发起订阅请求（建立推送关系）</span></span><br><span class="line">    namingClientProxy.subscribe(groupedServiceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>服务端订阅管理：<code>SubscriptionManager</code></li>
</ol>
<p>服务端存储”服务-客户端”订阅关系，核心是 <code>ConcurrentHashMap</code> 映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 订阅该服务的客户端集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Subscriber&gt;&gt; serviceSubscribers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册订阅关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceKey, Subscriber subscriber)</span> &#123;</span><br><span class="line">        serviceSubscribers.computeIfAbsent(serviceKey, key -&gt; ConcurrentHashMap.newKeySet())</span><br><span class="line">                          .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务的所有订阅者（用于推送）</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Subscriber&gt; <span class="title function_">getSubscribers</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceSubscribers.getOrDefault(serviceKey, Collections.emptySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>服务端推送触发：事件驱动</li>
</ol>
<p>当服务实例变动时，通过事件触发推送逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.PushService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听实例变更事件，触发推送</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInstanceChange</span><span class="params">(ServiceInstanceEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> event.getService();</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(service.getNamespaceId(), service.getServiceName());</span><br><span class="line">        <span class="comment">// 1. 获取订阅该服务的所有客户端</span></span><br><span class="line">        Set&lt;Subscriber&gt; subscribers = subscriptionManager.getSubscribers(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (subscribers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建推送数据（最新实例列表）</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> serviceStorage.getServiceInfo(service.getNamespaceId(), service);</span><br><span class="line">        <span class="comment">// 3. 通过 gRPC 向客户端推送</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            pushToClient(subscriber, serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 推送实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushToClient</span><span class="params">(Subscriber subscriber, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">ServiceChangeResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServiceChangeResponse.newBuilder()</span><br><span class="line">                .setServiceInfo(GrpcUtils.convertServiceInfoToProto(serviceInfo))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 通过客户端的 gRPC 连接推送</span></span><br><span class="line">        subscriber.getGrpcChannel().writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、服务变动推送订阅客户端源码剖析"><a href="#六、服务变动推送订阅客户端源码剖析" class="headerlink" title="六、服务变动推送订阅客户端源码剖析"></a>六、服务变动推送订阅客户端源码剖析</h2><p>客户端接收服务端推送的核心是 gRPC 流监听+本地缓存更新+监听器回调，关键类集中在 <code>nacos-naming-client</code> 模块。</p>
<h3 id="（一）推送接收：NamingPushResponseHandler"><a href="#（一）推送接收：NamingPushResponseHandler" class="headerlink" title="（一）推送接收：NamingPushResponseHandler"></a>（一）推送接收：<code>NamingPushResponseHandler</code></h3><p>客户端通过 gRPC 流观察者监听服务端推送，核心是 <code>onNext</code> 方法（推送消息接收入口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingPushResponseHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NamingPushResponseHandler</span> <span class="keyword">implements</span> <span class="title class_">StreamObserver</span>&lt;ServiceChangeResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfoHolder serviceInfoHolder; <span class="comment">// 本地缓存管理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager; <span class="comment">// 本地监听器管理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务端推送的变动消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(ServiceChangeResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 解析推送数据（Proto → ServiceInfo）</span></span><br><span class="line">            <span class="type">ServiceInfoProto</span> <span class="variable">serviceInfoProto</span> <span class="operator">=</span> response.getServiceInfo();</span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">newServiceInfo</span> <span class="operator">=</span> GrpcUtils.convertProtoToServiceInfo(serviceInfoProto);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 更新本地缓存（覆盖旧数据，保证一致性）</span></span><br><span class="line">            serviceInfoHolder.processServiceInfo(newServiceInfo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 触发本地监听器回调（通知业务层）</span></span><br><span class="line">            subscriptionManager.notifyListeners(newServiceInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;处理服务推送失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流异常处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;gRPC 推送流异常&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流关闭处理（重连机制）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;gRPC 推送流关闭，尝试重连&quot;</span>);</span><br><span class="line">        reconnect(); <span class="comment">// 内部实现重连逻辑，确保推送不中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）本地缓存更新：ServiceInfoHolder"><a href="#（二）本地缓存更新：ServiceInfoHolder" class="headerlink" title="（二）本地缓存更新：ServiceInfoHolder"></a>（二）本地缓存更新：<code>ServiceInfoHolder</code></h3><p>客户端维护本地实例缓存，避免重复查询服务端，核心是 <code>serviceInfoMap</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.cache.ServiceInfoHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfoHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 本地缓存：serviceKey → ServiceInfo（serviceKey 格式：group@@service@@cluster）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ServiceInfo&gt; serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新缓存（版本校验，避免旧数据覆盖新数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processServiceInfo</span><span class="params">(ServiceInfo newServiceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> newServiceInfo.getKey();</span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldServiceInfo</span> <span class="operator">=</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 版本校验：仅更新比本地新的数据（lastRefTime 为数据最后更新时间）</span></span><br><span class="line">        <span class="keyword">if</span> (oldServiceInfo != <span class="literal">null</span> &amp;&amp; newServiceInfo.getLastRefTime() &lt;= oldServiceInfo.getLastRefTime()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        serviceInfoMap.put(serviceKey, newServiceInfo);</span><br><span class="line">        newServiceInfo.setLastRefTime(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地缓存的实例列表</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）监听器回调：SubscriptionManager"><a href="#（三）监听器回调：SubscriptionManager" class="headerlink" title="（三）监听器回调：SubscriptionManager"></a>（三）监听器回调：<code>SubscriptionManager</code></h3><p>客户端通知业务层服务变动，核心是遍历监听器并调用 <code>onEvent</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.subscription.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 监听器集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;EventListener&gt;&gt; listenerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发监听器回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyListeners</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> serviceInfo.getKey();</span><br><span class="line">        Set&lt;EventListener&gt; listeners = listenerMap.get(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历监听器，触发业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.onEvent(<span class="keyword">new</span> <span class="title class_">NamingEvent</span>(serviceInfo.getName(), serviceInfo.getHosts()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;监听器回调失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>业务层示例：客户端通过实现 <code>EventListener</code> 感知变动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层订阅示例</span></span><br><span class="line">namingService.subscribe(<span class="string">&quot;user-service&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="type">NamingEvent</span> <span class="variable">namingEvent</span> <span class="operator">=</span> (NamingEvent) event;</span><br><span class="line">        List&lt;Instance&gt; instances = namingEvent.getInstances();</span><br><span class="line">        <span class="comment">// 业务逻辑：更新本地服务列表、重新计算负载均衡等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务变动，新实例列表：&quot;</span> + instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="七、服务端健康检查源码剖析"><a href="#七、服务端健康检查源码剖析" class="headerlink" title="七、服务端健康检查源码剖析"></a>七、服务端健康检查源码剖析</h2><p>Nacos 2.X 健康检查从 客户端主动心跳 改为 服务端主动探活，减少客户端开销，同时提高探活准确性。</p>
<h3 id="（一）核心机制：服务端-gRPC-主动探活"><a href="#（一）核心机制：服务端-gRPC-主动探活" class="headerlink" title="（一）核心机制：服务端 gRPC 主动探活"></a>（一）核心机制：服务端 gRPC 主动探活</h3><p>2.X 对临时实例（默认）采用 gRPC 探活，对持久化实例采用 HTTP 探活（可配置），核心由 <code>HealthCheckReactor</code> 调度探活任务。</p>
<h3 id="（二）探活任务管理：HealthCheckReactor"><a href="#（二）探活任务管理：HealthCheckReactor" class="headerlink" title="（二）探活任务管理：HealthCheckReactor"></a>（二）探活任务管理：<code>HealthCheckReactor</code></h3><p>负责创建、调度探活任务，采用线程池异步执行，避免阻塞主线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.HealthCheckReactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthCheckReactor</span> &#123;</span><br><span class="line">    <span class="comment">// 探活线程池（核心线程数：CPU 核心数 * 2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">healthCheckExecutor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;nacos-health-check-%d&quot;</span>).build()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加探活任务（延迟 0 秒，周期 20 秒执行一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHealthCheckTask</span><span class="params">(HealthCheckTask task)</span> &#123;</span><br><span class="line">        healthCheckExecutor.scheduleAtFixedRate(</span><br><span class="line">            task,</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 初始延迟</span></span><br><span class="line">            <span class="number">20000</span>, <span class="comment">// 周期（20 秒，默认值）</span></span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）gRPC-探活实现：GrpcHealthCheckTask"><a href="#（三）gRPC-探活实现：GrpcHealthCheckTask" class="headerlink" title="（三）gRPC 探活实现：GrpcHealthCheckTask"></a>（三）gRPC 探活实现：<code>GrpcHealthCheckTask</code></h3><p>临时实例的探活任务，通过 gRPC 向客户端发送探活请求，判断实例是否存活：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.processor.GrpcHealthCheckTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcHealthCheckTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line">    <span class="comment">// 探活超时时间（5 秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建 gRPC 探活请求</span></span><br><span class="line">            <span class="type">HealthCheckRequest</span> <span class="variable">request</span> <span class="operator">=</span> HealthCheckRequest.newBuilder()</span><br><span class="line">                    .setInstanceId(instance.getInstanceId())</span><br><span class="line">                    .build();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 向实例发送探活请求（客户端需实现 gRPC 健康检查接口）</span></span><br><span class="line">            <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> GrpcChannelFactory.getChannel(instance.getIp(), instance.getPort());</span><br><span class="line">            HealthCheckGrpc.<span class="type">HealthCheckBlockingStub</span> <span class="variable">stub</span> <span class="operator">=</span> HealthCheckGrpc.newBlockingStub(channel)</span><br><span class="line">                    .withDeadlineAfter(TIMEOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="type">HealthCheckResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.check(request);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 更新实例健康状态</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newHealthy</span> <span class="operator">=</span> response.getStatus() == HealthCheckResponse.ServingStatus.SERVING;</span><br><span class="line">            updateInstanceHealthStatus(newHealthy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 探活失败，标记为不健康</span></span><br><span class="line">            updateInstanceHealthStatus(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新实例健康状态并发布事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInstanceHealthStatus</span><span class="params">(<span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oldHealthy</span> <span class="operator">=</span> instance.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (oldHealthy == healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 状态无变化，不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新健康状态</span></span><br><span class="line">        instance.setHealthy(healthy);</span><br><span class="line">        <span class="comment">// 发布健康状态变更事件（触发推送、集群同步）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">HealthStateChangeEvent</span>(instance.getInstanceId(), healthy));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（四）健康状态判断与实例剔除"><a href="#（四）健康状态判断与实例剔除" class="headerlink" title="（四）健康状态判断与实例剔除"></a>（四）健康状态判断与实例剔除</h3><p>服务端通过 “探活失败次数” 而非固定时间判断实例状态，默认规则：</p>
<ol>
<li>连续 1 次探活失败 → 标记实例为 <code>healthy=false</code>；</li>
<li>连续 3 次探活失败（累计 60 秒） → 从注册表中移除实例（仅临时实例）；</li>
<li>持久化实例探活失败不会被剔除，仅标记为不健康。</li>
</ol>
<p>实例剔除逻辑在 <code>InstanceCleaner</code> 中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.InstanceCleaner</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCleaner</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceManager serviceManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听健康状态变更事件，触发剔除判断</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHealthChange</span><span class="params">(HealthStateChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">instanceId</span> <span class="operator">=</span> event.getInstanceId();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> event.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询实例</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> instanceManager.getInstanceById(instanceId);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span> || !instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累计探活失败次数</span></span><br><span class="line">        instance.incrementHealthFailureCount();</span><br><span class="line">        <span class="comment">// 连续 3 次失败，剔除实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance.getHealthFailureCount() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            serviceManager.removeInstance(instance.getNamespaceId(), instance.getServiceName(), instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、服务变动集群同步源码剖析"><a href="#八、服务变动集群同步源码剖析" class="headerlink" title="八、服务变动集群同步源码剖析"></a>八、服务变动集群同步源码剖析</h2><p>Nacos 2.X 集群同步采用 “Raft 协议（持久化实例）+ Distro 协议（临时实例）” 混合方案，确保数据一致性与性能平衡。</p>
<h3 id="（一）临时实例同步：Distro-协议"><a href="#（一）临时实例同步：Distro-协议" class="headerlink" title="（一）临时实例同步：Distro 协议"></a>（一）临时实例同步：Distro 协议</h3><p>临时实例存储在内存，通过 Distro 协议实现 最终一致性 同步，核心是”分片+主动推送”。</p>
<ol>
<li>Distro 分片策略</li>
</ol>
<p>每个 Nacos 节点负责部分实例的同步（按 <code>instanceId</code> 哈希分片），避免全量同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroHashMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroHashMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 instanceId 计算分片，确定负责节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">mapInstanceToServers</span><span class="params">(String instanceId, List&lt;String&gt; allServers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> Math.abs(instanceId.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % allServers.size();</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(allServers.get(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同步实现：<code>DistroDataSyncService</code></li>
</ol>
<p>当临时实例变动时，节点向负责该实例的其他节点推送同步数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroDataSyncService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroDataSyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DistroHashMapper hashMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GrpcClient grpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步临时实例变动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncEphemeralInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 计算负责该实例的节点</span></span><br><span class="line">        List&lt;String&gt; targetServers = hashMapper.mapInstanceToServers(instance.getInstanceId(), serverListManager.getServerList());</span><br><span class="line">        <span class="comment">// 2. 构建同步数据</span></span><br><span class="line">        <span class="type">DistroData</span> <span class="variable">data</span> <span class="operator">=</span> DistroDataBuilder.buildInstanceData(instance);</span><br><span class="line">        <span class="comment">// 3. 向目标节点推送同步请求</span></span><br><span class="line">        <span class="keyword">for</span> (String server : targetServers) &#123;</span><br><span class="line">            syncToServer(server, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 同步请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">syncToServer</span><span class="params">(String server, DistroData data)</span> &#123;</span><br><span class="line">        <span class="type">DistroSyncRequest</span> <span class="variable">request</span> <span class="operator">=</span> DistroSyncRequest.newBuilder()</span><br><span class="line">                .setData(ByteString.copyFrom(data.getContent()))</span><br><span class="line">                .build();</span><br><span class="line">        grpcClient.sendRequest(server, request, DistroSyncResponse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）持久化实例同步：Raft-协议"><a href="#（二）持久化实例同步：Raft-协议" class="headerlink" title="（二）持久化实例同步：Raft 协议"></a>（二）持久化实例同步：Raft 协议</h3><p>持久化实例存储在 MySQL，通过 Raft 协议实现 强一致性 同步，确保所有节点数据一致。</p>
<ol>
<li>Raft 核心实现：<code>RaftCore</code></li>
</ol>
<p>负责 Raft 协议的 ** Leader 选举、日志复制、数据提交**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.raft.RaftCore</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaftCore</span> &#123;</span><br><span class="line">    <span class="comment">// Raft 状态（FOLLOWER/CANDIDATE/LEADER）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RaftPeer.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> RaftPeer.State.FOLLOWER;</span><br><span class="line">    <span class="comment">// Raft 日志（存储所有变更操作）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Leader 选举（省略细节，核心是投票机制）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 触发选举逻辑，获取其他节点投票，得票超过半数成为 Leader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 日志复制（Leader 向 Follower 同步日志）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replicateLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != RaftPeer.State.LEADER) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;非 Leader 节点，无法复制日志&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加日志到本地</span></span><br><span class="line">        logEntries.add(entry);</span><br><span class="line">        <span class="comment">// 向所有 Follower 节点复制日志</span></span><br><span class="line">        <span class="keyword">for</span> (String follower : followerList) &#123;</span><br><span class="line">            replicateToFollower(follower, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 数据提交（日志复制到多数节点后，提交数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查日志是否已复制到多数节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLogReplicatedToMajority(entry.getIndex())) &#123;</span><br><span class="line">            <span class="comment">// 提交日志（更新本地注册表）</span></span><br><span class="line">            commitEntry(entry);</span><br><span class="line">            <span class="comment">// 通知 Follower 提交日志</span></span><br><span class="line">            notifyFollowersCommit(entry.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>持久化实例同步触发</li>
</ol>
<p>当持久化实例变动时，Leader 节点通过 Raft 日志复制同步到所有 Follower 节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.RaftConsistencyServiceImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 Raft 日志条目</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> LogEntry.newBuilder()</span><br><span class="line">            .setKey(key)</span><br><span class="line">            .setValue(ByteString.copyFrom(SerializeUtils.serialize(value)))</span><br><span class="line">            .setType(LogEntryType.WRITE)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2. Leader 节点复制日志</span></span><br><span class="line">    raftCore.replicateLog(entry);</span><br><span class="line">    <span class="comment">// 3. 等待日志提交</span></span><br><span class="line">    raftCore.waitForLogCommit(entry.getIndex(), <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Python 基础教程</title>
    <url>/2025/05/03/Python-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2025-05-04-Python-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Python-基础教程"><a href="#Python-基础教程" class="headerlink" title="Python 基础教程"></a>Python 基础教程</h1><p>Python 是一种简单易学、功能强大的编程语言。它拥有高效的高级数据结构，并且能够用简单而有效的方式进行面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。</p>
<h2 id="Python-的特点"><a href="#Python-的特点" class="headerlink" title="Python 的特点"></a>Python 的特点</h2><ul>
<li>简单易学：Python 有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li>
<li>免费开源：Python 是 FLOSS（自由&#x2F;开放源码软件）之一。</li>
<li>可移植性：基于其开放源代码的特性，Python 已经被移植到许多平台上。</li>
<li>丰富的库：Python 标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV 文件、密码系统、GUI（图形用户界面）、Tk 和其他与系统有关的操作。</li>
</ul>
<h2 id="第一个-Python-程序"><a href="#第一个-Python-程序" class="headerlink" title="第一个 Python 程序"></a>第一个 Python 程序</h2><p>让我们从经典的 “Hello, World!” 开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行这段代码，你会在控制台看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h2 id="Python-基本语法"><a href="#Python-基本语法" class="headerlink" title="Python 基本语法"></a>Python 基本语法</h2><h3 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h3><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 整数</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="comment"># 浮点数</span></span><br><span class="line">y = <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">name = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="comment"># 布尔值</span></span><br><span class="line">is_python = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Python 使用缩进来表示代码块，而不是使用大括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 是正数&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 是负数&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 是零&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Python 提供了 for 循环和 while 循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python 是一个功能强大且易于学习的编程语言，适合初学者和专业开发者。它的简洁语法和丰富的库使得开发过程更加高效和愉快。</p>
<p>希望这篇教程能帮助你开始 Python 编程之旅！如果你有任何问题，欢迎在评论区留言。</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>编程入门</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度工作》读书笔记</title>
    <url>/2024/05/04/reading-deep-work-notes/2025-05-04-reading-deep-work-notes/</url>
    <content><![CDATA[<h1 id="《深度工作》读书笔记"><a href="#《深度工作》读书笔记" class="headerlink" title="《深度工作》读书笔记"></a>《深度工作》读书笔记</h1><blockquote>
<p>作者：Cal Newport<br>出版年份：2016<br>推荐指数：⭐⭐⭐⭐⭐</p>
</blockquote>
<h2 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h2><p>深度工作是指在无干扰的状态下专注进行职业活动的能力，能够创造新价值，提升技能，而且难以复制。</p>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ol>
<li>深度工作 vs 浅度工作</li>
<li>注意力残留</li>
<li>心流状态</li>
</ol>
<h2 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h2><h3 id="1-培养深度工作习惯"><a href="#1-培养深度工作习惯" class="headerlink" title="1. 培养深度工作习惯"></a>1. 培养深度工作习惯</h3><ul>
<li>固定时间段</li>
<li>远离干扰源</li>
<li>创造仪式感</li>
</ul>
<h3 id="2-管理精力而非时间"><a href="#2-管理精力而非时间" class="headerlink" title="2. 管理精力而非时间"></a>2. 管理精力而非时间</h3><ul>
<li>识别最佳工作时段</li>
<li>合理安排休息</li>
<li>保持规律作息</li>
</ul>
<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>这本书改变了我对工作方式的认知…</p>
<span id="more"></span>

<h2 id="行动清单"><a href="#行动清单" class="headerlink" title="行动清单"></a>行动清单</h2><ul>
<li><input disabled="" type="checkbox"> 制定每日深度工作时间表</li>
<li><input disabled="" type="checkbox"> 创建专注工作环境</li>
<li><input disabled="" type="checkbox"> 培养深度工作习惯</li>
</ul>
<h2 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h2><blockquote>
<p>“Professional activities performed in a state of distraction-free concentration that push your cognitive capabilities to their limit.”</p>
</blockquote>
<hr>
<p>推荐阅读：</p>
<ul>
<li>《原子习惯》</li>
<li>《刻意练习》</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>自我提升</tag>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门指南</title>
    <url>/2024/05/04/tech-getting-started-with-python/2025-05-04-tech-getting-started-with-python/</url>
    <content><![CDATA[<h1 id="Python入门指南"><a href="#Python入门指南" class="headerlink" title="Python入门指南"></a>Python入门指南</h1><p>Python是一门优雅、简单且功能强大的编程语言。本文将带你了解Python的基础知识。</p>
<h2 id="为什么选择Python？"><a href="#为什么选择Python？" class="headerlink" title="为什么选择Python？"></a>为什么选择Python？</h2><ul>
<li>简单易学</li>
<li>可读性强</li>
<li>广泛应用</li>
<li>丰富的生态系统</li>
</ul>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><ol>
<li>下载Python</li>
<li>安装IDE</li>
<li>配置环境变量</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个简单的Python程序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">version = <span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件语句</span></span><br><span class="line"><span class="keyword">if</span> version &gt;= <span class="number">3.6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;You are using Python <span class="subst">&#123;version&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="下一步学习建议"><a href="#下一步学习建议" class="headerlink" title="下一步学习建议"></a>下一步学习建议</h2><ol>
<li>掌握基础语法</li>
<li>学习数据结构</li>
<li>了解面向对象编程</li>
<li>实践小项目</li>
</ol>
<span id="more"></span>

<h2 id="进阶内容"><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h2><p>更多内容请关注后续更新…</p>
<hr>
<p>相关阅读：</p>
<ul>
<li><a href="https://docs.python.org/">Python官方文档</a></li>
<li><a href="https://docs.python-guide.org/">Python最佳实践指南</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程入门</tag>
      </tags>
  </entry>
</search>
