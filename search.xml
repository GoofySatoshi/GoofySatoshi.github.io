<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadLocal、CAS、Atomic及并发安全</title>
      <link href="/2025/10/23/ThreadLocal%E3%80%81CAS%E3%80%81Atomic%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
      <url>/2025/10/23/ThreadLocal%E3%80%81CAS%E3%80%81Atomic%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ThreadLocal"><a href="#一、ThreadLocal" class="headerlink" title="一、ThreadLocal"></a>一、ThreadLocal</h1><h2 id="1-为什么要有ThreadLocal"><a href="#1-为什么要有ThreadLocal" class="headerlink" title="1. 为什么要有ThreadLocal ?"></a>1. 为什么要有ThreadLocal ?</h2><p>ThreadLocal的核心作用是：让变量成为“线程私有”的副本，每个线程操作自己的那份，互不干扰，以此避免多线程共享变量的安全问题；同时，线程内的变量能在任意方法里直接获取，不用一层层传参数，简化代码。</p><h2 id="2-ThreadLocal的使用"><a href="#2-ThreadLocal的使用" class="headerlink" title="2. ThreadLocal的使用"></a>2. ThreadLocal的使用</h2><p>ThreadLocal的使用非常简单，只有下面四个方法：<br>为了性能上的优化，Thread内部设置了一个ThreadLocal.ThreadLocalMap的成员变量。这样每个线程访问自己内部的变量可以无需传参即可跨方法传递使用。</p><ul><li>void set(Object value)</li><li>public Object get()</li><li>public void remove()</li><li>protected Object initialValue()</li></ul><h2 id="3-ThreadLocal的实现"><a href="#3-ThreadLocal的实现" class="headerlink" title="3. ThreadLocal的实现"></a>3. ThreadLocal的实现</h2><h3 id="1-结构设计"><a href="#1-结构设计" class="headerlink" title="1.结构设计"></a>1.结构设计</h3><p>ThreadLocal的内部实现非常有意思，每个Thread内部设置了一个ThreadLocal.ThreadLocalMap的成员变量。ThreadLocalMap内部用来存储值是一个Entry数组，可以看作是一个基于数组结构实现的哈希表,Key值为ThreadLocal,Value值为具体存储的值，下标值的计算是根据计算出的哈希值对数组长度取余</p><h3 id="2-哈希冲突"><a href="#2-哈希冲突" class="headerlink" title="2.哈希冲突"></a>2.哈希冲突</h3><p>HashMap在面对哈希冲突时，使用链表+红黑树的方式来解决哈希冲突。但是ThreadLcoal在面对哈希冲突时,使用开放线性寻址法来解决哈希冲突（其实源码是加一个固定的偏移量）,哈希冲突比较频繁的时候，会进行扩容来减少哈希冲突，并且重新根据哈希值计算每个元素的坐标。初始容量为16，扩容的阈值为内部存储元素占据Entry数组的2&#x2F;3，每次扩容后数组长度都会翻倍</p><h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3.内存泄漏"></a>3.内存泄漏</h3><p>内存泄漏是指程序运行过程中，由于程序代码的bug出现了无法被回收的内存区域,由于无法回收这部分内存空间。这种情况被称为内存泄漏。<br>使用ThreadLocal的时候,必须要提防一个内存泄漏的问题,实际上正常使用ThreadLocal（将ThreadLocal作为类中静态常量使用的时候）的时候,是不会产生内存泄漏的问题的。只有将ThreadLocal作为局部变量使用时,会出现无法回收内存空间的内存泄漏现象。这还和JVM的垃圾回收机制有关系。<br>在局部变量的使用场景下，每个value都会被设置到Entry,放到Entry数组中,虽然key是弱引用指向,每次垃圾回收都会回收掉Key值(弱引用特质，每次gc会回收内存空间),由于Java项目中都会使用线程池(天生多线程),线程对象会一直存活,JVM在进行垃圾回收时,由于有强引用指向ThreadLocalMap的value值(key回收掉了,value还在)<br>那value可以每次gc都回收掉吗？这样不就不会产生内存泄漏了么？我们需要站在设计者的角度进行考虑.如果把value值也设计成弱引用,java程序中发生gc是非常高频的,如果业务执行中,发生gc后使这个存储的value值失效,就会出现空指针异常。<br>为什么Key值设置成弱引用呢？<br>ThreadLocal的正确使用方式是调用完成后在可靠的代码区域进行remove回收内存，但肯定会存在有部分程序在编写时，不正常调用remove或者在安全代码区域外调用remove,进而导致remove代码失效，如果Key值设置为强引用,会导致key和value的双重泄漏，所以设置成弱引用本质上是一种防御性编程（xswl,想的太深了）</p><blockquote><p>弱引用使用场景一般是用来做本地的缓存实现（GC后自动回收）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 存储当前ThreadLocal对应的值（线程私有副本）</span></span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">// 构造方法：key是ThreadLocal实例，用弱引用存储；value是具体值</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k); <span class="comment">// 调用WeakReference的构造方法，将k包装为弱引用</span></span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、CAS-Atomic原子操作详解"><a href="#二、CAS-Atomic原子操作详解" class="headerlink" title="二、CAS &amp; Atomic原子操作详解"></a>二、CAS &amp; Atomic原子操作详解</h1><h2 id="什么是原子操作？如何实现原子操作？"><a href="#什么是原子操作？如何实现原子操作？" class="headerlink" title="什么是原子操作？如何实现原子操作？"></a>什么是原子操作？如何实现原子操作？</h2><blockquote><p>原子性：实际上是事务的概念，指的是多个操作不可分割的特性，要么全部执行，要么全部不执行，这种特性叫做原子性。</p></blockquote><blockquote><p>CAS机制(Compare and swap)：CAS基本思想是比较并替换</p></blockquote><p>内存地址V,预期值A,新值B,具体执行逻辑只有两步：</p><ul><li>1.比较：判断内存地址V中存储值是否为预期值A </li><li>2.替换：<ul><li>若相等，将V中的值更新为B</li><li>若不等，不做任何操作或重试</li></ul></li></ul><p>一般实现原子操作都会使用锁机制,虽然锁机制可以满足简单基本的业务需求,但是有的时候我们需要更有效、灵活的机制。sychronized这种基于阻塞的锁机制，持有锁的时候，其他线程会被全部阻塞，直到持有锁的线程释放锁。为了解决这个问题，Java提供了Atomic的原子工具类。</p><p>在JDK早期版本：Aotmic内部机制一般均为循环CAS重试来实现的,CAS这种无锁无阻塞循环尝试更新的操作，在性能上通常比sychronized锁机制更良好。<br>但是JDK不断对sychronized锁进行优化，现在两者性能上差距基本上没什么区别了。<br>虽然CAS在锁竞争弱的情况下性能上比阻塞锁机制要优秀，但是这是有代价的。CAS有下面三个缺陷</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题是CAS操作的弊病之一，在多线程并发的条件下，虽然期望值是A,但可能已经被其他线程修改成A了,如果此时进行更新操作，就会因为这种ABA问题发生并发条件下的数据脏写。ABA问题的解决方案一般是使用版本号进行记录数据版本,来根据版本号+期望值 双期望值来决定要不要更新数据。</p><h3 id="循环开销问题"><a href="#循环开销问题" class="headerlink" title="循环开销问题"></a>循环开销问题</h3><p>虽然CAS是无锁不阻塞的方式进行尝试更新数据，但是高并发环境下大量线程竞争，循环导致的额外开销会非常大，导致CPU的空转开销，造成性能上的浪费，这种情况下更适合使用sychronized阻塞锁来保证数据的原子性、安全性。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS的机制决定了只能保证对一个共享变量进行原子操作。但并不是绝对的，我们可以把多个共享变量合并成一个共享变量的对象进行操作（但是这种情况下又会导致锁竞争加剧，性能下降严重）</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><ul><li>int addAndGet()：CAS原子加操作，并返回结果</li><li>boolean compareAndSet(int expect,int update)：如果输入的数值等于预期值，则以原子方式设置该值</li><li>int getAndIncrement()：原子方式加1</li><li>int getAndSet(int newValue)：原子方式设置新值</li></ul><h2 id="解决ABA问题的Atomic原子类"><a href="#解决ABA问题的Atomic原子类" class="headerlink" title="解决ABA问题的Atomic原子类"></a>解决ABA问题的Atomic原子类</h2><p>AtomicMarkableReference和AtomicStampedReference<br>为了解决ABA问题,Java提供了两个原子类，这两者的区别是前者只关心有没有被修改过，不关心具体被修改过几次。后者会记录修改次数<br>由于原子类对高并发的写入性能开销比较大,所以jdk1.8之后引入了LongAdder类来解决写热点的问题，其内部用一个base的long类型，和一个Cell[]数组，使用数组来分散写热点事件。</p><h1 id="三、线程安全问题"><a href="#三、线程安全问题" class="headerlink" title="三、线程安全问题"></a>三、线程安全问题</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>所谓线程安全，即所写代码在并发情况下使用时，总是能表现出正确的行为。反之，未实现线程安全的代码，表现的行为是不可预知的。</p><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>实现好的并发是一件非常困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。就是把对象封装到一个线程里，只有这一个线程能看到这个对象。这个对象就算不是线程安全的也不会出现任何安全问题。</p><h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>栈封闭是我们编程中遇到的最多的线程封闭。最常见的就是局部变量，由于局部变量不是被多个线程共享，所以不会出现并发问题。所以使用局部变量不使用全局变量，能在一定程度上避免并发带来的安全问题，比如ThreadLocal就是一个实现线程封闭的很好的数据结构。</p><h3 id="无状态的对象"><a href="#无状态的对象" class="headerlink" title="无状态的对象"></a>无状态的对象</h3><p>没有任何成员变量的类，就叫做无状态的类，这种类一定是线程安全的。但其内部对于其他对象进行操作并不一定是线程安全的（类本身线程安全，但是内部行为不一定对操作对象是线程安全的）。</p><h2 id="加锁和CAS"><a href="#加锁和CAS" class="headerlink" title="加锁和CAS"></a>加锁和CAS</h2><p>我们最常用保证线程安全的手段，是使用synchronized关键字，使用显式锁以及各种原子变量，修改数据时使用CAS机制等</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，互相持有其他线程所需要的锁资源，并且等待其他线程释放锁资源，又不会释放自己已经持有的锁资源，而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去。此时系统就处于死锁状态。<br>学术上死锁发生死锁必须具备四个条件:</p><ul><li>互斥条件:资源具有独占性，同一时间只能被一个进程占用。例如，打印机同一时间只能处理一个打印任务。</li><li>请求与保持条件:进程已持有至少一个资源，同时又向其他进程请求新的资源，且该资源正被其他进程占用。例如，进程 A 持有打印机，又请求进程 B 正在使用的扫描仪。</li><li>不可剥夺条件:进程已获得的资源，在未主动释放前，不能被其他进程强制剥夺。例如，进程 B 正在使用的扫描仪，不能被系统强制收回分配给进程 A。</li><li>循环等待条件:多个进程之间形成闭环的资源等待链，每个进程都在等待下一个进程所持有的资源。例如，进程 A 等待进程 B 的资源，进程 B 等待进程 C 的资源，进程 C 等待进程 A 的资源。</li></ul><h3 id="死锁的预防核心"><a href="#死锁的预防核心" class="headerlink" title="死锁的预防核心"></a>死锁的预防核心</h3><p>预防死锁的本质的就是破坏四个条件中的任意一个，即可从根本上避免死锁发生。常见思路包括：采用资源预先分配策略（破坏请求与保持条件）、允许资源强制回收（破坏不可剥夺条件）、终止死锁中的线程（破坏循环等待）等。一般情况下互斥性是无法避免的。避免死锁还有一些常见算法：有序资源分配法和银行家算法等。</p><h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><p>单例模式是一种比较常见的设计模式，最常见的是DCL(double check lock)单例实现，下面是说明和代码实现：</p><ol><li>volatile 关键字：防止instance &#x3D; new Singleton()这句代码的指令重排序（分配内存→初始化对象→引用指向内存）。如果没有 volatile，可能导致其他线程获取到 “未完全初始化” 的实例（引用已指向内存，但对象还没初始化完）。</li><li>双重检查：<ul><li>第一次检查（同步块外）：避免每次调用getInstance()都进入同步块，减少性能损耗（多数情况下实例已初始化，直接返回）。</li><li>第二次检查（同步块内）：防止多线程同时通过第一次检查后，在同步块内重复创建实例。</li></ul></li><li>私有构造方法：禁止外部通过new Singleton()创建实例，确保唯一实例由getInstance()控制。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有静态实例变量，用volatile修饰（关键！防止指令重排序）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 2. 私有构造方法，禁止外部通过new创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 3. 公共静态方法，提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：未初始化时才进入同步块（减少同步开销）</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步块：保证多线程下的原子性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：防止多个线程同时通过第一次检查后重复创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> ThreadLocal </tag>
            
            <tag> CAS </tag>
            
            <tag> Atomic </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程并发、等待及通知机制</title>
      <link href="/2025/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程 &#x3D; 程序 + 执行</p><p>进程是系统分配资源的基本单位（内存、CPU时间片）<br>进程是用来实现多进程并发执行的一个实体，实现对CPU的虚拟化，让每个进程感觉都拥有一个CPU，核心技术就是上下文切换和进程调度。<br>进程是正在运行的程序的实例。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。<br>进程是执行中的程序，除了可执行代码外还包含进程的活动信息和数据，比如用来存放函数变量、局部变量、返回值的用户栈，存放进程相关数据的数据段，内核中进程间切换的内核栈，动态分配的堆。</p><p>早期操作系统程序都是单个运行的，CPU利用率低下，为了提高CPU的利用率，加载多个程序到内存并发运行，在单核CPU中这种属于伪并发。其实在同一时间只运行一个程序</p><img width="504" height="336" alt="image" src="https://github.com/user-attachments/assets/28eb9528-c6b1-4ec1-8d43-01861e49b0fe" /><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p><p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。</p><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p><p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I&#x2F;O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><h3 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h3><p>同一台计算机的进程通信称为IPC(Inter-process-conmumunication),不同计算机之间的通信被称为RPC(Remote-process-conmumunication)，需要通过网络，并遵守共同的协议，比如Dubbo就是一个RPC框架，而Http协议也经常用在RPC上，比如SpringCloud微服务</p><p><strong>进程间有几种通信方式？</strong></p><ul><li>管道：分为匿名管道(pipe)及命名管道(named pipe)<ul><li>匿名管道可用具有亲缘关系的父子进程间的通信</li><li>命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间进行通信</li></ul></li><li>信号（sign）:信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</li><li>消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定规则向消息队列中添加新信息；对消息队列有读权限的进程可以从消息队列中读取消息</li><li>共享内存（shared memory）:可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依赖某种同步操作，入互斥锁和信号量等。</li><li>信号量（semaphore）:主要作为进程间及同一种进程的不同线程之间的同步和互斥手段。</li><li>套接字（socket）：这是一种更为一般的进程间通信机制。可用于网络中不同机器之间的进程间通信，应用非常广泛。同一机器中的进程还可以使用Unix domain socket(比如同一机器中的MySQL中的控制台mysql shell 和MuSQL服务程序的连接)，这种方式不需要经过网络协议栈，不需要打包拆包、计算校验、维护序号和应答等，比纯粹基于网络的进程间通信肯定效率更高。</li></ul><h3 id="CPU核心数和线程数的关系"><a href="#CPU核心数和线程数的关系" class="headerlink" title="CPU核心数和线程数的关系"></a>CPU核心数和线程数的关系</h3><p>目前，主流的CPU都是多核的，线程是CPU调度的最小单位。同一CPU核心只能运行一个线程，也就是说CPU内核和同时运行的线程数是1:1的关系，也就是说8核CPU同时可以执行8个线程的代码。但Intel引入超线程技术后，产生了逻辑处理器的概念，使得核心数与线程数形成1:2的关系。在我们前面的Windows任务管理器贴图就能看出来，内核数是6,而逻辑处理器数是12个</p><h3 id="上下文切换（Context-switch）"><a href="#上下文切换（Context-switch）" class="headerlink" title="上下文切换（Context switch）"></a>上下文切换（Context switch）</h3><p>既然操作系统要在多个进程（线程）之间进行调度，而每个线程在使用CPU时总是要使用CPU中的资源，比如CPU寄存器和程序计数器。这就意味着，操作系统要保证线程在调度前后的正常执行，所以，操作系统中就有上下文切换的概念，它是指CPU从一个进程或线程到另一个进程或线程的切换。<br>上下文是CPU寄存器和程序计数器在任何时间点的内容。<br>寄存器是CPU内部的一小部分非常快的内存（相对于CPU内部的缓存和CPU外部较慢的RAM主内存），它通过提供对常用值的快速访问来加快计算机程序的执行。<br>程序计数器是一种专门的寄存器，它指示CPU在其指令序列中的位置，并保存着正在执行的指令的地址或下一条要执行的指令的地址，这取决于具体的系统。<br>上下文切换可以更详细地描述为内核（即操作系统的核心）对CPU上的进程（包括线程）执行以下活动：<br>1.暂停一个进程的处理，并将该进程的CPU状态（即上下文）存储在内存中的某个地方<br>2.从内存中获取下一个进程的上下文，并在CPU的寄存器中恢复它<br>3.返回到程序计数器指示的位置（即返回到进程被中断的代码行）以恢复进程。</p><ul><li>从数据角度来看，以程序员的角度来看，是方法调用过程中的各种局部变量与资源</li><li>从线程角度来看，是方法的调用栈中存储的各类信息。<br>引发上下文切换的原因一般包括：线程、进程切换、系统调用等等。上下文切换通常是计算密集型的，因为涉及一系列数据在各种寄存器、缓存中的来回拷贝。就CPU时间而言，一次上下文切换大概需要5000~20000个时钟周期，相对一个简单指令几个乃至十几个左右的执行时钟周期，可以看出这个成本的巨大。</li></ul><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>举个例子，如果有条高速公路A上面有8条车道，那么最大的并行车辆就是8辆。一个CPU就相当于一个高速公路，核心数或线程数就相当于车道数量。<br>当我们谈论并发时，一定要加个单位时间，也就是说单位时间内并发量是多少？离开了单位时间讨论并发是没有意义的<br>综合来说：<br>    并发Concurrent:指应用能够交替执行不同的任务，比如单CPU核心下执行多线程并非是同时执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，来达到“同时执行效果”<br>    并行Parallel:指应用能够同时执行不同的任务数量能力<br>两者的区别：并发是交替执行、并行是同时执行。</p><h1 id="2-Java中的线程"><a href="#2-Java中的线程" class="headerlink" title="2. Java中的线程"></a>2. Java中的线程</h1><h3 id="Java程序天生就是多线程的"><a href="#Java程序天生就是多线程的" class="headerlink" title="Java程序天生就是多线程的"></a>Java程序天生就是多线程的</h3><p>一个Java程序从Main方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但是实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main()的线程。<br>而一个Java程序的运行就算是没有用户自己开启的线程，实际上也有很多JVM自行启动的线程，一般来说有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlyMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds());</span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s\n&quot;</span>,threadInfo.getThreadId(), threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1] main //main线程，用户程序入口</span><br><span class="line">[2] Reference Handler // 清除Reference的线程</span><br><span class="line">[3] Finalizer //调用对象的finalize方法的线程</span><br><span class="line">[4] Signal Dispatcher // 分发处理发送给JVM信号的线程</span><br><span class="line">[5] Attach Listener // 内存dump,线程dump,类信息统计,获取系统属性等</span><br><span class="line">[13] Common-Cleaner // 执行对象的清理操作，尤其是针对那些需要显式释放的非 Java 堆资源（native 内存、文件句柄、网络连接等）</span><br><span class="line">[14] Monitor Ctrl-Break //监控Ctrl-Break中断信号的</span><br><span class="line">[15] Notification Thread // MBean（管理 Bean）可以通过发送 “通知”（Notification）来告知外部其状态变化（如属性修改、事件触发等）。</span><br></pre></td></tr></table></figure><p>不同JDK版本可能会有所差异，但是Java的特性决定了Java程序天生就是多线程的</p><h3 id="线程的启动和中止"><a href="#线程的启动和中止" class="headerlink" title="线程的启动和中止"></a>线程的启动和中止</h3><h4 id="面试题：线程的启动方式有几种？"><a href="#面试题：线程的启动方式有几种？" class="headerlink" title="面试题：线程的启动方式有几种？"></a>面试题：线程的启动方式有几种？</h4><p>官方说法是两种，一种是创建派生Thread类用以执行，另一种是实现Runnable接口。<br>本质上无论是线程池还是其他方式，都是这两种方式实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 无返回值的线程启动方式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">            ()-&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;无返回值&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">        <span class="comment">// 有返回值的线程启动方式</span></span><br><span class="line">        <span class="type">UseCallable</span> <span class="variable">useCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(useCallable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程中止"><a href="#线程中止" class="headerlink" title="线程中止"></a>线程中止</h4><p>1.线程自然终止<br>    线程的run方法执行完成，或者是抛出了未处理的异常导致线程提前结束</p><p>2.线程手动终止<br>    暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop().但是这些API是过期的，不建议使用。以suspend()方法为例,在调用后,线程不会释放已经占有的资源(比如锁),而是占用着资源进入睡眠状态,这样容易引发死锁问题。同样，stop()方法在终结一个线程的不会保证线程的资源正常释放,通常是没有给与线程完成资源释放工作的机会,因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用,这些方法才被标注为不建议使用的过期方法</p><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><pre><code>安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作,中断好比其他线程对该线程打了个招呼,不代表线程A会立即停止自己的工作,同样的A线程完全可以不理会这种中断请求。线程通过检测自身的中断标志位是否被置为True来进行响应。线程会通过方法isInterrupted()来进行判断是否被中断,也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断,不过Thread.interrupted()会同时将中断标识位改写为false。如果一个线程处于阻塞状态(如线程调用了thread.sleep、thread.join、thread.wait等),则在线程在检查中断标识时如果发现中断标识为True,则会在这些阻塞方法调用处抛出InterruptedException异常,并且在抛出异常后会立即将线程的中断标识位清除,即立即设置为false。不建议自定义一个取消标志位（例：public static boolean flag）来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志,线程必须从阻塞调用返回后,才会检查这个取消标志。这种情况下,使用中断会更好。</code></pre><p><strong>处于死锁状态下的线程无法被中断</strong></p><h4 id="run和start区别"><a href="#run和start区别" class="headerlink" title="run和start区别"></a>run和start区别</h4><p>单独调用run方法，执行的是普通方法，并不会创建线程，start方法是创建线程后，在新建线程中执行run方法</p><h3 id="线程的状态-生命周期"><a href="#线程的状态-生命周期" class="headerlink" title="线程的状态&#x2F;生命周期"></a>线程的状态&#x2F;生命周期</h3><p>Java中的线程状态分为以下6种：</p><ul><li>1.初始(New):新创建了一个线程对象，还没有调用start()方法。</li><li>2.运行(Runnable):Java线程中将就绪(ready)和运行中(running)两种状态笼统称为”运行”。</li><li>3.阻塞(Blocked):阻塞态,表示线程阻塞于锁</li><li>4.等待(Waiting):进入该状态的线程需要等待其他线程做出一些特定动作(通知或者中断)。</li><li>5.超时等待(Timed_Waiting):该状态不同于Waiting,它可以在指定时间后自行返回。</li><li>6.终止(Terminated):表示该线程已经执行完毕。</li></ul><h3 id="其他线程相关方法"><a href="#其他线程相关方法" class="headerlink" title="其他线程相关方法"></a>其他线程相关方法</h3><p>yield()方法主动让出CPU资源,但让出的时间不可控且资源不会释放</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在Java线程中，通过priority这个整形成员变量来控制优先级，优先级的范围为1~10，可以在线程构建的时候通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>线程调度指系统为线程分配CPU使用权的过程，主要调度方式分为两种：</p><ul><li>协同式线程调度</li><li>抢占式线程调度</li></ul><p>使用协程式线程调度的多线程系统，线程执行的时间由线程本身来控制，线程把自己的工作执行完成后，主动通知系统切换到另一个线程上。使用协同式线程调度的最大好处是实现简单，由于线程要把自己的事情做完之后通知系统进行线程切换，所以就没有线程同步的问题，但是坏处也很明显，如果一个线程出了问题，程序就会阻塞。</p><p>使用抢占式线程调度的多线程系统，每个线程执行的时间以及是否切换都由系统决定。这种情况下，线程的执行时间不可控，所以不会有【一个线程导致整个进程阻塞】这种问题的出现。</p><p>Java线程调度使用了抢占式调度的方式，在Java中，Thread.yield()可以让出CPU执行时间，但是对于获取执行时间，线程本身是没有办法的。对于获取CPU执行时间，线程唯一可以使用的手段是设置线程优先级，Java程序设置了10个级别的程序优先级，当两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><h3 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h3><p>线程其实是操作系统层面的实体，Java中的线程是怎么和操作系统层面对应起来的呢？<br>其实任何语言实现线程主要有三种方式：使用内核线程实现（1：1）,使用用户线程实现（1：N），使用用户线程+轻量级进程混合实现（N:M）</p><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>使用内核线程的实现方式也被称为1：1实现。将内核线程（操作系统内核支持的线程），由于内核线程的支持，每个线程都成为了一个独立的调度单元，即使某个线程在系统调用中被阻塞了，也不会影响整个进程继续工作，相关的调度工作也不需要额外考虑，由操作系统处理。<br>局限性：由于基于内核线程实现，所以各种线程的操作：创建、析构以及同步，都需要涉及到系统调用。系统调用的代价是十分昂贵的，需要在用户态和内核态进行来回切换。其次，每个语言层面的线程都需要有一个内核线程的支持，需要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持的线程数量是有限的。</p><h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>用户线程属于完全建立在用户空间的线程库上，内核不能感知到，用户线程的建立、同步、销毁和调度完成完全在用户态完成，不需要内核的帮助。程序如果实现得当，不需要进行用户态-内核态的切换，操作非常快速且低消耗，能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。</p><p>用户线程的优势在于不需要操作系统内核支援，缺陷同样也在于没有内核线程的支援上，所有的线程操作都需要用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配给到进程，那诸如“阻塞如何处理”，“多处理器系统如何将线程映射到其他处理器上”这类问题解决起来非常困难，甚至有些在语言层面是不可能实现的。因为使用用户线程实现的程序往往比较复杂，所以一般的应用程序都不倾向使用用户线程。Jav语言曾经使用过用户线程，最终又放弃了。但是近年来以高并发为卖点的Golang等语言又普遍支持了用户线程。</p><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。这种混合实现下，即存在用户线程，又存在内核线程。</p><p>用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然可以保持低开销、快速，并且可以支持大规模的用户线程并发。<br>同样又可以使用内核提供的线程调度功能以及处理器映射，并且用户线程的系统调用要通过内核线程来完成。在这种混合模式中，用户线程与轻量级进程的数量比是不定的。是N:M的关系</p><h4 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h4><p>Java线程在早期的CLassic虚拟机上（1.2之前），是用户线程实现的，但是JDK1.3起，主流商用的Java虚拟机的线程模型普遍被替换为基于操作系统原生线程模型来实现（1：1线程模型）。<br>以Hotspot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以Hotspot自己是不回去干涉线程调度的，全权交给底层的操作系统进行处理。<br>Java的线程调度最终取决于操作系统，映射到操作系统的原生线程，所以操作系统的优先级有时候并不能和Java一一对应，所以Java优先级并不是特别靠谱。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>随着互联网行业的发展，目前内核线程实现在很多场景已经有点不适宜了。互联网架构在处理一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，也就是我们常说的微服务，这种服务细分的架构在减少了单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一服务提供者都要同时处理更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待。<br>Java目前并发编程机制与上述互联网的架构演进趋势产生了一些矛盾，1:1的内核线程模型依然是如今Java虚拟机线程实现的主流选择，但是这种线程模型的天生缺陷切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户本身的业务线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的资源浪费。<br>另外我们常见的JavaWeb服务器，比如Tomcat的线程池的容量通常在几十个到两百之间，当把数以百万计的请求往线程池里面灌的时候，系统即使能处理过来，其中的切换损耗也是相当可观的。<br>这样的话对于Java语言来说，用户线程的引入成为了解决上述问题一个非常可行的方案。其次，Go语言等支持用户线程的新型编程语言给Java带来了巨大的压力，也使得Java在面对是否引入用户线程这个问题面前避无可避。<br>用户线程又被称为协程，内核线程的切换开销来自于保护和恢复线程的成本，如果改用用户线程，这部分开销依然不能够省略掉，但是，把保护、恢复现场以及调度的工作从操作系统交到程序员手上，则可以通过很多手段来缩减这些开销。<br>由于最初多数用户线程是被设计为协同式调度，所以用户线程有了一个别名-协程，完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”</p><h4 id="纤程-Java中的协程"><a href="#纤程-Java中的协程" class="headerlink" title="纤程-Java中的协程"></a>纤程-Java中的协程</h4><p>在JVM的实现上，以Hotspot为例,协程的实现会有些额外的限制，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎么样？譬如Kotlin提供的协程实现，一旦遭遇synchronize关键字，那挂起来的仍将是整个线程。<br>所以Java开发组就Java中协程的实现也做了很多努力，OpenJDK在2018年创建了Loom项目，这是Java的官方解决方案，并用了“纤程（Fiber）”这个名字。<br>Loom项目的意图是重新提供对用户线程的支持，但这些新功能不是为了取代当前基于操作系统的线程实现，而是会有两个并发编程模型在Java虚拟机并存，可以在程序中同时使用。新模型有意地保持了与目前线程模型相似的API设计，它们甚至可以拥有一个共同的基类，这样现有的代码就不需要为了使用纤程而进行过多改动，甚至不需要知道背后采用了哪个并发编程模型。<br>Loom团队在2018年公布的他们对于Jetty基于纤程改造后的测试结果，同样在5000QPS压力下，以容量为400的线程池的传统模式和每个请求配以一个纤程的新并发处理模式进行对比，前者的请求响应延迟在10000至20000毫秒之间，而后者的延迟普遍在200毫秒以下，目前Java中比较出名的协程库是Quasar,Quasar的实现原理是字节码注入，在字节码层面对当前被调用函数中的所有局部变量进行保存和恢复。这种不依赖Java虚拟机的线程保护虽然能够工作，但是影响性能。</p><h4 id="Java使用纤程"><a href="#Java使用纤程" class="headerlink" title="Java使用纤程"></a>Java使用纤程</h4><ol><li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependemcy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>co.paralleluniverse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quasar-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependemcy</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用纤程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 线程工作池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协程工作池</span></span><br><span class="line">        <span class="comment">// ExecutorService executorService = Executors.newFixedThreadPool(2000);</span></span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>,<span class="number">10000</span>).forEach(i-&gt;executorService.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException ex)&#123;&#125;</span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;)) ;</span><br><span class="line">        count.await();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.print(stopWatch.prettyPrint());</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。但是我们一般用不上，比如垃圾回收线程就是守护线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。<br>这段代码打印的线程除了main线程外，其余线程均为守护线程。当JVM中线程均为守护线程时，JVM虚拟机就会退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlyMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds());</span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s\n&quot;</span>,threadInfo.getThreadId(), threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程间的通信和协调、协作"><a href="#线程间的通信和协调、协作" class="headerlink" title="线程间的通信和协调、协作"></a>线程间的通信和协调、协作</h3><p>很多的时候，孤零零的一个线程工作并没有什么太多的用处，更多的时候，我们是很多的线程一起工作，而且是这些线程间进行通信，或者配合着完成某项工作，这就离不开线程间的通信和协调、协作。</p><h3 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h3><p>进程间有好几种通信机制，其中包括了管道，其实Java的线程里也有类似的管道机制，用于线程间的数据传输，而传输的媒介为内存。<br>Java中的管道输入输出流主要包括了如下4种具体实现：<br>PipedOutputStream、PipedInputStream、PipedReader和PipedWriter,前面两种面向字节，而后面两种面向字符。</p><h3 id="Join方法"><a href="#Join方法" class="headerlink" title="Join方法"></a>Join方法</h3><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>现在有T1、T2、T3三个线程，你怎么保证T2在T1执行完后执行，T3在T2执行完后执行？</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>把指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B种调用了线程A的Join方法，直到线程A执行完毕后，才会继续执行线程B剩下的代码。</p><h3 id="synchronized-内置锁"><a href="#synchronized-内置锁" class="headerlink" title="synchronized 内置锁"></a>synchronized 内置锁</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。<br>Java支持多个线程同时访问一个对象或者对象的成员变量，但是多个线程同时访问同一个变量，会导致不可预料的结果。关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，使多个线程访问同一个变量的结果正确，它又被称为内置锁机制。</p><h3 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h3><p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。</p><h3 id="volatile-最轻量的通信同步机制"><a href="#volatile-最轻量的通信同步机制" class="headerlink" title="volatile 最轻量的通信同步机制"></a>volatile 最轻量的通信同步机制</h3><p>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对于其他线程来说是立即可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCase</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加volatile时，子线程无法感知主线程修改了ready的值，加了volatile后，子线程可以感知主线程修改了ready的值，但是volatile只能保证可见性，并不能保证多线程状态下操作的原子性。</p><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h3><p>线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者是消费者，这种模式隔离了“做什么”和“怎么做”，简单的方法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出循环，从而完成消费者的工作。但是却存在下面的问题：</p><ol><li>难以确保及时性</li><li>难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li></ol><p>等待&#x2F;通知机制则可以很好的避免，这种机制是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()方法或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify()&#x2F;notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方的交互工作。</p><p>notify():<br>通知一个在对象上等待的线程，使其从wait方法返回，而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。</p><h4 id="等待和通知的标准范式"><a href="#等待和通知的标准范式" class="headerlink" title="等待和通知的标准范式"></a>等待和通知的标准范式</h4><p>等待方遵循如下原则：</p><ol><li>获取对象的锁</li><li>如果条件不满足，则调用对象的wait方法，被通知后仍要检查条件</li><li>条件满足则执行对应的逻辑。</li></ol><p>通知方遵循如下原则：</p><ol><li>获取对象的锁</li><li>如果获取到对象锁，执行业务逻辑操作，然后调用对象的notify方法（通知方法）</li></ol><h3 id="方法和锁"><a href="#方法和锁" class="headerlink" title="方法和锁"></a>方法和锁</h3><p>调用yield()、sleep()、wait()、notify()等方法对锁有何影响？<br>yield()、sleep()被调用后，都不会释放当前线程所持有的锁。<br>调用wait()方法后,会释放当前线程持有的锁,而且当前被唤醒后,会重新去竞争锁，锁竞争到后才会执行wait方法后面的代码。<br>调用notify()系列方法后,对锁无影响,线程只有在syn同步代码执行完后才会自然而然的释放锁,所以notify()系列方法一般都是syn同步代码的最后一行。</p><h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait 和 notify"></a>wait 和 notify</h3><p>为什么wait和notify方法要在同步块中调用？</p><p>原因：<br>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IIIegalMonitorStateException异常。其实真实原因是：<br>这个问题并不是说只在Java语言中会出现，而是会在所有的多线程环境下出现。</p><p>生产者-消费者简单示例<br>下面是一个简单的生产者-消费者例子，展示为什么wait()和notify()必须在同步块中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasMessage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生产者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// ❌ 错误：不在同步块中调用wait/notify</span></span><br><span class="line">        <span class="comment">// if (hasMessage) &#123;</span></span><br><span class="line">        <span class="comment">//     wait(); // 会抛出IllegalMonitorStateException</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ 正确：在同步块中</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果还有消息没被消费，就等待</span></span><br><span class="line">            <span class="keyword">while</span> (hasMessage) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者：还有消息未消费，等待中...&quot;</span>);</span><br><span class="line">                    wait(); <span class="comment">// 释放锁，等待消费者消费</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 生产消息</span></span><br><span class="line">            <span class="built_in">this</span>.message = msg;</span><br><span class="line">            hasMessage = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者：生产了消息 - &quot;</span> + msg);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知消费者</span></span><br><span class="line">            notify(); <span class="comment">// 唤醒等待的消费者线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ✅ 正确：在同步块中</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有消息，就等待</span></span><br><span class="line">            <span class="keyword">while</span> (!hasMessage) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者：没有消息，等待中...&quot;</span>);</span><br><span class="line">                    wait(); <span class="comment">// 释放锁，等待生产者生产</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 消费消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">consumedMsg</span> <span class="operator">=</span> <span class="built_in">this</span>.message;</span><br><span class="line">            hasMessage = <span class="literal">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者：消费了消息 - &quot;</span> + consumedMsg);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知生产者</span></span><br><span class="line">            notify(); <span class="comment">// 唤醒等待的生产者线程</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> consumedMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProducerConsumerExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConsumerExample</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                example.produce(<span class="string">&quot;消息-&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                example.consume();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果可能输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生产者：生产了消息 - 消息-1</span><br><span class="line">消费者：消费了消息 - 消息-1</span><br><span class="line">生产者：生产了消息 - 消息-2</span><br><span class="line">消费者：消费了消息 - 消息-2</span><br><span class="line">生产者：生产了消息 - 消息-3</span><br><span class="line">消费者：消费了消息 - 消息-3</span><br></pre></td></tr></table></figure><p>如果不使用同步块会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误示例 - 竞态条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrongProduce</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasMessage) &#123;           <span class="comment">// 步骤1：检查条件</span></span><br><span class="line">        <span class="comment">// 在这里，消费者线程可能消费了消息，hasMessage变为false</span></span><br><span class="line">        <span class="comment">// 但生产者不知道这个变化，仍然会调用wait()</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();            <span class="comment">// 步骤2：等待 - 但可能错过notify()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.message = msg;        <span class="comment">// 步骤3：可能重复生产，覆盖未消费的消息</span></span><br><span class="line">    hasMessage = <span class="literal">true</span>;</span><br><span class="line">    notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程、并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> Java并发 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 Sentinel 限流组件推模式实现</title>
      <link href="/2025/10/15/sentinel%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2025/10/15/sentinel%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在微服务架构中，流量控制是保障系统稳定性的核心手段，Sentinel 作为主流限流组件，其规则同步模式直接影响分布式环境下的可用性。本文将聚焦 Sentinel 推模式的实现细节，对比拉模式的局限性，并补充多种主流实现方案，为线上分布式场景提供实践参考。</p><h1 id="一、Sentinel-规则同步的两种核心模式"><a href="#一、Sentinel-规则同步的两种核心模式" class="headerlink" title="一、Sentinel 规则同步的两种核心模式"></a>一、Sentinel 规则同步的两种核心模式</h1><p>在正式讲解推模式前，需先明确 Sentinel 规则同步的两种基础模式：拉模式（Pull Mode） 与 推模式（Push Mode），二者的核心差异在于规则的主动方与持久化方式。</p><h2 id="1-1-拉模式：本地文件驱动的“被动同步”"><a href="#1-1-拉模式：本地文件驱动的“被动同步”" class="headerlink" title="1.1 拉模式：本地文件驱动的“被动同步”"></a>1.1 拉模式：本地文件驱动的“被动同步”</h2><p>拉模式是 Sentinel 最基础的规则同步方式，核心依赖本地文件存储，实现逻辑如下：</p><ul><li>客户端通过定时任务（默认间隔 3 秒）主动读取本地配置文件（如 JSON 格式）；</li><li>若文件内容变更，客户端更新本地规则缓存，生效限流逻辑；</li><li>服务端（或运维人员）需手动向每个客户端节点推送文件，才能实现规则更新。</li></ul><p>局限性：</p><ul><li>无法实现“一策多节点”：规则仅对单个节点生效，若微服务部署 10 个实例，需手动更新 10 次配置文件；</li><li>无持久化保障：本地文件易丢失，且无法追溯规则变更历史；</li><li>实时性差：依赖定时任务间隔，规则更新存在延迟，不适合流量突发场景。</li></ul><h2 id="1-2-推模式：配置中心驱动的“主动同步”"><a href="#1-2-推模式：配置中心驱动的“主动同步”" class="headerlink" title="1.2 推模式：配置中心驱动的“主动同步”"></a>1.2 推模式：配置中心驱动的“主动同步”</h2><p>推模式的核心是基于统一配置中心（如 Nacos、Apollo），由配置中心主动向客户端推送规则变更，实现逻辑如下：</p><ul><li>服务端将限流规则（如流控、熔断规则）通过配置中心的  publish  接口发布；</li><li>客户端通过监听配置中心的规则变更事件，实时获取最新配置并更新本地缓存；</li><li>所有客户端节点共享同一配置源，规则变更“一次发布，全节点生效”。</li></ul><p>核心优势：</p><ul><li>规则全局统一：配置中心作为唯一数据源，解决多节点规则不一致问题；</li><li>持久化与可追溯：配置中心自带版本管理，支持规则回滚、变更记录查询；</li><li>实时性高：基于事件监听机制，规则更新延迟可控制在毫秒级；</li><li>适配分布式场景：天然支持微服务动态扩缩容，新节点启动时自动拉取最新规则。</li></ul><h1 id="二、基于-Nacos-的推模式实现（两种方案对比）"><a href="#二、基于-Nacos-的推模式实现（两种方案对比）" class="headerlink" title="二、基于 Nacos 的推模式实现（两种方案对比）"></a>二、基于 Nacos 的推模式实现（两种方案对比）</h1><p>Nacos 作为阿里开源的配置中心，是 Sentinel 推模式的主流选择，官方提供两种实现思路，需根据业务场景选择。</p><h2 id="2-1-方案一：客户端“拉取-监听”模式（简单易实现）"><a href="#2-1-方案一：客户端“拉取-监听”模式（简单易实现）" class="headerlink" title="2.1 方案一：客户端“拉取+监听”模式（简单易实现）"></a>2.1 方案一：客户端“拉取+监听”模式（简单易实现）</h2><p>这是最基础的 Nacos 推模式方案，无需修改 Sentinel 服务端代码，核心依赖 Nacos 的  ConfigService  接口，实现步骤如下：</p><h3 id="1-服务端发布规则："><a href="#1-服务端发布规则：" class="headerlink" title="1. 服务端发布规则："></a>1. 服务端发布规则：</h3><p>服务端将限流规则（如流控规则  FlowRule ）封装为 JSON 格式，通过 Nacos 的  publishConfig(dataId, group, content)  接口，将规则发布到指定  dataId  和  group  下（如  sentinel-rules-demo ）。</p><h3 id="2-客户端监听规则："><a href="#2-客户端监听规则：" class="headerlink" title="2. 客户端监听规则："></a>2. 客户端监听规则：</h3><p>客户端引入 Nacos 依赖，通过  addListener  接口监听目标  dataId  的配置变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端核心代码示例</span></span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 监听规则变更</span></span><br><span class="line">configService.addListener(<span class="string">&quot;sentinel-rules-demo&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 JSON 字符串解析为 FlowRule 列表</span></span><br><span class="line">        List&lt;FlowRule&gt; rules = JSON.parseArray(configInfo, FlowRule.class);</span><br><span class="line">        <span class="comment">// 更新 Sentinel 本地规则</span></span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 初始拉取规则</span></span><br><span class="line"><span class="type">String</span> <span class="variable">initConfig</span> <span class="operator">=</span> configService.getConfig(<span class="string">&quot;sentinel-rules-demo&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">FlowRuleManager.loadRules(JSON.parseArray(initConfig, FlowRule.class));</span><br></pre></td></tr></table></figure><p>优势：实现简单，无需侵入 Sentinel 服务端，适合快速落地；<br>不足：客户端需额外处理规则解析、异常重试逻辑，代码冗余度较高。</p><h2 id="2-2-方案二：服务端“直接交互”模式（官方推荐）"><a href="#2-2-方案二：服务端“直接交互”模式（官方推荐）" class="headerlink" title="2.2 方案二：服务端“直接交互”模式（官方推荐）"></a>2.2 方案二：服务端“直接交互”模式（官方推荐）</h2><p>Sentinel 官方推荐的 Nacos 推模式，核心是让 Sentinel 服务端直接与 Nacos 交互，客户端仅负责“被动监听”，实现步骤如下：</p><h3 id="1-改造-Sentinel-服务端："><a href="#1-改造-Sentinel-服务端：" class="headerlink" title="1. 改造 Sentinel 服务端："></a>1. 改造 Sentinel 服务端：</h3><ul><li>在 Sentinel 控制台（服务端）中集成 Nacos 客户端依赖；</li><li>扩展控制台的“规则管理”模块，新增“发布到 Nacos”按钮，点击后直接调用 Nacos  publishConfig  接口；</li><li>支持规则的增删改查与 Nacos 配置实时同步，无需手动编写发布逻辑。</li></ul><h3 id="2-客户端简化监听："><a href="#2-客户端简化监听：" class="headerlink" title="2. 客户端简化监听："></a>2. 客户端简化监听：</h3><p>客户端逻辑与方案一一致，但无需关心规则发布流程，仅需监听 Nacos 变更即可。</p><p>优势：规则管理集中化，运维人员通过 Sentinel 控制台即可操作，降低使用成本；<br>不足：需修改 Sentinel 服务端源码（如扩展  NacosConfigPublisher  类），对定制化能力要求较高。</p><h1 id="三、推模式的其他主流实现方案"><a href="#三、推模式的其他主流实现方案" class="headerlink" title="三、推模式的其他主流实现方案"></a>三、推模式的其他主流实现方案</h1><p>除了 Nacos，结合 Spring 生态、Guava 等工具，也能实现 Sentinel 推模式，适用于不同技术栈场景。</p><h2 id="3-1-基于-Spring-生态的推模式"><a href="#3-1-基于-Spring-生态的推模式" class="headerlink" title="3.1 基于 Spring 生态的推模式"></a>3.1 基于 Spring 生态的推模式</h2><p>利用 Spring 的生命周期钩子和后置处理器，可将 Sentinel 规则与 Spring 配置无缝整合，实现步骤如下：</p><h3 id="1-绑定-Spring-生命周期："><a href="#1-绑定-Spring-生命周期：" class="headerlink" title="1. 绑定 Spring 生命周期："></a>1. 绑定 Spring 生命周期：</h3><p>在  SpringApplicationRunListener  或  CommandLineRunner  中，初始化 Sentinel 规则数据源，确保 Spring 启动时自动拉取初始规则。</p><h3 id="2-使用后置处理器增强："><a href="#2-使用后置处理器增强：" class="headerlink" title="2. 使用后置处理器增强："></a>2. 使用后置处理器增强：</h3><p>自定义  BeanPostProcessor ，对 Sentinel 的  RuleDataSource  实例进行增强：</p><ul><li>为不同规则（流控、熔断、系统规则）创建独立的  RuleDataSource   Bean；</li><li>在后置处理器中注入配置中心客户端，实现规则的持久化与变更监听；</li><li>示例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelRulePostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigService nacosConfigService;</span><br><span class="line">    <span class="comment">// 构造注入 Nacos ConfigService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SentinelRulePostProcessor</span><span class="params">(ConfigService nacosConfigService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nacosConfigService = nacosConfigService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 对 FlowRuleDataSource 进行增强</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FlowRuleDataSource) &#123;</span><br><span class="line">            <span class="type">FlowRuleDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (FlowRuleDataSource) bean;</span><br><span class="line">            <span class="comment">// 绑定 Nacos 监听</span></span><br><span class="line">            nacosConfigService.addListener(<span class="string">&quot;sentinel-flow-rules&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, </span><br><span class="line">                (configInfo) -&gt; dataSource.loadConfig(configInfo));</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>适用场景：Spring Boot&#x2F;Spring Cloud 技术栈，需与 Spring 配置体系深度整合的场景。</p><h2 id="3-2-基于-Guava-Sentinel-自带能力的推模式"><a href="#3-2-基于-Guava-Sentinel-自带能力的推模式" class="headerlink" title="3.2 基于 Guava&#x2F;Sentinel 自带能力的推模式"></a>3.2 基于 Guava&#x2F;Sentinel 自带能力的推模式</h2><p>若无需依赖外部配置中心，可利用 Guava 的缓存监听或 Sentinel 自带的规则持久化接口，实现轻量级推模式：</p><h3 id="1-基于-Guava-的实现："><a href="#1-基于-Guava-的实现：" class="headerlink" title="1. 基于 Guava 的实现："></a>1. 基于 Guava 的实现：</h3><ul><li>使用 Guava 的  LoadingCache  存储规则，设置过期时间（如 10 秒）；</li><li>服务端更新规则时，直接修改 Guava 缓存；</li><li>客户端通过  CacheLoader  定时从服务端拉取缓存，实现规则同步。</li></ul><h3 id="2-基于-Sentinel-自带能力的实现："><a href="#2-基于-Sentinel-自带能力的实现：" class="headerlink" title="2. 基于 Sentinel 自带能力的实现："></a>2. 基于 Sentinel 自带能力的实现：</h3><p>Sentinel 提供  RuleRepository  接口，可自定义实现类：</p><ul><li>实现  saveAll 、 findAll  等方法，将规则持久化到数据库（如 MySQL）或 Redis；</li><li>服务端通过  RuleRepository  读写规则，客户端定时调用  findAll  拉取最新规则；</li><li>配合 Redis 的  Pub&#x2F;Sub  机制，可实现规则变更的实时推送。</li></ul><p>适用场景：轻量级微服务，无需引入配置中心，追求低依赖的场景。</p><h1 id="四、推模式-vs-拉模式：如何选择？"><a href="#四、推模式-vs-拉模式：如何选择？" class="headerlink" title="四、推模式 vs 拉模式：如何选择？"></a>四、推模式 vs 拉模式：如何选择？</h1><p>维度 拉模式（本地文件） 推模式（配置中心）<br>适用场景 单机测试、小型服务 分布式微服务、线上环境<br>规则同步范围 单个节点 全节点统一<br>实时性 低（定时任务间隔） 高（事件监听）<br>持久化与可追溯 无 有（配置中心版本管理）<br>实现复杂度 低 中（需集成配置中心） </p><p>结论：线上分布式环境优先选择推模式（推荐 Nacos&#x2F;Apollo 方案）；单机测试或小型服务可使用拉模式快速验证。</p><h1 id="五、实践中的注意事项"><a href="#五、实践中的注意事项" class="headerlink" title="五、实践中的注意事项"></a>五、实践中的注意事项</h1><h2 id="1-规则格式一致性："><a href="#1-规则格式一致性：" class="headerlink" title="1. 规则格式一致性："></a>1. 规则格式一致性：</h2><p>无论哪种推模式，规则的 JSON 格式需严格匹配 Sentinel 实体类（如  FlowRule  的  resource 、 grade 、 count  字段不可缺失），避免解析失败。</p><h2 id="2-异常重试机制："><a href="#2-异常重试机制：" class="headerlink" title="2. 异常重试机制："></a>2. 异常重试机制：</h2><p>客户端监听配置中心时，需添加重试逻辑（如使用  Retryer ），防止网络抖动导致规则同步失败。</p><h2 id="3-规则版本管理："><a href="#3-规则版本管理：" class="headerlink" title="3. 规则版本管理："></a>3. 规则版本管理：</h2><p>配置中心需开启版本管理，避免误操作导致规则丢失，支持快速回滚到历史版本。</p><h2 id="4-客户端兜底规则："><a href="#4-客户端兜底规则：" class="headerlink" title="4. 客户端兜底规则："></a>4. 客户端兜底规则：</h2><p>客户端初始化时，需加载默认兜底规则（如“单机QPS不超过1000”），防止配置中心不可用时无规则可用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sentinel 推模式通过统一配置中心解决了拉模式的分布式痛点，是线上环境的最优选择。本文介绍的 Nacos 两种方案、Spring 整合方案、Guava 轻量方案，覆盖了不同技术栈的需求。在实际落地时，需结合业务场景选择合适的方案，并做好异常处理与版本管理，才能充分发挥 Sentinel 的流量控制能力，保障微服务稳定运行。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 中间件 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> Nacos </tag>
            
            <tag> 限流组件 </tag>
            
            <tag> 推模式 </tag>
            
            <tag> Spring生态 </tag>
            
            <tag> 分布式流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的IO模型与性能调优</title>
      <link href="/2025/10/13/Tomcat%E7%9A%84IO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/10/13/Tomcat%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Tomcat的I-O模型"><a href="#1-Tomcat的I-O模型" class="headerlink" title="1. Tomcat的I&#x2F;O模型"></a>1. Tomcat的I&#x2F;O模型</h1><h2 id="1-1-Linux-I-O模型"><a href="#1-1-Linux-I-O模型" class="headerlink" title="1.1 Linux I&#x2F;O模型"></a>1.1 Linux I&#x2F;O模型</h2><h3 id="I-O要解决什么问题？"><a href="#I-O要解决什么问题？" class="headerlink" title="I&#x2F;O要解决什么问题？"></a>I&#x2F;O要解决什么问题？</h3><p>I&#x2F;O本质上是在解决在计算机内存与外部设备之间拷贝数据的过程</p><p>程序通过CPU向外部设备发出读指令，数据从外部设备拷贝至内存需要一段时间，这段时间CPU就没事情做了，程序此时有两种选择：</p><ol><li><p>让出CPU资源，CPU执行其他任务</p></li><li><p>继续使用CPU轮询数据是否拷贝完成</p></li></ol><p>采取的具体策略就是不同I&#x2F;O模型要解决的问题</p><p>以网络数据读取为例分析，会涉及两个对象，一个是调用I&#x2F;O操作的用户线程，另一个是操作系统内核。一个进程的地址空间分为用户空间和内核空间，基于安全上的考虑，用户程序只能访问用户空间，内核程序可以访问整个进程空间，只有内核可以直接访问各种硬件资源，比如磁盘和网卡。</p><img width="1101" height="613" alt="image" src="https://github.com/user-attachments/assets/28b24729-5077-45e1-98c4-7145582e439f" /><p>当用户线程发起I&#x2F;O调用后，网络数据读取操作会经历两个步骤：</p><ul><li><p>数据准备阶段：用户线程等待内核将数据从网卡拷贝到内核空间</p></li><li><p>数据拷贝阶段：内核将数据从内核空间拷贝到用户空间（用户进程的缓冲区）</p></li></ul><img width="1080" height="574" alt="image" src="https://github.com/user-attachments/assets/4b6fcf47-be70-46ef-bdef-9a9d32236d3c" /><h3 id="Linux的I-O模型分类"><a href="#Linux的I-O模型分类" class="headerlink" title="Linux的I&#x2F;O模型分类"></a>Linux的I&#x2F;O模型分类</h3><ul><li><p>同步阻塞I&#x2F;O(bloking I&#x2F;O)</p></li><li><p>同步非阻塞I&#x2F;O(non-bloking I&#x2F;O)</p></li><li><p>I&#x2F;O多路复用（multiplexing I&#x2F;O）</p></li><li><p>信号驱动式I&#x2F;O（signal-driven I&#x2F;O）</p></li><li><p>异步I&#x2F;O(asynchronous I&#x2F;O)</p></li></ul><p>其中信号驱动式I&#x2F;O在实际中并不常用:</p><img width="1232" height="906" alt="image" src="https://github.com/user-attachments/assets/8ec4c31e-38ac-4b5f-97c8-e267edf7e5b2" /><ul><li><p>阻塞或非阻塞I&#x2F;O是指应用程序在发起I&#x2F;O操作时，是立即返回还是等待</p></li><li><p>同步或异步是指应用程序在与内核通信时，数据从内核空间到应用空间的拷贝，是由内核主动发起还是应用程序来触发。</p></li></ul><p>BIO的缺点：每个线程只能建立一个连接，所以必须使用线程池来管理多个客户端连接，客户端连接能力有限</p><p>NIO的缺点：每次都需要轮询所有的客户连接，确认是否有读取事件，造成CPU的空转，浪费CPU资源</p><p>多路复用I&#x2F;O:事件驱动模型的I&#x2F;O，每当有读取事件，或者写入事件发布时，会获取事件对应的连接，执行对应的事件，极大利用了CPU资源</p><table><thead><tr><th>BIO(JioEndpoint)</th><th>同步阻塞式I&#x2F;O，即Tomcat使用传统java.io进行操作。该模式下每个请求都会创建一个线程，对性能开销大，不适合高并发场景。优点是稳定，适合连接数小且固定架构。Tomcat8.5.x开始移除BIO</th><th></th></tr></thead><tbody><tr><td>NIO(NioEndPoint)</td><td>同步非阻塞式I&#x2F;O，jdk1.4之后实现的新IO。该模式基于多路复用选择器监测连接状态再同步通知线程处理，从而达到非阻塞的目的。比传统BIO能更好的支持并发性能。Tomcat8.0之后默认采用该模式。NIO模式使用连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯，编程比较复杂</td><td></td></tr><tr><td>AIO（Nio2EndPoint）</td><td>异步非阻塞式IO，jdk1.7后支持，与NIO不同在于不需要多路复用选择器，而是请求处理线程执行完成之后进行回调通知，继续执行后续操作。Tomcat8之后支持。一般适用于连接数较多且连接时间较长的应用。</td><td></td></tr><tr><td>APR（APrEndPoint）</td><td>（全称是Apache Portable Runtime&#x2F;Apache可移植运行库），是ApacheHTTP服务器的支持库。APrEndPoint是通过JNI调用APR本地库而实现非阻塞I&#x2F;O的。使用需要编译安装APR库</td><td></td></tr></tbody></table><h2 id="1-2-Tomcat-I-O模型如何选型"><a href="#1-2-Tomcat-I-O模型如何选型" class="headerlink" title="1.2 Tomcat I&#x2F;O模型如何选型"></a>1.2 Tomcat I&#x2F;O模型如何选型</h2><p>I&#x2F;O调优实际上是连接器类型的选择，一般情况下默认都是NIO，在绝大多数情况下都是够用的，除非你的WEB应用用到了TLS加密传输，而且对性能要求极高，这个时候可以考虑APR，因为APR通过OoenSSL来处理TLS握手和加解密。OpenSSL本身用C语言实现，它还对TLS通信做了优化，所以性能比Java要高。如果你的Tomcat跑在Windows上，并且HTTP请求的数据量比较大，可以考虑NIO2,这是因为Windows从操作系统层面实现了真正意义的异步I&#x2F;O，如果传输的数据量比较大，异步I&#x2F;O的效果就能显现出来。如果你的Tomcat跑在Linux平台上，建议使用NIO。因为在Linux上，JavaNIO和JavaNIO2底层都是通过epoll来实现的，但是JavaNIO更加简单高效。指定IO模型只需要修改server.xml的protocol配置</p><h2 id="1-3-网络编程模型Reactor线程模型"><a href="#1-3-网络编程模型Reactor线程模型" class="headerlink" title="1.3 网络编程模型Reactor线程模型"></a>1.3 网络编程模型Reactor线程模型</h2><p>Reactor模型是网络服务器端用来处理高并发网络IO请求的一种编程模型。</p><p>该模型主要有三类处理事件：即连接事件、写事件、读事件；</p><p>三个关键角色：即reactor、acceptor、handler。</p><p>accpetor负责连接事件，handler负责读写事件，reactor负责事件监听和事件分发</p><h3 id="单Reactor单线程（redis用的就是这个）："><a href="#单Reactor单线程（redis用的就是这个）：" class="headerlink" title="单Reactor单线程（redis用的就是这个）："></a>单Reactor单线程（redis用的就是这个）：</h3><img width="955" height="630" alt="image" src="https://github.com/user-attachments/assets/dfa466fd-53dc-47ad-85d8-fc34e73d5df0" /><h3 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h3><img width="904" height="869" alt="image" src="https://github.com/user-attachments/assets/4b9e3e71-ff29-4191-a895-cee39c158cfb" /><h3 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h3><img width="935" height="970" alt="image" src="https://github.com/user-attachments/assets/e104c179-2062-4457-895e-e795a298d189" /><h2 id="1-4-Tomcat-NIO实现"><a href="#1-4-Tomcat-NIO实现" class="headerlink" title="1.4 Tomcat NIO实现"></a>1.4 Tomcat NIO实现</h2><p>在Tomcat中，Endpoint组件的主要工作就是处理IO，而NIOEndpoint利用Java NIO API实现了多路复用I&#x2F;O模型。Tomcat的NioEndPoint是基于主从Reactor多线程模型设计的</p><p>有一个额外的线程单独处理连接事件，线程池负责处理事件</p><p>学习主从Reactor多线程模型这种实现可以去看下thrift实现</p><h1 id="2-Tomcat调优"><a href="#2-Tomcat调优" class="headerlink" title="2. Tomcat调优"></a>2. Tomcat调优</h1><h2 id="2-1-如何监控Tomcat的性能"><a href="#2-1-如何监控Tomcat的性能" class="headerlink" title="2.1 如何监控Tomcat的性能"></a>2.1 如何监控Tomcat的性能</h2><p>tomcat的关键指标有吞吐量、响应时间、错误数、线程池、CPU以及JVM内存。前三个指标是我们最关心的业务指标，Tomcat作为服务器，就是要能够又快又好地处理请求，因此吞吐量要大、响应时间要短，并且错误数要少。后面三个指标都是跟系统资源有关的，当某个资源出现瓶颈就会影响前面的业务指标，比如线程池种的线程数量不足会影响吞吐量和响应时间；但是线程数太多会耗费大量CPU，也会影响吞吐量，当内存不足时，会频繁触发GC,耗费CPU资源，最后也会反映在业务指标上来</p><h4 id="通过JConsole监控Tomcat"><a href="#通过JConsole监控Tomcat" class="headerlink" title="通过JConsole监控Tomcat"></a>通过JConsole监控Tomcat</h4><p>1）开启JMX的远程监听端口</p><p>我们可以在Tomcat的bin目录下新建一个名为setenv.sh的文件，然后输入下面内容</p><p>2)重启Tomcat,这样JMX的监听端口8011就开启了，可以通过JConsole来连接这个端口</p><p>这样就可以监控这些核心业务参数了</p><h2 id="2-2-常用调优参数"><a href="#2-2-常用调优参数" class="headerlink" title="2.2 常用调优参数"></a>2.2 常用调优参数</h2><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">namePrefix</span>=<span class="string">&quot;catalina-exec-&quot;</span>  &lt;!<span class="attr">--</span> <span class="attr">线程名前缀</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">          maxThreads=&quot;500&quot;            <span class="comment">&lt;!-- 最大线程数 --&gt;</span></span><br><span class="line">          minSpareThreads=&quot;50&quot;        <span class="comment">&lt;!-- 最小空闲线程 --&gt;</span></span><br><span class="line">          maxIdleTime=&quot;60000&quot;         <span class="comment">&lt;!-- 线程空闲超时时间（毫秒） --&gt;</span></span><br><span class="line">          maxQueueSize=&quot;100&quot;          <span class="comment">&lt;!-- 任务队列大小 --&gt;</span></span><br><span class="line">          prestartminSpareThreads=&quot;true&quot;/&gt; <span class="comment">&lt;!-- 启动时初始化最小空闲线程 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接器引用线程池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
          <category> 中间件 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat IO模型 </tag>
            
            <tag> Linux IO模型 </tag>
            
            <tag> Reactor线程模型 </tag>
            
            <tag> Tomcat性能调优 </tag>
            
            <tag> NIO </tag>
            
            <tag> APR </tag>
            
            <tag> Tomcat线程池参数 </tag>
            
            <tag> JConsole监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat类加载机制与热部署原理详解</title>
      <link href="/2025/10/12/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/12/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Tomcat类加载机制详解"><a href="#1-Tomcat类加载机制详解" class="headerlink" title="1.Tomcat类加载机制详解"></a>1.Tomcat类加载机制详解</h1><h2 id="1-1-JVM类加载器"><a href="#1-1-JVM类加载器" class="headerlink" title="1.1 JVM类加载器"></a>1.1 JVM类加载器</h2><p>Java中有3种类加载器，当然你也可以自定义类加载器</p><ul><li>引导类加载器（启动类加载器）：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar</li><li>扩展类加载器：负责加载支撑JVM运行的JRE的lib目录下ext扩展目录中的核心jar包</li><li>应用程序类加载器（系统类加载器）：负责ClassPath路径下的类包，主要就是加载你自己写的类</li><li>自定义类加载器：自己实现，负责加载自定义路径下的类包<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// BootStrapClassLoader c/c++实现，java层面是获取不到的，会输出null</span></span><br><span class="line">    System.out.println(ReentrantLock.class.getClassLoader());</span><br><span class="line">    <span class="comment">// ExtClassLoader</span></span><br><span class="line">    System.out.println(ZipInfo.class.getClassLoader());</span><br><span class="line">    <span class="comment">// AppClassLoader</span></span><br><span class="line">    System.out.println(ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;===========JVM类加载器父子关系==============&quot;</span>);</span><br><span class="line">    <span class="comment">// AppClassLoader </span></span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    <span class="comment">// ExtClassLoader</span></span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    <span class="comment">// BootStrapClassLoader</span></span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-双亲委派机制"><a href="#1-2-双亲委派机制" class="headerlink" title="1.2 双亲委派机制"></a>1.2 双亲委派机制</h2><p>Java中的类加载依赖双亲委派机制，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载目录中查找并载入目标类，双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载<br><img width="1404" height="1188" alt="image" src="https://github.com/user-attachments/assets/dcd36232-ea06-418a-a266-178af135f9b0" /></p><h3 id="为什么设计双亲委派机制？"><a href="#为什么设计双亲委派机制？" class="headerlink" title="为什么设计双亲委派机制？"></a>为什么设计双亲委派机制？</h3><ul><li>沙箱安全机制:防止核心类库API被随意篡改</li><li>避免类的重复加载：父加载器已经加载了该类时，就没必要子类加载器再加载一次，保证被加载类的唯一性</li></ul><h3 id="ClassLocader-loadClass源码分析"><a href="#ClassLocader-loadClass源码分析" class="headerlink" title="ClassLocader#loadClass源码分析"></a>ClassLocader#loadClass源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Tomcat为什么（如何）打破双亲委派机制？"><a href="#1-3-Tomcat为什么（如何）打破双亲委派机制？" class="headerlink" title="1.3 Tomcat为什么（如何）打破双亲委派机制？"></a>1.3 Tomcat为什么（如何）打破双亲委派机制？</h2><p>Tomcat的主要目的是充当应用服务器并处理用户的业务请求，使用场景可能会单机部署多应用。所以Tomcat打破双亲委派机制，核心是为了解决多Web应用独立运行的类隔离需求：双亲委派要求类加载器优先委托父加载器加载类，而Tomcat中多个Web应用可能依赖同一类的不同版本（如不同Spring版本），若按双亲委派，父加载器（如CommonClassLoader）加载一个版本后，所有应用都只能使用该版本，会引发类版本冲突；因此Tomcat自定义了WebAppClassLoader等加载器，让每个Web应用的类加载器优先加载自身WEB-INF&#x2F;classes和WEB-INF&#x2F;lib下的类，仅在自身未找到时才委托父加载器，从而实现不同应用类的独立隔离，保证多应用在同一容器中互不干扰地运行。<br>Tomcat打破双亲委派具体实现就是重写ClassLoader的两个方法：findClass和loadClass，来改变双亲委派的类加载顺序，但是直接重写这两个实现依然需要保证核心类库被篡改，所以为了保证核心类库的安全性，并没有一开始就使用系统类型加载器加载，而是先查询本地目录缓存，为了避免本地目录下的类覆盖JRE的核心类，会先尝试用JVM扩展类加载器ExtClassLoader去加载</p><h3 id="findClass方法"><a href="#findClass方法" class="headerlink" title="findClass方法"></a>findClass方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">&quot;    findClass(&quot;</span> + name + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    checkStateForClassLoading(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Permission to define this class when using a SecurityManager</span></span><br><span class="line">    <span class="keyword">if</span> (securityManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                    log.trace(<span class="string">&quot;      securityManager.checkPackageDefinition&quot;</span>);</span><br><span class="line">                securityManager.checkPackageDefinition(name.substring(<span class="number">0</span>,i));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception se) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                    log.trace(<span class="string">&quot;      --&gt;Exception--&gt;ClassNotFoundException&quot;</span>, se);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, se);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask our superclass to locate this class, if possible</span></span><br><span class="line">    <span class="comment">// (throws ClassNotFoundException if it is not found)</span></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">            log.trace(<span class="string">&quot;      findClassInternal(&quot;</span> + name + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (securityManager != <span class="literal">null</span>) &#123;</span><br><span class="line">                PrivilegedAction&lt;Class&lt;?&gt;&gt; dp =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PrivilegedFindClassByName</span>(name);</span><br><span class="line">                clazz = AccessController.doPrivileged(dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 1、先在应用本地目录下查找类 </span></span><br><span class="line">                clazz = findClassInternal(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(AccessControlException ace) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;WebappClassLoader.findClassInternal(&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;) security exception: &quot;</span> + ace.getMessage(), ace);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, ace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                log.trace(<span class="string">&quot;      --&gt;RuntimeException Rethrown&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((clazz == <span class="literal">null</span>) &amp;&amp; hasExternalRepositories) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 2、如果在本地目录没有找到，委派父加载器去查找</span></span><br><span class="line">                clazz = <span class="built_in">super</span>.findClass(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(AccessControlException ace) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;WebappClassLoader.findClassInternal(&quot;</span> + name</span><br><span class="line">                        + <span class="string">&quot;) security exception: &quot;</span> + ace.getMessage(), ace);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, ace);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                    log.trace(<span class="string">&quot;      --&gt;RuntimeException Rethrown&quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、如果父加载器也没找到，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;    --&gt; Returning ClassNotFoundException&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">            log.trace(<span class="string">&quot;    --&gt; Passing on ClassNotFoundException&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the class we have located</span></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">        log.debug(<span class="string">&quot;      Returning class &quot;</span> + clazz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        ClassLoader cl;</span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED)&#123;</span><br><span class="line">            cl = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrivilegedGetClassLoader</span>(clazz));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cl = clazz.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;      Loaded by &quot;</span> + cl.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (clazz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadClass方法"><a href="#loadClass方法" class="headerlink" title="loadClass方法"></a>loadClass方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 1、从本地缓存中查找是否加载过此类</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Returning class from cache&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从AppClassLoader中查找是否加载过此类</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Returning class from cache&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceName</span> <span class="operator">=</span> binaryNameToPath(name, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3、尝试用ExtClassLoader 类加载器加载类,防止应用覆盖JRE的核心类</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="type">boolean</span> tryLoadingFromJavaseLoader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url;</span><br><span class="line">            <span class="keyword">if</span> (securityManager != <span class="literal">null</span>) &#123;</span><br><span class="line">                PrivilegedAction&lt;URL&gt; dp = <span class="keyword">new</span> <span class="title class_">PrivilegedJavaseGetResource</span>(resourceName);</span><br><span class="line">                url = AccessController.doPrivileged(dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = javaseLoader.getResource(resourceName);</span><br><span class="line">            &#125;</span><br><span class="line">            tryLoadingFromJavaseLoader = (url != <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            tryLoadingFromJavaseLoader = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delegateLoad</span> <span class="operator">=</span> delegate || filter(name, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、判断是否设置了delegate属性,如果设置为true那么就按照双亲委派机制加载类</span></span><br><span class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Delegating to parent classloader1 &quot;</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">&quot;  Loading class from parent&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、默认是设置delegate是false的,那么就会先用WebAppClassLoader进行加载</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">&quot;  Searching local repositories&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                    log.debug(<span class="string">&quot;  Loading class from local repository&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、如果在WebAppClassLoader没找到类，那么就委托给AppClassLoader去加载</span></span><br><span class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                log.debug(<span class="string">&quot;  Delegating to parent classloader at end: &quot;</span> + parent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">&quot;  Loading class from parent&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-4-Tomcat如何隔离Web应用"><a href="#1-4-Tomcat如何隔离Web应用" class="headerlink" title="1.4 Tomcat如何隔离Web应用"></a>1.4 Tomcat如何隔离Web应用</h2><p>Tomcat作为Servlet容器，它负责加载我们的Servlet类，此外它还负责加载Servlet所依赖的JAR包。并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的JAR包。Tomcat此时需要解决下面这三个问题：</p><ol><li>Tomcat运行了两个Web应用程序，两个Web应用中有同名的Servlet,但是功能不同，Tomcat需要同时加载和管理这两个同名的Servlet类，保证它们不会冲突。Tomcat是如何实现Web应用之间的所有类都完成隔离的？</li><li>两个Web应用都依赖同一个第三方的JAR包，比如Spring,Spring的JAR包被加载到内存后，Tomcat要保证这两个Web应用能够共享，也就是说Spring的JAR包只被加载一次，否则随着依赖第三方JAR包的增多，JVM的内存会膨胀，Tomcat是如何解决的？</li><li>跟JVM一样，我们需要隔离Tomcat本身的类和Web应用的类。Tomcat是怎么实现的？<br>也就是如何实现内部类隔离，三方JAR包资源共享，以及自身的隔离性</li></ol><h3 id="Tomcat类加载器的层次结构"><a href="#Tomcat类加载器的层次结构" class="headerlink" title="Tomcat类加载器的层次结构"></a>Tomcat类加载器的层次结构</h3><p>为了解决这些问题，Tomcat设计了类加载器的层次结构，它们的关系如下图所示：<br><img width="1668" height="2034" alt="image" src="https://github.com/user-attachments/assets/ffc48507-ed9f-47a8-9b39-76ff73eaa2be" /></p><ul><li>commonLoader:Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器以及本身各个Webapp访问；</li><li>catalinaLoader:Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li><li>sharedLoader:各个Webapp共享的类加载器，加载路径中的class对于所有的Webapp可见，但是对于Tomcat容器不可见；</li><li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class，只对当前webapp可见，加载war包里相关的类，每个war包应用都有自己的WebAppClassLoader，实现相互隔离，加载对应各自的依赖版本</li></ul><h3 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h3><p>当一个ClassLoader装载一个类的时候，除非显式的使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。<br>比如Spring作为Bean工厂，它需要创建业务类的实例，并且创建业务类实例之前需要加载这些类。Spring是通过Class.forName来加载业务类的，下面是forName的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName(className,<span class="literal">true</span>,CLassLoader.getClassLoader(caller),caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forName的函数中，会默认使用调用者的类加载器去加载业务类。<br>Web应用之间共享的JAR包可以交给SharedClassLoader来加载，从而避免重复加载。Spring作为共享的第三方JAR包，它本身是由SharedClassLoader来加载的，Spring又要去加载业务类，按照前面的那条规则，加载Spring的类加载器也会用来加载业务类，但是业务类再Web应用目录下，不在SharedClassLoader的加载路径下，Tomcat是如何解决这个问题的？</p><h3 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h3><p>于是线程上下文加载器登场了，它其实是一种类加载器传递机制。为什么叫做“线程上下文加载器”？因为这个类加载器保存在线程私有数据里，只要是同一个线程，一旦设置了线程上下文加载器，在线程后续执行过程中就能把这个线程类加载器取出来使用。因此Tomcat为每个Web应用创建一个WebAppClassLoader类加载器，并在启动Web应用的线程里设置线程上下文加载器，这样Spring在启动时就将线程上下文类加载器取出来，用来加载Bean。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure><p>线程上下文加载器不仅仅可以用在Tomcat和Spring类加载器的场景里，核心框架类需要加载具体实现类时都可以用到它，比如我们熟悉的JDBC就是通过上下文类加载器来加载不同的数据库驱动的</p><h1 id="2-Tomcat热加载和热部署"><a href="#2-Tomcat热加载和热部署" class="headerlink" title="2. Tomcat热加载和热部署"></a>2. Tomcat热加载和热部署</h1><p>项目开发过程中，经常要改动Java&#x2F;JSP文件，但是又不想重新启动Tomcat,有两种方式：热加载和热部署。热部署表示重新部署应用，它执行的主体是HOST。热加载表示重新加载class，它的执行主体是Context。</p><ul><li>热加载：在server.xml -&gt; context标签中 设置 reloadable &#x3D; “true”<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;C:\project&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/project&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>热部署：在server.xml -&gt; Host标签中 设置 autoDeploy&#x3D;”true”<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARS</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>它们的区别是：</li><li>热加载的实现方式是Web容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，这个过程中不会清空Session，一般用在开发环境</li><li>热部署原理类似，也是由后台线程定时检测Web应用的变化，但它会重新加载整个Web应用。这种方式会清空Session，比热加载更加彻底，一般用于生产环境</li></ul><h2 id="2-1-Tomcat开启后台线程执行周期性任务"><a href="#2-1-Tomcat开启后台线程执行周期性任务" class="headerlink" title="2.1 Tomcat开启后台线程执行周期性任务"></a>2.1 Tomcat开启后台线程执行周期性任务</h2><p>Tomcat 通过ScheduledThreadPoolExecutor（定时线程池） 管理后台周期性任务，核心是在容器初始化时（如 Service 启动阶段）创建固定数量的后台线程，绑定到 Catalina 生命周期中统一管理。典型场景包括：会话过期清理（定期扫描 HttpSession，销毁超时会话）、日志滚动（按时间 &#x2F; 大小切割访问日志）、连接池维护（检测并回收空闲数据库连接）、集群节点心跳检测等。任务调度支持 “固定延迟”（如每隔 30 秒执行）或 “固定速率”（如每分钟执行一次），且线程池会自动处理任务异常，避免单个任务失败导致整个线程池崩溃，确保周期性任务稳定执行且不阻塞主线程。</p><h2 id="2-2-Tomcat热加载实现原理"><a href="#2-2-Tomcat热加载实现原理" class="headerlink" title="2.2 Tomcat热加载实现原理"></a>2.2 Tomcat热加载实现原理</h2><p>Tomcat 热加载的核心是基于类加载器的 “重新加载” 机制，仅针对 Web 应用内部的类和资源（如 WEB-INF&#x2F;classes、WEB-INF&#x2F;lib），无需重启整个 Tomcat 容器。具体逻辑：</p><ol><li>后台线程（如 WebAppLoader 的监控线程）定期扫描 WEB-INF&#x2F;classes 和 lib 目录下文件的 “最后修改时间”，对比上次扫描记录；</li><li>若检测到文件变化（如.class 文件更新、JAR 包替换），Tomcat 会销毁当前 Web 应用的WebAppClassLoader（应用级类加载器）（同时销毁其加载的所有类、Servlet 实例、线程资源）；</li><li>创建新的 WebAppClassLoader，重新加载更新后的类和资源，初始化 Servlet、Spring 容器等组件，完成 “热加载”。该机制仅适用于开发环境（如调试时修改代码），且无法处理服务器级配置（如 server.xml）的变化，因这类配置依赖 Tomcat 核心类加载器，无法单独重新加载。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动资源监控线程（位于WebAppLoader中）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 启动定时监控线程（每2秒扫描一次资源变化）</span></span><br><span class="line">    monitorThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ResourceMonitor</span>(), <span class="string">&quot;WebappResourceMonitor&quot;</span>);</span><br><span class="line">    monitorThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    monitorThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 资源监控逻辑（检测类或JAR包变化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceMonitor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 上次修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 扫描WEB-INF/classes和lib目录的最后修改时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentModified</span> <span class="operator">=</span> getResourcesLastModified();</span><br><span class="line">            <span class="keyword">if</span> (currentModified &gt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// 检测到变化，触发热加载</span></span><br><span class="line">                context.reload();  <span class="comment">// 调用Context的重新加载方法</span></span><br><span class="line">                lastModified = currentModified;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 间隔2秒扫描</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Context的reload方法（销毁旧类加载器，创建新的）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁当前Web应用的类加载器和资源</span></span><br><span class="line">    <span class="type">WebappClassLoader</span> <span class="variable">oldLoader</span> <span class="operator">=</span> <span class="built_in">this</span>.loader;</span><br><span class="line">    oldLoader.stop();  <span class="comment">// 释放类、Servlet实例等资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的类加载器，重新加载资源</span></span><br><span class="line">    <span class="built_in">this</span>.loader = <span class="keyword">new</span> <span class="title class_">WebappClassLoader</span>(oldLoader.getParent());</span><br><span class="line">    <span class="built_in">this</span>.loader.start();  <span class="comment">// 加载更新后的类和配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-Tomcat热部署实现原理"><a href="#2-3-Tomcat热部署实现原理" class="headerlink" title="2.3 Tomcat热部署实现原理"></a>2.3 Tomcat热部署实现原理</h2><p>Tomcat 热部署是整个 Web 应用的 “卸载 - 重新部署” 过程，支持替换应用的完整资源（包括 WAR 包、配置文件、静态资源等），可用于生产环境的版本更新（通常需短暂停止应用）。具体逻辑：</p><ol><li>触发方式（手动复制新 WAR 包、通过 Manager 应用 &#x2F; API 发送部署指令）；</li><li>卸载旧应用：停止应用所有 Servlet 和 Filter，关闭数据库连接池、线程池等资源，销毁对应的 WebAppClassLoader 和应用上下文（Context），删除旧应用的临时目录；</li><li>部署新应用：解压新 WAR 包（若为 WAR 格式），创建新的 Context 和 WebAppClassLoader，加载新的类、资源和配置文件，初始化 Servlet、Listener 等组件，绑定到 Connector（连接器）接收请求。</li></ol><p>与热加载的核心区别是：热部署针对 “整个应用” 的替换，可处理配置文件（如 web.xml）的变化；热加载仅针对 “类和资源” 的重新加载，依赖应用级类加载器，不涉及 Context 销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 热部署触发（检测webapps目录下的WAR包变化）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostConfig</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType().equals(Lifecycle.PERIODIC_EVENT)) &#123;</span><br><span class="line">            checkResources();  <span class="comment">// 定期检查应用资源变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkResources</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描webapps目录下的WAR包或目录</span></span><br><span class="line">        <span class="keyword">for</span> (File app : webappsDir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isModified(app)) &#123;  <span class="comment">// 检测到应用更新（如WAR包替换）</span></span><br><span class="line">                redeploy(app);  <span class="comment">// 执行热部署</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 重新部署逻辑（卸载旧应用+部署新应用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">redeploy</span><span class="params">(File app)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> app.getName();</span><br><span class="line">    <span class="comment">// 第一步：卸载旧应用</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">oldContext</span> <span class="operator">=</span> host.findContext(appName);</span><br><span class="line">    <span class="keyword">if</span> (oldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        host.removeChild(oldContext);  <span class="comment">// 从Host中移除旧Context</span></span><br><span class="line">        oldContext.stop();  <span class="comment">// 停止旧应用（释放连接池、线程等）</span></span><br><span class="line">        oldContext.destroy();  <span class="comment">// 销毁旧应用资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步：部署新应用</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">newContext</span> <span class="operator">=</span> createContext(app);  <span class="comment">// 创建新Context</span></span><br><span class="line">    host.addChild(newContext);  <span class="comment">// 添加到Host</span></span><br><span class="line">    newContext.start();  <span class="comment">// 启动新应用（加载新类、初始化Servlet等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
          <category> 中间件 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 类加载机制 </tag>
            
            <tag> 热部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 整体结构以及设计源码分析</title>
      <link href="/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Tomcat是什么？"><a href="#1-Tomcat是什么？" class="headerlink" title="1. Tomcat是什么？"></a>1. Tomcat是什么？</h1><p>Tomcat 是一款<strong>开源的 Java Web 服务器 + Servlet 容器</strong>，由 Apache 软件基金会开发维护，主要用于部署和运行 Java Web 应用程序（如基于 Servlet、JSP、Spring MVC 等技术的应用）。它是 Java 生态中最流行的 Web 容器之一，兼具轻量性、稳定性和易扩展性，广泛用于开发和生产环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-<span class="number">10.0</span><span class="number">.0</span>/</span><br><span class="line">├── <span class="built_in">bin</span>/                <span class="comment"># 脚本与可执行文件目录</span></span><br><span class="line">├── conf/               <span class="comment"># 配置文件目录</span></span><br><span class="line">├── lib/                <span class="comment"># 核心依赖库目录</span></span><br><span class="line">├── webapps/            <span class="comment"># Web 应用部署目录</span></span><br><span class="line">├── logs/               <span class="comment"># 日志文件目录</span></span><br><span class="line">├── temp/               <span class="comment"># 临时文件目录</span></span><br><span class="line">├── work/               <span class="comment"># JSP 编译缓存目录</span></span><br><span class="line">└── LICENSE、NOTICE 等  <span class="comment"># 许可证和说明文件</span></span><br></pre></td></tr></table></figure><img width="3182" height="870" alt="image" src="https://github.com/user-attachments/assets/d66e17b1-c5e5-4c58-b54e-464dc92b3c83" /><h1 id="2-WEB应用部署的三种方式"><a href="#2-WEB应用部署的三种方式" class="headerlink" title="2. WEB应用部署的三种方式"></a>2. WEB应用部署的三种方式</h1><h3 id="2-1-自动部署（Webapps-目录部署）"><a href="#2-1-自动部署（Webapps-目录部署）" class="headerlink" title="2.1 自动部署（Webapps 目录部署）"></a>2.1 自动部署（Webapps 目录部署）</h3><p>这是最简便、最常用的部署方式，适合开发环境或简单场景，依赖 Tomcat 的自动检测机制。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Tomcat 启动时会自动扫描 <code>webapps/</code> 目录（默认部署目录），对目录中的 Web 应用（包括 <strong>WAR 包</strong> 或 <strong>解压后的应用目录</strong>）进行部署；运行过程中，若向 <code>webapps/</code> 目录添加新的应用（如复制 WAR 包），Tomcat 也会自动检测并部署（需开启自动部署配置，默认开启）。</p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p>将 Web 应用打包为 WAR 包（如 <code>myapp.war</code>），或直接获取解压后的应用目录（如 <code>myapp/</code>）。</p></li><li><p>将 WAR 包或目录复制到 Tomcat 的 <code>webapps/</code> 目录下。</p></li><li><p>启动 Tomcat（<code>bin/startup.sh</code> 或 <code>startup.bat</code>），Tomcat 会自动处理：</p><ul><li><p>若为 WAR 包：自动解压为同名目录（如 <code>myapp.war</code> → <code>myapp/</code>）。</p></li><li><p>若为目录：直接识别为 Web 应用。</p></li></ul></li><li><p>访问应用：通过 <code>http://localhost:8080/应用名</code> 访问（如 <code>http://localhost:8080/myapp</code>）。</p></li></ol><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li><p><strong>优点</strong>：操作简单，无需手动配置，适合开发调试或快速部署。</p></li><li><p><strong>缺点</strong>：灵活性低（应用必须放在 <code>webapps/</code> 目录）；若需修改应用路径或配置，需额外操作。</p></li></ul><h3 id="2-2-配置文件部署（Context-配置部署）"><a href="#2-2-配置文件部署（Context-配置部署）" class="headerlink" title="2.2 配置文件部署（Context 配置部署）"></a>2.2 配置文件部署（Context 配置部署）</h3><p>通过手动配置 Tomcat 的 XML 配置文件，指定应用的部署路径和实际存储位置，适合需要自定义部署路径（非 <code>webapps/</code> 目录）或复杂配置的场景。</p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>Tomcat 通过 <strong>Context 元素</strong> 定义 Web 应用的映射关系（访问路径 → 实际目录）。Context 配置可放在两个位置：</p><ul><li>在 <code>conf/server.xml</code> 中配置（不推荐）</li></ul><p>在 <code>server.xml</code> 的 <code>&lt;Host&gt;</code> 标签内添加 <code>&lt;Context&gt;</code> 元素，指定应用的访问路径和实际位置。</p><p><strong>示例</strong>：</p><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Service</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">...</span>&gt;</span><span class="comment">&lt;!-- 配置 myapp 应用：访问路径为 /myapp，实际目录为 /opt/apps/myapp --&gt;</span><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/myapp&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;/opt/apps/myapp&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">Host</span>&gt;</span><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span><span class="tag">&lt;/<span class="name">Service</span>&gt;</span><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>path</code>：应用的访问路径（如 <code>/myapp</code> 对应 <code>http://localhost:8080/myapp</code>）。</p></li><li><p><code>docBase</code>：应用的实际存储路径（可绝对路径或相对 <code>appBase</code> 的路径）。</p></li><li><p><code>reloadable</code>：是否自动重载（<code>true</code> 表示当应用类文件变化时，Tomcat 自动重启应用，适合开发环境）。</p></li></ul><ul><li>在 <code>conf/Catalina/localhost/</code> 下创建独立 XML 文件（推荐）</li></ul><p>在 <code>conf/Catalina/localhost/</code> 目录下创建以 <strong>应用访问路径</strong> 命名的 XML 文件（如 <code>myapp.xml</code>），文件内容为 <code>&lt;Context&gt;</code> 元素。</p><p><strong>示例</strong>：创建 <code>conf/Catalina/localhost/myapp.xml</code>，内容：</p><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 访问路径为 /myapp，实际目录为 /opt/apps/myapp --&gt;</span><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;/opt/apps/myapp&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>此时应用的访问路径由 XML 文件名决定（<code>myapp.xml</code> → 访问路径 <code>/myapp</code>）。</p></li><li><p>无需重启 Tomcat，添加 &#x2F; 修改此文件后，Tomcat 会自动部署 &#x2F; 更新应用（热部署）。</p></li></ul><h4 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li><p><strong>优点</strong>：灵活（应用可放在任意目录）、支持热部署（独立 XML 文件方式）、便于集中管理配置。</p></li><li><p><strong>缺点</strong>：需手动编写配置文件，对新手稍复杂。</p></li></ul><h3 id="2-3-Manager-应用部署（远程管理部署）"><a href="#2-3-Manager-应用部署（远程管理部署）" class="headerlink" title="2.3 Manager 应用部署（远程管理部署）"></a>2.3 Manager 应用部署（远程管理部署）</h3><p>通过 Tomcat 自带的 <strong>Manager 应用</strong>（网页或 API）远程部署应用，适合生产环境中无需直接操作服务器文件系统的场景（如运维人员远程部署）。</p><h4 id="前提：配置-Manager-访问权限"><a href="#前提：配置-Manager-访问权限" class="headerlink" title="前提：配置 Manager 访问权限"></a>前提：配置 Manager 访问权限</h4><ol><li><p>编辑 <code>conf/tomcat-users.xml</code>，添加具有 <code>manager-gui</code>（网页管理）或 <code>manager-script</code>（API 管理）权限的用户：</p></li><li><p>xml</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span>&gt;</span><span class="comment">&lt;!-- 允许通过网页管理部署 --&gt;</span><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>重启 Tomcat 使配置生效。</li></ol><h4 id="操作步骤（网页方式）："><a href="#操作步骤（网页方式）：" class="headerlink" title="操作步骤（网页方式）："></a>操作步骤（网页方式）：</h4><ol><li><p>访问 Manager 应用：<code>http://localhost:8080/manager/html</code>，输入配置的用户名 &#x2F; 密码登录。</p></li><li><p>在 “Deploy” 区域部署应用：</p><ul><li><p><strong>方式 1（上传 WAR 包）</strong>：点击 “Browse” 选择本地 WAR 包，点击 “Deploy” 上传并部署。</p></li><li><p><strong>方式 2（指定 URL）</strong>：在 “Context path” 输入访问路径（如 <code>/myapp</code>），在 “WAR or Directory URL” 输入远程 WAR 包的 URL（如 <code>http://example.com/myapp.war</code>），点击 “Deploy”。</p></li></ul></li><li><p>部署成功后，可在 “Applications” 列表中看到应用，支持启动、停止、卸载等操作。</p></li></ol><h1 id="3-Tomcat整体架构分析"><a href="#3-Tomcat整体架构分析" class="headerlink" title="3. Tomcat整体架构分析"></a>3. Tomcat整体架构分析</h1><p><strong>Tomcat</strong>本质上只<strong>需要</strong>实现两个核心功能：</p><ul><li><p>处理Socket连接，负责网络字节流Request和Response对象的转化</p></li><li><p>加载和管理Servlet，以及具体处理Request请求</p></li></ul><p>因此Tomcat设计两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情，连接器负责对外交流，容器负责内部处理</p><img width="2760" height="1400" alt="image" src="https://github.com/user-attachments/assets/cae9cc54-f3d8-4dba-8875-0deba0771b48" /><h2 id="3-1-Tom核心组件详解"><a href="#3-1-Tom核心组件详解" class="headerlink" title="3.1 Tom核心组件详解"></a>3.1 Tom核心组件详解</h2><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Server</strong></td><td>整个 Tomcat 实例的顶层容器，代表一个运行的 Tomcat 服务器，可包含多个 Service。</td></tr><tr><td><strong>Service</strong></td><td>关联一个或多个 Connector 与一个 Container，负责将请求从 Connector 传递到 Container。</td></tr><tr><td><strong>Connector</strong></td><td>监听指定端口（如 8080），接收客户端 HTTP 请求，解析请求数据并传递给 Container，同时将 Container 的响应返回给客户端。支持 HTTP、HTTPS、AJP 等协议。</td></tr><tr><td><strong>Container</strong></td><td>负责处理请求的核心组件，内部采用层级结构：</td></tr><tr><td><strong>Servlet</strong></td><td>业务逻辑组件，由 Container 调用，处理具体的 HTTP 请求（如接收参数、访问数据库、生成响应）。</td></tr></tbody></table><h3 id="Server组件"><a href="#Server组件" class="headerlink" title="Server组件"></a>Server组件</h3><p>整个 Tomcat 实例的顶层容器，代表一个运行的 Tomcat 服务器，可包含多组服务（ Service ）。负责管理和启动各个Service，同时监听8005端口发送过来的shutdown命令</p><h3 id="Service组件"><a href="#Service组件" class="headerlink" title="Service组件"></a>Service组件</h3><p>每个service组件都包含了若干用于接收客户端消息的Connector组件和处理请求的Engine组件，Service组件还包含了若干Executor组件，每个Executor都是一个线程池，它可以为Service内部所有组件提供线程池执行任务。Tomcat内部可能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat内部配置多个Service，可以实现通过不同端口号来访问同一台机器上部署的不同应用</p><img width="2760" height="1400" alt="image" src="https://github.com/user-attachments/assets/e3d8b4e6-f43e-4c1d-a933-1636a6947687" /><h3 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h3><p>Tomcat与外部世界的连接器，监听固定端口接收外部请求，传递给Container,并将Container处理的结果返回给外部。连接器对Servlet容器屏蔽了不同的应用层协议以及IO模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象</p><h3 id="Container组件"><a href="#Container组件" class="headerlink" title="Container组件"></a>Container组件</h3><p>容器，顾名思义就是用来装载对象的器具，在Tomcat里，容器就是用了装载servlet的。tomcat通过分层架构，使得Servlet容器具有很好的灵活性。Tomcat设计了四种容器，分别是Engine、Host、Context和Wrapper。这四种容器并不是平行关系，而是父子关系。</p><ul><li><p><strong>Engine</strong>：引擎，Servlet的顶层容器，用来管理多个虚拟站点，一个Service最多只能有一个Engine</p></li><li><p><strong>Host</strong>:虚拟主机，负责web应用的部署和context的创建。可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机可以部署多个Web应用程序</p></li><li><p><strong>Context</strong>：Web应用程序上下文，包含多个Wrapper，负责Web配置的解析，管理所有的Web资源。一个Context对应一个Web应用程序</p></li><li><p><strong>Wrapper</strong>:表示一个Servlet,最底层的容器，是对Servlet的封装，负责Servlet实例的创建、执行和销毁</p></li></ul><img width="289" height="290" alt="image" src="https://github.com/user-attachments/assets/7abb6b51-c53a-4f70-b8b1-90947b6fe8d0" /><h2 id="3-2-请求定位Servlet的过程"><a href="#3-2-请求定位Servlet的过程" class="headerlink" title="3.2 请求定位Servlet的过程"></a>3.2 请求定位Servlet的过程</h2><p>网络请求先到达 Connector，也就是连接器，它负责监听端口，接收 HTTP 请求。然后，Connector 会把请求封装成 Request 对象，可能还有 Response 对象，然后传递给 Engine 处理。接下来，Engine 会根据请求的 Host 头找到对应的 Host 虚拟主机。Host 再根据请求的上下文路径（Context Path）找到对应的 Context，也就是 Web 应用。然后，Context 内部需要根据请求的 Servlet 路径（Servlet Path）来匹配对应的 Servlet。这里可能涉及到 Web 应用的 web.xml 配置或者注解定义的 Servlet 映射。</p><h1 id="4-Tomcat架构设计"><a href="#4-Tomcat架构设计" class="headerlink" title="4. Tomcat架构设计"></a>4. Tomcat架构设计</h1><h2 id="4-1-Connector高内聚低耦合设计"><a href="#4-1-Connector高内聚低耦合设计" class="headerlink" title="4.1 Connector高内聚低耦合设计"></a>4.1 Connector高内聚低耦合设计</h2><p>Tomcat连接器需要实现的功能：</p><ul><li><p>监听网络端口</p></li><li><p>接受网络连接请求</p></li><li><p>读取请求网络字节流</p></li><li><p>根据具体应用层协议解析字节流，生成统一的TomcatRequest对象</p></li><li><p>将TomcatRequest对象转化成ServletRequest对象</p></li><li><p>调用Servlet容器，得到ServletResponse对象</p></li><li><p>将ServletResponse对象转化成TomcatResponse对象</p></li><li><p>将TomcatResponse转成网络字节流</p></li><li><p>将响应字节流写回浏览器</p></li></ul><p>通过连接器需要实现的功能列表，会发现连接器需要实现3个高内聚的功能：</p><ul><li><p>网络通信</p></li><li><p>应用层协议解析</p></li><li><p>Tomcat Request&#x2F;Response 与 Servlet Request&#x2F;Response相互转化</p></li></ul><h3 id="ProtocolHandler"><a href="#ProtocolHandler" class="headerlink" title="ProtocolHandler"></a>ProtocolHandler</h3><blockquote><p>因此Tomcat设计者设计了3个组件来实现这3个核心功能，分别是EndPoint、Processor和Adapter</p></blockquote><ul><li><p><strong>Endpoint：</strong>&#x8D1F;责提供字节流给Processor</p></li><li><p><strong>Processor：</strong>&#x8D1F;责提供TomcatRequest对象给Adapter</p></li><li><p><strong>Adapter</strong>：负责提供ServletRequest对象给容器</p></li></ul><blockquote><p>组件之间通过抽象接口交互，这样的好处是封装变化。这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加系统的复用性，并降低系统耦合度</p></blockquote><img width="4698" height="1430" alt="image" src="https://github.com/user-attachments/assets/78713cf6-af9e-4b54-9133-bf2cd6f8e859" /><p>由于IO模型和应用层协议之间可以自由组合，比如NIO+HTTP或者NIO2+NJP。Tomcat设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫做ProtocolHandler的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类，比如：Http11NioProtocol和AjpNioProtocol</p><p>除了这些变化点，系统也存在一些相对稳定的部分，因此tomcat设计了一系列抽象基类来封装这些稳定的部分，抽象基类AbstractProtocol实现类ProtocolHandler接口。每一种应用层协议有自己的抽象基类，比如AbstractAjpProtocol和AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。</p><img width="821" height="468" alt="image" src="https://github.com/user-attachments/assets/ef9a7208-6550-4783-a507-72d1427b4e17" /><h4 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h4><p>endpoint是通信端点，即监听通信的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此EndPoint是用来实现TCP&#x2F;IP协议的。endpoint是一个接口，对应的抽象实现类是AbstractEndpoint，其子类中，例如NioEndpoint和Nio2Endpoint中，有两个重要的子组件：Acceptor和SocketProcessor.其中Acceptor用于监听Socket连接请求。SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理，为了提高处理能力，SocketProcessor被提交到线程池来执行，而这个线程池叫做执行器（Executor）</p><h4 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h4><p>Processor用来实现HTTP&#x2F;AJP协议，Processor接收来自Endpoint的Socket,读取字节流解析成TomcatRequset和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象，Processor是一个接口，定义了请求的处理等方法，它的抽象实现类AbstractProcessor对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有AJPProcessor\HTTP11Processor等，这些具体实现类实现了特定协议的解析方法和请求处理方式。EndPoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池去处理，SocketProcessor的Run方法会调用Processor组件去解析应用层协议，Processor通过解析生成Request对象后没回调有Adapter的Service方法。</p><img width="4950" height="1430" alt="image" src="https://github.com/user-attachments/assets/7a2eef46-6b54-4baf-abf2-0cf376bcbb12" /><h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h4><p>由于协议不同，客户端发过来的请求信息也不相同，Tomcat定义了自己的Request类来存放这些请求信息。ProtocolHandler接口负责解析请求并生成TomcatRequest类。但是这个Request对象不是标准的ServletRequest，也就是意味着，不能使用TomcatRequest作为参数来调用容器。Tomcat的设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Service方法，传入的是TomcatRequest对象CoyoteAdapter负责将TomcatRequest和ServletRequest进行传化，再调用容器的Service方法。</p><p>设计复杂系统的思路：</p><p>首先分析需求，列出功能点，根据功能以及高内聚、低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，再抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。tomcat的父子容器组合模式设计，tomcat通过组合模式来管理这些容器。具体的实现方法是，所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象具有使用的一致性。</p><h2 id="4-2-Pipeline-Valve责任链模式设计"><a href="#4-2-Pipeline-Valve责任链模式设计" class="headerlink" title="4.2 Pipeline-Valve责任链模式设计"></a>4.2 Pipeline-Valve责任链模式设计</h2><p>连接器中的Adapter会调用容器的Service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host继续处理，依次类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet处理，这个过程中使用了Pipeline-Valve管道责任链模式</p><p>这种设计模式是指再一个请求处理的过程中有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完成之后再调用下一个处理者继续处理。</p><img width="3620" height="2316" alt="image" src="https://github.com/user-attachments/assets/c8d0c35e-e97e-46ba-8687-e1fe0cce5e82" /><h2 id="4-3-Tomcat生命周期设计"><a href="#4-3-Tomcat生命周期设计" class="headerlink" title="4.3 Tomcat生命周期设计"></a>4.3 Tomcat生命周期设计</h2><p>通过对Tomcat架构的分析，我们知道了Tomcat都有哪些组件，以及组件之间的关系，处理http请求的流程，如果想让tomcat能够对外提供服务，我们需要创建、组装并启动Tomcat组件，在服务停止的时候，我们还需要释放资源，销毁Tomcat组件，这是一个动态的过程。Tomcat需要动态地管理这些组件的生命周期。</p><h3 id="一键式启停：LifeCycle接口"><a href="#一键式启停：LifeCycle接口" class="headerlink" title="一键式启停：LifeCycle接口"></a>一键式启停：LifeCycle接口</h3><p>Tomcat 组件层级复杂（如 <code>Server → Service → Engine → Host → Context</code>），若每个组件各自实现启停逻辑，会导致：</p><ul><li><p>组件间依赖混乱（如必须先启动 <code>Connector</code> 才能接收请求，但 <code>Connector</code> 依赖 <code>Service</code> 初始化）；</p></li><li><p>无法统一控制（启动 &#x2F; 停止操作需逐个处理组件，无法 “一键操作”）。</p></li></ul><p><code>LifeCycle</code> 接口通过以下方式解决问题：</p><ol><li><p><strong>统一生命周期方法</strong>：定义所有组件必须实现的初始化、启动、停止、销毁方法；</p></li><li><p><strong>状态管理</strong>：规范组件的生命周期状态（如 “未初始化”“启动中”“已启动” 等）及状态转换规则；</p></li><li><p><strong>事件监听</strong>：支持通过监听器感知组件状态变化，实现扩展逻辑（如启动前初始化资源、停止后释放连接）。</p></li></ol><h4 id="1-核心方法（定义在-org-apache-catalina-Lifecycle-接口中）"><a href="#1-核心方法（定义在-org-apache-catalina-Lifecycle-接口中）" class="headerlink" title="1. 核心方法（定义在 org.apache.catalina.Lifecycle 接口中）"></a>1. 核心方法（定义在 <code>org.apache.catalina.Lifecycle</code> 接口中）</h4><h4 id="2-生命周期状态流转（关键状态）"><a href="#2-生命周期状态流转（关键状态）" class="headerlink" title="2. 生命周期状态流转（关键状态）"></a>2. 生命周期状态流转（关键状态）</h4><p>Tomcat 定义了严格的状态转换规则（通过 <code>LifecycleState</code> 枚举），确保组件按顺序执行生命周期操作，核心状态流转如下：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW（新建未初始化）→ INITIALIZING（初始化中）→ INITIALIZED（已初始化）</span><br><span class="line">→ STARTING_PREP（启动准备）→ STARTING（启动中）→ STARTED（已启动）</span><br><span class="line">→ STOPPING_PREP（停止准备）→ STOPPING（停止中）→ STOPPED（已停止）</span><br><span class="line">→ DESTROYING（销毁中）→ DESTROYED（已销毁）</span><br></pre></td></tr></table></figure><ul><li><p>每个状态转换只能通过特定方法触发（如 <code>start()</code> 触发从 <code>INITIALIZED</code> 到 <code>STARTED</code> 的转换）；</p></li><li><p>状态转换不可逆（如 <code>STARTED</code> 不能直接回到 <code>INITIALIZED</code>，必须先 <code>stop()</code> 到 <code>STOPPED</code>）。</p></li></ul><h4 id="3-“一键式启停”-的实现逻辑"><a href="#3-“一键式启停”-的实现逻辑" class="headerlink" title="3. “一键式启停” 的实现逻辑"></a>3. “一键式启停” 的实现逻辑</h4><p><code>LifeCycle</code> 接口的层级联动机制，是 “一键式启停” 的核心：<strong>顶层组件的生命周期方法会自动触发所有子组件的对应方法</strong>。</p><p>以 Tomcat 启动为例（从 <code>Server</code> 到子组件）：</p><ol><li><p>用户执行 <code>startup.sh</code> 或点击启动按钮，最终调用 <strong><code>Server</code> 的 <code>start()</code> 方法</strong>；</p></li><li><p><code>Server</code> 的 <code>start()</code> 会先执行自身启动逻辑，然后遍历所有子组件（<code>Service</code>），调用每个 <code>Service</code> 的 <code>start()</code> 方法；</p></li><li><p><code>Service</code> 的 <code>start()</code> 会启动自身，再调用子组件 <code>Engine</code> 和 <code>Connector</code> 的 <code>start()</code> 方法；</p></li><li><p><code>Engine</code> 的 <code>start()</code> 会启动自身，再调用子组件 <code>Host</code> 的 <code>start()</code> 方法；</p></li><li><p>以此类推，直到最底层的 <code>Context</code>（Web 应用）和 <code>Wrapper</code>（Servlet）启动完成。</p></li></ol><p>停止过程同理：调用 <code>Server</code> 的 <code>stop()</code> 方法，会逐级触发所有子组件的 <code>stop()</code> 方法，最终实现 “一键停止”。</p><h4 id="4-3-4-监听器机制：扩展生命周期行为"><a href="#4-3-4-监听器机制：扩展生命周期行为" class="headerlink" title="4.3.4 监听器机制：扩展生命周期行为"></a>4.3.4 监听器机制：扩展生命周期行为</h4><p><code>LifeCycle</code> 接口通过 <strong><code>LifecycleListener</code> 监听器</strong>支持扩展，允许在组件状态变化时执行自定义逻辑（如日志记录、资源预热）。</p><p>示例：给 <code>Host</code> 组件添加启动监听器，在 Host 启动后打印日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostStartListener</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 当事件类型为“已启动”时触发</span></span><br><span class="line">        <span class="keyword">if</span> (Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">            <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> (Host) event.getSource();</span><br><span class="line">            System.out.println(<span class="string">&quot;Host &quot;</span> + host.getName() + <span class="string">&quot; 已启动，准备处理请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Host 组件中注册监听器（通常在 server.xml 或代码中配置）</span></span><br><span class="line"><span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">host.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">HostStartListener</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
          <category> 中间件 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Tomcat 架构 </tag>
            
            <tag> Servlet 容器 </tag>
            
            <tag> Pipeline-Valve 模式 </tag>
            
            <tag> LifeCycle 接口 </tag>
            
            <tag> Tomcat 源码分析 </tag>
            
            <tag> Web 应用部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G1 垃圾收集器学习笔记</title>
      <link href="/2025/09/22/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2025/09/22/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="G1垃圾收集器学习笔记"><a href="#G1垃圾收集器学习笔记" class="headerlink" title="G1垃圾收集器学习笔记"></a>G1垃圾收集器学习笔记</h1><h2 id="2025-09-23"><a href="#2025-09-23" class="headerlink" title="2025-09-23"></a>2025-09-23</h2><h2 id="一、G1垃圾收集器概述"><a href="#一、G1垃圾收集器概述" class="headerlink" title="一、G1垃圾收集器概述"></a>一、G1垃圾收集器概述</h2><p>G1（Garbage-First）是Java 9默认的垃圾收集器，核心特性如下：  </p><ul><li><strong>取消物理分代</strong>：将内存划分为2048个逻辑<code>Region</code>（默认值）  </li><li><strong>动态分区管理</strong>：年轻代&#x2F;老年代区域可相互转化  </li><li><strong>巨型对象处理</strong>：新增<code>Humongous</code>区存储超Region 50%的大对象</li></ul><h2 id="二、内存管理机制"><a href="#二、内存管理机制" class="headerlink" title="二、内存管理机制"></a>二、内存管理机制</h2><h3 id="1-内存分区"><a href="#1-内存分区" class="headerlink" title="1. 内存分区"></a>1. 内存分区</h3><ul><li><strong>逻辑分区</strong>：保留年轻代（Eden&#x2F;Survivor）、老年代概念  </li><li><strong>物理结构</strong>：  <ul><li>默认2048个Region（通过<code>-XX:G1HeapRegionSize</code>调整）  </li><li>年轻代初始占比5%（动态调整，上限60%）  </li><li>Eden:Survivor默认比例8:1:1</li></ul></li></ul><h3 id="2-特殊区域"><a href="#2-特殊区域" class="headerlink" title="2. 特殊区域"></a>2. 特殊区域</h3><ul><li><strong>Humongous区</strong>：  <ul><li>存储超过Region 50%的大对象  </li><li>若对象超过单个Region大小，会被分割存储于多个连续Region</li></ul></li></ul><h2 id="三、垃圾回收流程"><a href="#三、垃圾回收流程" class="headerlink" title="三、垃圾回收流程"></a>三、垃圾回收流程</h2><p>G1回收分为四个阶段：  </p><ol><li><strong>初始标记</strong>（Stop The World）  <ul><li>标记GC Roots直接引用对象</li></ul></li><li><strong>并发标记</strong>（Concurrent）  <ul><li>与工作线程并行标记存活对象</li></ul></li><li><strong>最终标记</strong>（Stop The World）  <ul><li>修正并发阶段的增量引用</li></ul></li><li><strong>筛选回收</strong>（Concurrent）  <ul><li>按回收价值排序Region  </li><li>执行复制算法整理内存</li></ul></li></ol><h2 id="四、核心特性"><a href="#四、核心特性" class="headerlink" title="四、核心特性"></a>四、核心特性</h2><ol><li><strong>并行与并发</strong>  <ul><li>多核CPU缩短停顿时间</li></ul></li><li><strong>分代抽象管理</strong>  <ul><li>逻辑分代替代物理分区</li></ul></li><li><strong>空间整合</strong>  <ul><li>整体标记整理 + 局部复制算法  </li><li>减少内存碎片</li></ul></li></ol><h2 id="五、垃圾收集分类"><a href="#五、垃圾收集分类" class="headerlink" title="五、垃圾收集分类"></a>五、垃圾收集分类</h2><h3 id="1-YoungGC（年轻代回收）"><a href="#1-YoungGC（年轻代回收）" class="headerlink" title="1. YoungGC（年轻代回收）"></a>1. YoungGC（年轻代回收）</h3><ul><li><strong>触发条件</strong>：  <ul><li>伊甸区填满时预估回收时间：  <ul><li>若预估时间 &lt; <code>MaxGCPauseMillis</code> → 新增年轻代Region  </li><li>若预估时间 ≈ <code>MaxGCPauseMillis</code> → 触发回收</li></ul></li></ul></li><li><strong>执行逻辑</strong>：  <ul><li>回收所有年轻代Region  </li><li>存活对象晋升至老年代&#x2F;Survivor区</li></ul></li></ul><h3 id="2-MixedGC（混合回收）"><a href="#2-MixedGC（混合回收）" class="headerlink" title="2. MixedGC（混合回收）"></a>2. MixedGC（混合回收）</h3><ul><li><strong>触发条件</strong>：  <ul><li>老年代占用率超过阈值（<code>-XX:InitiatingHeapOccupancyPercent</code>）</li></ul></li><li><strong>执行逻辑</strong>：  <ul><li>回收所有年轻代 + 部分老年代Region（非全部老年代）  </li><li>具体回收数量由回收价值决定</li></ul></li></ul><h3 id="3-Full-GC（负GC）"><a href="#3-Full-GC（负GC）" class="headerlink" title="3. Full GC（负GC）"></a>3. Full GC（负GC）</h3><ul><li><strong>触发条件</strong>：  <ul><li>内存不足（如MixedGC无法完成回收）</li></ul></li><li><strong>执行逻辑</strong>：  <ul><li>单线程标记-清理-压缩内存  </li><li>现代JVM（Java 11+）通过<code>-XX:+UseG1GC -XX:-UseAdaptiveSizePolicy</code>可减少Full GC</li></ul></li></ul><h2 id="六、关键参数"><a href="#六、关键参数" class="headerlink" title="六、关键参数"></a>六、关键参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>目标最大停顿时间（默认200ms）</td></tr><tr><td><code>-XX:G1HeapRegionSize</code></td><td>Region大小（推荐1MB-32MB）</td></tr><tr><td><code>-XX:InitiatingHeapOccupancyPercent</code></td><td>老年代触发并发回收阈值（默认45%）</td></tr></tbody></table><h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h2><ul><li>过度追求低停顿可能导致：  <ul><li>垃圾堆积 → 负GC → 回收成本上升</li></ul></li><li>生产环境建议保持默认参数配置  </li><li>通过<code>-XX:+PrintGCDetails -XX:+PrintGCDateStamps</code>监控GC行为</li></ul><h2 id="八、其他相关回收器"><a href="#八、其他相关回收器" class="headerlink" title="八、其他相关回收器"></a>八、其他相关回收器</h2><ul><li><strong>ZGC</strong>（JDK 11引入的低延迟垃圾收集器）：  <ul><li>支持TB级内存  </li><li>停顿时间&lt;10ms  </li><li>基于Region的着色指针技术</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm">G1官方文档</a>  </li><li><a href="https://docs.oracle.com/javase/11/gctuning/z-garbage-collector.htm">ZGC官方文档</a>  </li><li>《深入理解Java虚拟机》第三版（周志明）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
          <category> 垃圾收集器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> G1 垃圾收集器 </tag>
            
            <tag> JVM </tag>
            
            <tag> Java 虚拟机 </tag>
            
            <tag> 垃圾回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata AT 模式与 XA 模式的区别</title>
      <link href="/2025/09/19/SEATA%E6%BA%90%E7%A0%81%EF%BC%9AAT%E4%B8%8EXA%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/19/SEATA%E6%BA%90%E7%A0%81%EF%BC%9AAT%E4%B8%8EXA%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-模式区别"><a href="#1-模式区别" class="headerlink" title="1. 模式区别"></a>1. 模式区别</h2><ul><li><strong>AT 模式</strong>：生成的是数据源代理（DataSource Proxy），通过代理拦截 SQL 执行，无需额外配置默认模式（Seata 默认支持 AT 模式），而非“数据库动态代理”（表述更精准）。</li><li><strong>XA 模式</strong>：生成的是 XA 数据源代理（XADataSource Proxy），需在 YAML 中显式配置 <code>seata.tx-mode=XA</code>（而非仅“配置默认模式为 XA”），且依赖数据库原生 XA 协议支持（如 MySQL、Oracle 的 XA 事务能力）。</li></ul><h2 id="2-AT-模式流程"><a href="#2-AT-模式流程" class="headerlink" title="2. AT 模式流程"></a>2. AT 模式流程</h2><ul><li>第一步会申请<strong>全局事务 ID（XID）</strong>（需明确“全局”，与分支事务 ID 区分）。</li><li>基于原有分布式服务调用逻辑扩展，实现异常后的<strong>自动回滚</strong>（而非“自动补偿”）——补偿逻辑通过 Undo Log 反向生成 SQL 实现，需明确概念。</li><li><strong>事务开始前</strong>：申请 XID 并存储到 ThreadLocal（Seata 内部通过 <code>RootContext</code> 管理 XID，MDC 通常用于日志打印携带 XID，非核心存储位置，修正存储载体）；往 TC（事务协调器）的全局事务表（global_table）插入记录；将数据库连接的 Auto Commit 改为 <code>false</code>（手动提交）。</li><li><strong>SQL 执行前</strong>：仅对<strong>写操作（insert&#x2F;update&#x2F;delete）</strong> 分析语法并生成前置镜像（查询操作不会触发镜像生成，也不会拼接 <code>for update</code>——<code>for update</code> 是用户业务 SQL 自主使用的行锁语法，AT 模式通过全局锁控制并发，修正“查询加锁”错误）。</li><li><strong>SQL 执行后</strong>：对写操作获取后置镜像（基于主键&#x2F;唯一键查询，确保与前置镜像对应），此时事务未提交。</li><li><strong>后续操作</strong>：将前置&#x2F;后置镜像、Undo Log 写入本地数据库的 undo_log 表（而非“Seata 的 TC 表”，TC 不存储镜像，仅管理事务状态）；向 TC 注册分支事务，TC 分配分支事务 ID（Branch ID），并将分支事务与全局事务关联；同时获取全局锁（往 TC 的 lock_table 插入记录，键为“表名+主键”，而非“事务 ID 作为标识”，修正锁标识逻辑）。</li><li><strong>事务提交&#x2F;回滚</strong>：<ul><li>若正常提交：TC 通知各分支删除 Undo Log，释放全局锁；</li><li>若出现异常：TC 通知各分支执行 Undo Log 回滚（反向 SQL 恢复数据），之后删除 Undo Log 并释放锁；</li><li>后置处理：清除 <code>RootContext</code> 中的 XID，释放数据库连接等资源（修正“清除 XID”的载体）。</li></ul></li></ul><h2 id="3-XID-传递"><a href="#3-XID-传递" class="headerlink" title="3. XID 传递"></a>3. XID 传递</h2><ul><li>微服务间调用时，发起方从 <code>RootContext</code>（而非仅 MDC）获取 XID，通过 HTTP 请求头（默认键为 <code>TX_XID</code>）传递给接收方；</li><li>接收方通过 Spring MVC 拦截器&#x2F;Feign 拦截器解析请求头中的 <code>TX_XID</code>，并绑定到自身的 <code>RootContext</code> 中，从而实现 XID 跨服务传递（MDC 仅用于日志携带 XID，方便排查，非传递核心逻辑）。</li></ul><h2 id="4-其他要点"><a href="#4-其他要点" class="headerlink" title="4. 其他要点"></a>4. 其他要点</h2><ul><li><strong>AT 模式的全局锁</strong>：获取时往 TC 的 <code>lock_table</code> 插入记录，键为“<code>resource_id</code>（数据源标识）+表名+主键”（而非“事务 ID 作为标识”，事务 ID 用于关联全局事务，锁键才是唯一标识）；插入失败时会阻塞并重试（默认重试次数可配置），避免并发写冲突。</li><li><strong>AT 模式的默认隔离级别</strong>：读已提交（Read Committed），但通过“全局锁+本地锁”的协同，可避免“脏写”，并在一定程度上缓解“不可重复读”（需补充隔离级别的实际效果）。</li><li><strong>取消全局事务绑定</strong>：若某服务不想参与全局事务，需在调用下游服务前执行 <code>RootContext.unbind()</code>（解除当前 XID 绑定），下游服务将不会注册分支事务；若后续需重新参与，需再次绑定 XID（修正“调用下游前再重新绑定”的顺序逻辑）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
          <category> 中间件 </category>
          
          <category> Seata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Seata </tag>
            
            <tag> AT模式 </tag>
            
            <tag> XA模式 </tag>
            
            <tag> 分布式事务 </tag>
            
            <tag> 全局事务ID </tag>
            
            <tag> Undo Log </tag>
            
            <tag> 事务协调器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata 分布式事务其他模式学习笔记</title>
      <link href="/2025/09/07/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2025/09/07/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p> </p><p>今天学习了 Seata 分布式事务的其他模式，包括 XA 模式、TCC 模式和 Saga 模式，以下是详细整理：</p><p>一、XA 模式</p><p>核心特点</p><ul><li>连接持有机制：XA 模式会持有数据库连接（如 MySQL 的  Connection  对象）直至两阶段提交完成，在此期间连接无法释放，可能影响数据库连接池性能。</li><li>注解使用：需同时使用  @GlobalTransactional （保证分布式事务的提交&#x2F;回滚）和  @Transactional （保证本地事务正常提交）两个注解。</li><li>两阶段流程：<br>1. 一阶段：各分支事务执行本地业务逻辑，但不提交，仅记录日志并等待全局协调。<br>2. 二阶段：事务协调者（TC）根据全局事务状态，决定所有分支事务执行  commit （提交）或  rollback （回滚）。</li></ul><p>优缺点</p><ul><li>优点：强一致性，依赖数据库原生 XA 协议，无需侵入业务代码。</li><li>缺点：长期持有连接导致性能损耗大，不适合高并发场景，一般不推荐使用。</li></ul><p>二、TCC 模式</p><p>核心概念</p><p>TCC 模式将分布式事务分为三个阶段，需手动实现业务逻辑：</p><p>1. Try：资源检查与预留（如扣减库存前检查库存是否充足，并锁定部分库存）。<br>2. Confirm：确认提交（如实际扣减锁定的库存）。<br>3. Cancel：取消回滚（如释放锁定的库存）。</p><p>注解使用</p><p>需在服务类上配合使用  @LocalTCC  和  @TwoPhaseBusinessAction  注解，明确 Try、Confirm、Cancel 方法的映射关系。</p><p>关键问题及解决方案</p><p>1. 空回滚：</p><ul><li>问题：当某分支事务未执行完成（如远程调用失败），却触发了 Cancel 回滚，导致无实际业务可回滚。</li><li>解决：Seata 通过全局事务 ID（XID）和分支 ID 查询对应记录，判断是否需要执行回滚逻辑。<br>2. 幂等性：</li><li>问题：因网络重试等原因，同一事务可能被多次执行（如重复提交订单）。</li><li>解决：通过状态机控制事务状态（如  Trying （执行中）、 Committed （已提交）、 Rollbacked （已回滚）），避免重复处理。<br>3. 悬挂问题：</li><li>问题：事务执行顺序异常（如二阶段提交先于一阶段完成，导致一阶段失败后无法回滚）。</li><li>解决：新版本 Seata 限制在一阶段业务逻辑未完成前，不允许执行二阶段的  commit  操作。</li></ul><p>优缺点</p><ul><li>优点：灵活性高，不依赖特定数据源，支持非关系型数据库。</li><li>缺点：对业务代码侵入性强，需手动实现三个阶段的逻辑，开发成本高。</li></ul><p>三、Saga 模式</p><p>核心特点</p><ul><li>状态机驱动：通过状态机定义业务流程的执行顺序，以及异常时的补偿逻辑（逆向操作）。</li><li>回滚机制：当某环节失败时，通过状态机触发前置步骤的补偿操作（如订单创建失败，回滚支付、库存扣减等操作）。</li></ul><p>常见实践</p><ul><li>实际应用中，Saga 模式较少直接使用，更多结合 MQ 实现定时补偿：</li><li>业务处理失败时，将补偿任务发送至 MQ，通过重试机制反复执行。</li><li>多次重试失败后，消息进入死信队列，由人工介入处理，保证数据最终一致性。</li></ul><p>适用场景</p><ul><li>适合业务流程长、分支多的场景（如订单履约全流程）。</li><li>适合老系统改造（无需深入了解原有业务细节，通过状态流转控制补偿逻辑）。</li></ul><p>四、模式对比与选择建议</p><p>模式 一致性 性能 业务侵入性 适用场景<br>XA 强一致 差 无 低并发、强一致性要求极高场景<br>AT 最终一致 中 无 关系型数据库、一般微服务场景<br>TCC 最终一致 高 高 新业务、非关系型数据库场景<br>Saga 最终一致 中 低 长事务、老系统改造场景 </p><p>选择建议</p><ul><li>新业务且需灵活控制资源：优先考虑 TCC 模式（需接受业务侵入性）。</li><li>关系型数据库为主、低侵入需求：优先考虑 AT 模式。</li><li>老系统改造或长事务：优先考虑 Saga 模式。</li><li>性能敏感场景：避免使用 XA 模式。</li></ul><p>总结</p><p>Seata 提供的多种分布式事务模式各有优劣，实际使用中需根据业务场景（如一致性要求、并发量、系统新旧程度）选择合适的模式，同时注意解决 TCC 等模式中的空回滚、幂等性、悬挂等问题，确保分布式事务的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Seata </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel 拉模式实现详解</title>
      <link href="/2025/09/04/sentinel%E6%8B%89%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2025/09/04/sentinel%E6%8B%89%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么需要-Sentinel-拉模式？"><a href="#一、为什么需要-Sentinel-拉模式？" class="headerlink" title="一、为什么需要 Sentinel 拉模式？"></a>一、为什么需要 Sentinel 拉模式？</h2><p>Sentinel 默认的内存模式存在明显缺陷：限流规则仅存储在客户端内存中，应用重启后规则全部丢失，无法满足生产环境的规则持久化与统一管理需求。</p><p>拉模式是 Sentinel 规则持久化的核心方案之一，其核心逻辑是客户端主动通过定时轮询，从外部存储（如 MySQL、本地文件）拉取规则，并结合 SPI 扩展机制实现自定义数据源，彻底解决“重启失效”问题。本文将完整拆解拉模式的实现流程，基于 MySQL 存储规则，适配 Spring Boot 场景。</p><h2 id="二、拉模式与-SPI-的关系"><a href="#二、拉模式与-SPI-的关系" class="headerlink" title="二、拉模式与 SPI 的关系"></a>二、拉模式与 SPI 的关系</h2><p>在动手实现前，先理清两个关键概念，避免与推模式混淆：</p><p>概念 作用说明<br>拉模式 客户端通过定时任务主动轮询外部存储（如 MySQL），获取最新规则并加载到 Sentinel，实时性取决于轮询间隔。<br>SPI 扩展机制 Sentinel 提供  ReadableDataSource  接口作为 SPI 扩展点，允许自定义“规则读取逻辑”，框架启动时自动扫描加载。 </p><h2 id="三、完整实现步骤（基于-MySQL-Spring-Boot）"><a href="#三、完整实现步骤（基于-MySQL-Spring-Boot）" class="headerlink" title="三、完整实现步骤（基于 MySQL + Spring Boot）"></a>三、完整实现步骤（基于 MySQL + Spring Boot）</h2><h3 id="1-环境准备：引入依赖"><a href="#1-环境准备：引入依赖" class="headerlink" title="1. 环境准备：引入依赖"></a>1. 环境准备：引入依赖</h3><p>在  pom.xml  中添加 Sentinel 核心依赖、SPI 扩展依赖及 MySQL 连接依赖（使用 Druid 连接池简化操作）：</p><!-- 1. Sentinel 核心依赖 --><dependency>    <groupId>com.alibaba.csp</groupId>    <artifactId>sentinel-core</artifactId>    <version>1.8.6</version></dependency><!-- 2. Sentinel DataSource 扩展（SPI 扩展基础） --><dependency>    <groupId>com.alibaba.csp</groupId>    <artifactId>sentinel-datasource-extension</artifactId>    <version>1.8.6</version></dependency><!-- 3. MySQL 连接依赖 --><dependency>    <groupId>mysql</groupId>    <artifactId>mysql-connector-java</artifactId>    <version>8.0.33</version></dependency><!-- 4. Druid 连接池 --><dependency>    <groupId>com.alibaba</groupId>    <artifactId>druid</artifactId>    <version>1.2.16</version></dependency><!-- 5. Spring Boot 基础（已引入可忽略） --><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter</artifactId>    <version>2.7.15</version></dependency>  <h3 id="2-存储设计：创建-MySQL-规则表"><a href="#2-存储设计：创建-MySQL-规则表" class="headerlink" title="2. 存储设计：创建 MySQL 规则表"></a>2. 存储设计：创建 MySQL 规则表</h3><p>在 MySQL 中创建 Sentinel 限流规则表，用于持久化存储规则配置（支持后续扩展降级、热点规则等）：</p><p>– 数据库：sentinel_db（可自定义）<br>CREATE DATABASE IF NOT EXISTS sentinel_db DEFAULT CHARSET utf8mb4;<br>USE sentinel_db;</p><p>– 限流规则表<br>CREATE TABLE IF NOT EXISTS sentinel_flow_rule (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT COMMENT ‘主键ID’,<br>  <code>resource</code> varchar(255) NOT NULL COMMENT ‘限流资源名（如接口路径 &#x2F;order&#x2F;create）’,<br>  <code>limit_app</code> varchar(64) DEFAULT ‘default’ COMMENT ‘限制来源（默认所有来源）’,<br>  <code>grade</code> tinyint(1) NOT NULL COMMENT ‘限流类型：1&#x3D;QPS，0&#x3D;线程数’,<br>  <code>count</code> double NOT NULL COMMENT ‘限流阈值（如 QPS&#x3D;10）’,<br>  <code>strategy</code> tinyint(1) DEFAULT 0 COMMENT ‘流控策略：0&#x3D;直接模式，1&#x3D;关联模式，2&#x3D;链路模式’,<br>  <code>control_behavior</code> tinyint(1) DEFAULT 0 COMMENT ‘流控效果：0&#x3D;快速失败，1&#x3D;预热，2&#x3D;排队’,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT ‘Sentinel 限流规则表’;</p><p>– 插入测试数据：对 &#x2F;order&#x2F;create 接口限制 QPS&#x3D;10<br>INSERT INTO sentinel_flow_rule (resource, limit_app, grade, count, strategy, control_behavior)<br>VALUES (‘&#x2F;order&#x2F;create’, ‘default’, 1, 10, 0, 0); </p><h3 id="3-核心实现：自定义-SPI-数据源（DataSource）"><a href="#3-核心实现：自定义-SPI-数据源（DataSource）" class="headerlink" title="3. 核心实现：自定义 SPI 数据源（DataSource）"></a>3. 核心实现：自定义 SPI 数据源（DataSource）</h3><p>拉模式的核心是实现  ReadableDataSource  接口（Sentinel 的 SPI 扩展点），在类中封装“定时轮询逻辑”与“MySQL 规则读取逻辑”。</p><h4 id="自定义-DataSource-代码"><a href="#自定义-DataSource-代码" class="headerlink" title="自定义 DataSource 代码"></a>自定义 DataSource 代码</h4><p>package com.example.sentinel.datasource;</p><p>import com.alibaba.csp.sentinel.datasource.ReadableDataSource;<br>import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br>import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br>import com.alibaba.druid.pool.DruidDataSource;</p><p>import java.sql.Connection;<br>import java.sql.PreparedStatement;<br>import java.sql.ResultSet;<br>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.ScheduledExecutorService;<br>import java.util.concurrent.TimeUnit;</p><p>&#x2F;**</p><ul><li><p>Sentinel 拉模式数据源：从 MySQL 定时拉取限流规则</p></li><li><p>实现 ReadableDataSource 接口，通过 SPI 被 Sentinel 自动加载<br> *&#x2F;<br>public class MysqlPullFlowRuleDataSource implements ReadableDataSource&lt;Void, List<FlowRule>&gt; {</p><p> &#x2F;&#x2F; 1. 配置参数（生产环境建议从配置文件注入，此处简化为硬编码）<br> private final String jdbcUrl &#x3D; “jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;sentinel_db?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC”;<br> private final String dbUsername &#x3D; “root”; &#x2F;&#x2F; 替换为你的 MySQL 账号<br> private final String dbPassword &#x3D; “123456”; &#x2F;&#x2F; 替换为你的 MySQL 密码<br> private final long pullInterval &#x3D; 5000; &#x2F;&#x2F; 定时轮询间隔：5秒（可根据需求调整）</p><p> &#x2F;&#x2F; 2. 数据库连接池（复用连接，避免频繁创建销毁）<br> private final DruidDataSource druidDataSource;<br> &#x2F;&#x2F; 3. 定时任务线程池（执行规则拉取任务）<br> private final ScheduledExecutorService scheduler;</p><p> &#x2F;**</p><ul><li>构造方法：初始化连接池 + 启动定时轮询<br>  *&#x2F;<br> public MysqlPullFlowRuleDataSource() {<br> &#x2F;&#x2F; 初始化 Druid 连接池<br> this.druidDataSource &#x3D; initDruidDataSource();<br> &#x2F;&#x2F; 初始化定时任务：项目启动立即拉取一次，之后每 5 秒拉取<br> this.scheduler &#x3D; Executors.newSingleThreadScheduledExecutor();<br> this.scheduler.scheduleAtFixedRate(<br>     this::loadRuleToSentinel, &#x2F;&#x2F; 轮询执行的方法：拉取并加载规则<br>     0, &#x2F;&#x2F; 初始延迟：0秒（立即执行）<br>     pullInterval, &#x2F;&#x2F; 轮询间隔<br>     TimeUnit.MILLISECONDS<br> );<br> }</li></ul><p> &#x2F;**</p><ul><li><p>核心1：从 MySQL 读取最新规则<br>  *&#x2F;<br> private List<FlowRule> readRuleFromMysql() {<br> List<FlowRule> flowRules &#x3D; new ArrayList&lt;&gt;();<br> String sql &#x3D; “SELECT resource, limit_app, grade, count, strategy, control_behavior FROM sentinel_flow_rule”;</p><p> &#x2F;&#x2F; try-with-resources 自动关闭连接、Statement<br> try (Connection conn &#x3D; druidDataSource.getConnection();<br>  PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);<br>  ResultSet rs &#x3D; pstmt.executeQuery()) {<br><br> &#x2F;&#x2F; 遍历结果集，转换为 Sentinel 识别的 FlowRule 对象<br> while (rs.next()) {<br>     FlowRule rule &#x3D; new FlowRule();<br>     rule.setResource(rs.getString(“resource”));       &#x2F;&#x2F; 限流资源（接口&#x2F;方法名）<br>     rule.setLimitApp(rs.getString(“limit_app”));     &#x2F;&#x2F; 限制来源<br>     rule.setGrade(rs.getInt(“grade”));               &#x2F;&#x2F; 限流类型（QPS&#x2F;线程数）<br>     rule.setCount(rs.getDouble(“count”));            &#x2F;&#x2F; 限流阈值<br>     rule.setStrategy(rs.getInt(“strategy”));         &#x2F;&#x2F; 流控策略<br>     rule.setControlBehavior(rs.getInt(“control_behavior”)); &#x2F;&#x2F; 流控效果<br>     flowRules.add(rule);<br> }<br> } catch (Exception e) {<br> throw new RuntimeException(“从 MySQL 拉取 Sentinel 规则失败”, e);<br> }<br> return flowRules;</p></li></ul><p> }</p><p> &#x2F;**</p><ul><li>核心2：将 MySQL 中的规则加载到 Sentinel 核心<br>  *&#x2F;<br> private void loadRuleToSentinel() {<br> List<FlowRule> rules &#x3D; readRuleFromMysql();<br> FlowRuleManager.loadRules(rules); &#x2F;&#x2F; 覆盖 Sentinel 本地规则<br> System.out.printf(“[Sentinel 拉模式] 规则加载完成：共 %d 条规则%n”, rules.size());<br> }</li></ul><p> &#x2F;**</p><ul><li>初始化 Druid 连接池（配置基础参数，生产环境需优化）<br>  *&#x2F;<br> private DruidDataSource initDruidDataSource() {<br> DruidDataSource dataSource &#x3D; new DruidDataSource();<br> dataSource.setUrl(jdbcUrl);<br> dataSource.setUsername(dbUsername);<br> dataSource.setPassword(dbPassword);<br> dataSource.setInitialSize(5); &#x2F;&#x2F; 初始连接数<br> dataSource.setMaxActive(20);  &#x2F;&#x2F; 最大连接数<br> dataSource.setMinIdle(3);     &#x2F;&#x2F; 最小空闲连接数<br> return dataSource;<br> }</li></ul><p> &#x2F;&#x2F; ——————- 实现 ReadableDataSource 接口（SPI 强制要求） ——————-<br> @Override<br> public List<FlowRule> readSource() throws Exception {<br>     &#x2F;&#x2F; SPI 机制会调用此方法获取最新规则，直接复用 MySQL 读取逻辑<br>     return readRuleFromMysql();<br> }</p><p> @Override<br> public void close() throws Exception {<br>     &#x2F;&#x2F; 资源销毁：关闭连接池 + 停止定时任务<br>     if (druidDataSource !&#x3D; null) {<br>         druidDataSource.close();<br>     }<br>     if (scheduler !&#x3D; null &amp;&amp; !scheduler.isShutdown()) {<br>         scheduler.shutdown();<br>     }<br> }</p></li></ul><p>} </p><h3 id="4-SPI-注册：让-Sentinel-识别自定义数据源"><a href="#4-SPI-注册：让-Sentinel-识别自定义数据源" class="headerlink" title="4. SPI 注册：让 Sentinel 识别自定义数据源"></a>4. SPI 注册：让 Sentinel 识别自定义数据源</h3><p>Sentinel 启动时会扫描  META-INF&#x2F;services  目录下的 SPI 配置文件，自动加载  ReadableDataSource  的实现类。需手动创建配置文件：</p><p>1. 创建 SPI 配置文件路径：在项目的  src&#x2F;main&#x2F;resources  目录下，新建路径  META-INF&#x2F;services 。<br>2. 创建 SPI 配置文件：在上述路径下创建文件，文件名必须为  com.alibaba.csp.sentinel.datasource.ReadableDataSource （即  ReadableDataSource  接口的全路径）。<br>3. 写入自定义 DataSource 全类名：在配置文件中添加自定义 DataSource 的完整包名+类名（确保 Sentinel 能扫描到）：</p><p>com.example.sentinel.datasource.MysqlPullFlowRuleDataSource </p><h3 id="5-Spring-Boot-集成：初始化数据源"><a href="#5-Spring-Boot-集成：初始化数据源" class="headerlink" title="5. Spring Boot 集成：初始化数据源"></a>5. Spring Boot 集成：初始化数据源</h3><p>将自定义 DataSource 注册为 Spring Bean，确保项目启动时自动执行构造方法（初始化连接池与定时任务）：</p><p>package com.example.sentinel.config;</p><p>import com.example.sentinel.datasource.MysqlPullFlowRuleDataSource;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;</p><p>@Configuration<br>public class SentinelPullConfig {</p><pre><code>/** * 注册拉模式数据源为 Spring Bean * - initMethod：启动时执行规则加载 * - destroyMethod：关闭时销毁资源（连接池、定时任务） */@Bean(initMethod = &quot;loadRuleToSentinel&quot;, destroyMethod = &quot;close&quot;)public MysqlPullFlowRuleDataSource mysqlPullFlowRuleDataSource() &#123;    return new MysqlPullFlowRuleDataSource();&#125;</code></pre><p>} </p><h3 id="6-验证：拉模式是否生效"><a href="#6-验证：拉模式是否生效" class="headerlink" title="6. 验证：拉模式是否生效"></a>6. 验证：拉模式是否生效</h3><p>1. 启动 Spring Boot 项目：控制台会打印  [Sentinel 拉模式] 规则加载完成：共 1 条规则 ，说明定时任务已启动，首次拉取规则成功。<br>2. 修改 MySQL 规则：执行 SQL 语句修改阈值（如将 QPS 从 10 改为 5）：<br>UPDATE sentinel_flow_rule SET count &#x3D; 5 WHERE resource &#x3D; ‘&#x2F;order&#x2F;create’;<br> <br>3. 等待轮询间隔：5 秒后，控制台会再次打印规则加载日志，说明规则已自动更新。<br>4. 测试接口限流：用 Postman 或 JMeter 压测  &#x2F;order&#x2F;create  接口，当 QPS 超过 5 时，接口会返回 Sentinel 限流提示（如  Blocked by Sentinel (flow limiting) ），验证规则生效。</p><h2 id="四、拉模式的优势与注意事项"><a href="#四、拉模式的优势与注意事项" class="headerlink" title="四、拉模式的优势与注意事项"></a>四、拉模式的优势与注意事项</h2><p>优势</p><ul><li>规则持久化：规则存储在 MySQL 中，应用重启后自动拉取，解决默认内存模式的痛点。</li><li>实现成本低：无需依赖配置中心（如 Nacos、ZooKeeper），仅需定时轮询，适合中小项目。</li><li>扩展灵活：可替换存储介质（如本地文件、Redis），只需修改  readRuleFromMysql()  中的读取逻辑。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>实时性平衡：轮询间隔越小，实时性越高，但会增加数据库压力（建议设置 3-10 秒）。</li><li>避免重复加载：确保 DataSource 仅初始化一次（如 Spring Bean 单例），避免多定时任务冲突。</li><li>生产环境优化：</li><li>数据库连接池参数需根据并发量调整（如最大连接数、超时时间）。</li><li>增加规则缓存，减少数据库查询次数。</li><li>对 SQL 执行异常添加重试机制。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Sentinel 拉模式的核心是“SPI 扩展自定义 DataSource + 客户端定时轮询”：</p><p>1. 通过 SPI 机制让 Sentinel 加载自定义的“MySQL 规则读取逻辑”；<br>2. 通过定时任务主动拉取规则并注入 Sentinel 核心；<br>3. 最终实现规则的持久化与自动更新，解决默认内存模式的缺陷。</p><p>拉模式适合对规则实时性要求不高、不想依赖配置中心的场景，是中小项目实现 Sentinel 规则持久化的优选方案。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> 流量控制 </tag>
            
            <tag> 拉模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel源码学习笔记</title>
      <link href="/2025/09/02/Sentinel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/09/02/Sentinel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel源码学习笔记"><a href="#Sentinel源码学习笔记" class="headerlink" title="Sentinel源码学习笔记"></a>Sentinel源码学习笔记</h1><p>一、客户端与服务端的交互流程</p><p>1. 连接建立：客户端启动时通过配置的服务端地址（如  spring.cloud.sentinel.transport.dashboard.server ）与Sentinel Dashboard建立长连接（HTTP长轮询或WebSocket），定期发送心跳包保持连接。<br>2. 数据同步：</p><ul><li>客户端将实时统计的监控数据（QPS、异常数等）通过长连接上报给服务端，服务端在控制台展示实时监控图表。</li><li>服务端通过长连接向客户端推送规则配置（流控、熔断等），客户端接收后更新本地规则缓存并生效。<br>3. 指令交互：服务端可通过控制台手动触发客户端规则更新、熔断状态重置等指令，客户端接收后执行对应操作并返回结果。</li></ul><p>二、自动配置类（以Spring Cloud整合为例）的核心逻辑</p><p> SentinelAutoConfiguration  是核心自动配置类，主要执行以下操作：</p><p>1. 初始化核心组件：注册  SentinelResourceAspect  切面，通过AOP拦截被  @SentinelResource  注解标记的资源（方法&#x2F;接口），触发责任链执行。<br>2. 规则加载：通过  DataSource  加载预设规则（如Nacos、Apollo配置的流控&#x2F;熔断规则），初始化到  RuleManager  中。<br>3. 适配Spring生态：注册  SentinelWebInterceptor  拦截HTTP请求，将URL自动作为资源进行监控；适配Feign、Dubbo等组件，自动拦截远程调用作为资源。<br>4. 异常处理：注册  SentinelExceptionHandler ，统一处理流控、熔断等异常（如  BlockException ），返回自定义响应。</p><p>三、责任链（ProcessorSlotChain）的构建与核心插槽</p><ol><li>构建流程</li></ol><ul><li>客户端初始化时， SlotChainProvider  会通过SPI机制加载默认插槽链，并允许通过  SlotChainBuilder  自定义扩展。</li><li>默认链顺序（按优先级执行）： NodeSelectorSlot  →  ClusterBuilderSlot  →  LogSlot  →  StatisticSlot  →  AuthoritySlot  →  FlowSlot  →  DegradeSlot  →  SystemSlot （顺序固定）。</li></ul><ol start="2"><li>关键插槽工作原理</li></ol><ul><li>StatisticSlot（统计插槽）：责任链核心，负责收集资源实时指标（QPS、响应时间、异常数等），为后续插槽提供数据支持；通过  ArrayMetric  维护滑动窗口统计，记录每个时间窗口的请求数、成功数等。</li><li>FlowSlot（流控插槽）：使用  StatisticSlot  提供的QPS&#x2F;线程数数据，与预设流控规则对比，超过阈值则抛出  FlowException  拦截请求。</li><li>DegradeSlot（熔断插槽）：通过  StatisticSlot  获取异常比例&#x2F;数、响应时间等数据，判断是否触发熔断（OPEN状态），拦截请求并抛出  DegradeException 。</li><li>NodeSelectorSlot：为资源创建唯一统计节点（ DefaultNode ），用于区分不同上下文的资源调用（如不同服务调用同一接口）。</li></ul><p>四、断路器（熔断）实现逻辑</p><ol><li>状态机设计</li></ol><ul><li>CLOSED：正常允许请求， DegradeSlot  实时统计异常比例&#x2F;数、响应时间。</li><li>OPEN：触发熔断（如异常比例超阈值），拦截所有请求；持续  waitTimeout  时间后转为 HALF_OPEN。</li><li>HALF_OPEN：允许少量请求通过，请求成功则转为 CLOSED，失败则重回 OPEN。</li></ul><ol start="2"><li>判断逻辑</li></ol><ul><li>基于异常比例： （异常数 &#x2F; 总请求数）&gt; 阈值  且 总请求数≥最小请求数。</li><li>基于响应时间：慢调用比例（响应时间&gt;阈值的请求数&#x2F;总请求数）&gt; 阈值。</li></ul><p>五、限流实现逻辑</p><p>1.  FlowSlot  在责任链中检查  StatisticSlot  统计的实时QPS&#x2F;线程数，若超过预设规则阈值，直接抛出  FlowException  拦截请求。</p><p>六、Fallback（降级）逻辑</p><p>1. 触发场景：当资源被限流（ FlowException ）、熔断（ DegradeException ）或抛出业务异常时，执行预设的fallback逻辑。<br>2. 实现方式：</p><ul><li>注解指定： @SentinelResource(fallback &#x3D; “xxx”) ，方法  xxx  需与原方法参数一致，可接收异常参数。</li><li>全局配置：通过  GlobalFallback  定义全局fallback，统一处理未指定局部fallback的资源。<br>3. 执行流程： SentinelResourceAspect  拦截到  BlockException  或业务异常后，通过反射调用fallback方法，返回降级结果。</li></ul><p>七、降级逻辑（与熔断的区别）</p><ul><li>熔断（Degrade）：服务端主动触发的保护机制（如异常率过高），属于“被动降级”，状态随指标自动切换（CLOSED→OPEN→HALF_OPEN→CLOSED）。</li><li>限流（Flow）：主动限制请求量以防止资源耗尽，属于“主动降级”，触发条件是实时请求量超阈值。</li><li>共性：两者最终均通过抛出异常被fallback逻辑捕获，返回降级响应，避免服务雪崩。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件学习 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel 控制台用法与工作原理学习笔记</title>
      <link href="/2025/09/01/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%94%A8%E6%B3%95%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/09/01/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%94%A8%E6%B3%95%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel-控制台用法与工作原理学习笔记"><a href="#Sentinel-控制台用法与工作原理学习笔记" class="headerlink" title="Sentinel 控制台用法与工作原理学习笔记"></a>Sentinel 控制台用法与工作原理学习笔记</h1><h2 id="一、流控规则配置"><a href="#一、流控规则配置" class="headerlink" title="一、流控规则配置"></a>一、流控规则配置</h2><ol><li><strong>基础控制维度</strong>：支持对 QPS（每秒查询率）和并发线程数进行控制。</li><li><strong>三种流控模式</strong>：<ul><li>直接关系：直接针对接口配置流量规则，可设置 QPS 或并发线程数阈值，当触发阈值时直接对该接口进行限流。</li><li>关联关系：适用于存在关联的服务，例如调用 A 服务的请求过多时，可配置当 A 服务的 QPS 或并发线程数达到阈值后，对关联的 B 服务进行流量控制，避免因 A 服务过载影响 B 服务。</li><li>链路关系：针对具有调用关系的链路进行配置，可对链路上的特定节点或多个节点限流，进而控制整个链路的流量。需注意：1.7 版本后，链路控制功能需在配置文件中设置 <code>WebContextUtile</code> 参数为 <code>false</code> 才能生效。</li></ul></li><li><strong>三种流控类型</strong>：<ul><li>快速失败：当接口请求超过设定阈值（QPS 或并发线程数）时，直接返回失败结果。</li><li>接口预热：服务启动时，通过模拟线程加载缓存等资源，避免刚启动就被大量流量击垮，逐渐提升接口处理能力至阈值。</li><li>排队等待：可设置超时时间，请求会进入队列等待处理。若超时则被剔除并返回失败；未超时则正常响应。例如，阈值设为 20 时，每秒处理 20 个请求，超出部分进入队列等待。</li></ul></li></ol><h2 id="二、熔断降级配置"><a href="#二、熔断降级配置" class="headerlink" title="二、熔断降级配置"></a>二、熔断降级配置</h2><p>基于三种情况设置阈值，触发后进入熔断状态，熔断时间结束后恢复正常：</p><ol><li>慢调用比例：当慢调用（如慢查询接口）占比超过配置阈值时，触发熔断。</li><li>异常比例：接口异常请求占比超过阈值时，触发熔断。</li><li>异常数：接口异常请求数量达到阈值时，触发熔断。</li></ol><h2 id="三、热点限流"><a href="#三、热点限流" class="headerlink" title="三、热点限流"></a>三、热点限流</h2><p>针对接口的热点参数（仅支持 Java 7 种基本数据类型）进行 QPS 配置。例如，查询用户 ID 为 1 的数据是热点，可设置当该参数的 QPS 达到阈值时进行限流。</p><h2 id="四、系统规则限流"><a href="#四、系统规则限流" class="headerlink" title="四、系统规则限流"></a>四、系统规则限流</h2><p>从系统整体层面限制流量，包含五种模式：</p><ol><li>Load：仅对 Linux&#x2F;Unix 机器生效，根据系统负载进行限流。</li><li>RT（响应时间）：当系统整体响应时间超过阈值时，触发限流。</li><li>线程数：限制系统最大支持的并发线程数，超过则限流。</li><li>入口 QPS：限制单位时间内整体进入系统的 QPS，超过则限流。</li><li>CPU 使用率：当 CPU 使用率超过阈值时，触发限流。</li></ol><h2 id="五、授权规则限流"><a href="#五、授权规则限流" class="headerlink" title="五、授权规则限流"></a>五、授权规则限流</h2><p>支持通过黑白名单实现微服务间的调用控制：</p><ul><li>需手动实现 <code>RequestOriginParser</code> 接口，并将其注册为 Spring 管理的 Bean，用于解析请求来源。</li><li>根据解析的来源，结合黑白名单规则，允许或限制微服务间的调用。</li></ul><h2 id="六、集群流控"><a href="#六、集群流控" class="headerlink" title="六、集群流控"></a>六、集群流控</h2><ol><li>基础配置：在流控规则中可选择是否为集群模式，支持单机均摊或整体阈值设置。</li><li>差异化配置：通过 <code>Token Server</code> 和 <code>Token Client</code> 实现，可针对不同机器（如配置高低）设置差异化 QPS 阈值，配置高的机器可适当提高 QPS，配置低的则降低。</li></ol><h2 id="七、工作原理"><a href="#七、工作原理" class="headerlink" title="七、工作原理"></a>七、工作原理</h2><ol><li><strong>核心抽象</strong>：将流量规则控制、集群节点聚簇等功能抽象为一个个 <code>Slot</code>（插槽）。</li><li><strong>责任链模式</strong>：所有插槽构成一条责任链，请求需依次经过链路上的各个插槽检查。</li><li><strong>执行流程</strong>：<ul><li>外部请求进入后，先进行统计簇点构建和监控统计。</li><li>依次经过热点参数限流、系统保护限流、来源访问控制限流、流量控制、熔断降级等插槽的检查。</li><li>若链路上任何一个插槽的限流规则未通过，返回快速失败结果；全部通过则执行接口逻辑。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 中间件学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> 流量控制 </tag>
            
            <tag> 熔断降级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel 学习笔记</title>
      <link href="/2025/08/31/Sentinel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/31/Sentinel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Sentinel-基础概念与服务雪崩背景"><a href="#一、Sentinel-基础概念与服务雪崩背景" class="headerlink" title="一、Sentinel 基础概念与服务雪崩背景"></a>一、Sentinel 基础概念与服务雪崩背景</h2><h3 id="（一）服务雪崩现象剖析"><a href="#（一）服务雪崩现象剖析" class="headerlink" title="（一）服务雪崩现象剖析"></a>（一）服务雪崩现象剖析</h3><p>服务雪崩是微服务架构中的严重问题：当某服务因高并发不堪重负，其依赖链上的其他服务会受波及，影响层层传递，最终导致大量服务瘫痪。</p><p>服务不可用的核心原因包括：</p><ol><li>程序 Bug：隐藏错误在特定场景（输入、环境、业务）下触发，导致服务异常。</li><li>高并发冲击：突发请求远超服务器承载能力，资源被耗尽，无法及时处理请求。</li><li>硬件故障：服务器硬件老化、损坏等物理问题，直接导致服务停运。</li><li>缓存击穿：热点数据缓存过期瞬间，大量请求穿透缓存直达后端，造成服务压力激增。</li></ol><h3 id="（二）服务雪崩解决方案概述"><a href="#（二）服务雪崩解决方案概述" class="headerlink" title="（二）服务雪崩解决方案概述"></a>（二）服务雪崩解决方案概述</h3><p>应对服务雪崩的常见方案有四类：</p><ol><li>超时机制：为服务调用设超时时间，超时未响应则返回默认结果（如 false），避免调用方长时间等待。</li><li>服务限流：限制单位时间内通过的请求数，拦截超额流量并返回“服务繁忙”提示，保护服务不被压垮。</li><li>资源隔离：划分独立资源池（线程池、数据库连接等）给不同服务&#x2F;模块，某资源池耗尽不影响其他服务。</li><li>熔断降级：若被调用服务频繁错误或崩溃，直接返回默认结果，防止影响在服务链蔓延。</li></ol><h3 id="（三）微服务流量治理技术选型对比"><a href="#（三）微服务流量治理技术选型对比" class="headerlink" title="（三）微服务流量治理技术选型对比"></a>（三）微服务流量治理技术选型对比</h3><p>微服务流量治理中，Hystrix 与 Sentinel 是主流选择，核心差异如下：</p><ol><li>Hystrix：核心聚焦“隔断+资源隔离+熔断”，提供 fallback 机制，服务异常时执行备用逻辑，保障基础可用性。</li><li>Sentinel：功能更全面，除流量控制、熔断降级外，还支持系统负载保护、实时监控，且有控制台支持规则动态调整，灵活性更强。</li></ol><h2 id="二、Sentinel-核心概念与使用方式"><a href="#二、Sentinel-核心概念与使用方式" class="headerlink" title="二、Sentinel 核心概念与使用方式"></a>二、Sentinel 核心概念与使用方式</h2><h3 id="（一）Sentinel-核心概念详解"><a href="#（一）Sentinel-核心概念详解" class="headerlink" title="（一）Sentinel 核心概念详解"></a>（一）Sentinel 核心概念详解</h3><ol><li>资源：经 Sentinel AOP 增强的代码接口（如微服务业务方法），是 Sentinel 监控和控制的核心对象。</li><li>规则：围绕资源设定的控制策略，用于实现限流、降级等功能，支持在控制台实时动态调整，适配业务和系统变化。</li></ol><h3 id="（二）Sentinel-使用方式对比"><a href="#（二）Sentinel-使用方式对比" class="headerlink" title="（二）Sentinel 使用方式对比"></a>（二）Sentinel 使用方式对比</h3><ol><li>原生使用：需引入多依赖，通过代码手动定义资源、规则，并在 post constructor 注入。弊端是业务代码与 Sentinel 配置耦合，可维护性差。</li><li>灵活使用：微服务推荐方式，引入切面依赖后，通过配置函数、配置类或 YAML 文件配置，实现业务代码与配置逻辑分离，结构清晰易维护。</li></ol><h2 id="三、Sentinel-在微服务中的具体应用"><a href="#三、Sentinel-在微服务中的具体应用" class="headerlink" title="三、Sentinel 在微服务中的具体应用"></a>三、Sentinel 在微服务中的具体应用</h2><h3 id="（一）常用处理机制"><a href="#（一）常用处理机制" class="headerlink" title="（一）常用处理机制"></a>（一）常用处理机制</h3><ol><li>block 流控异常处理：触发流控规则时，通过自定义逻辑返回友好提示（如“当前请求受限，请稍后重试”），提升用户体验。</li><li>fallback 熔断降级函数：服务熔断时自动调用，返回备用结果，确保系统在部分服务不可用的情况下仍能提供基础功能。</li></ol><h3 id="（二）与-Sentinel-控制台交互"><a href="#（二）与-Sentinel-控制台交互" class="headerlink" title="（二）与 Sentinel 控制台交互"></a>（二）与 Sentinel 控制台交互</h3><ol><li>注册流程：微服务 API 被调用时，Sentinel 读取 IP、端口等配置，在 HandlerInterceptor 预处理阶段，将客户端请求信息注册到 Sentinel Dashboard。</li><li>提示优化：默认提示为 Sentinel 配置信息，可通过实现 block interceptor handler 或熔断 interceptor handler，自定义提示内容，适配业务需求。</li></ol><h3 id="（三）使用过程中的坑点及解决办法"><a href="#（三）使用过程中的坑点及解决办法" class="headerlink" title="（三）使用过程中的坑点及解决办法"></a>（三）使用过程中的坑点及解决办法</h3><p><strong>核心坑点</strong>：服务重启后，控制台手动配置的规则会丢失，导致流量控制&#x2F;熔断策略失效。<br><strong>解决方案</strong>：规则持久化，如结合 Nacos 配置中心，将规则存储在 Nacos，服务启动时从 Nacos 加载规则，避免规则丢失。</p><h3 id="（四）微服务调用控制维度"><a href="#（四）微服务调用控制维度" class="headerlink" title="（四）微服务调用控制维度"></a>（四）微服务调用控制维度</h3><p>Sentinel 支持从两个维度对微服务调用进行熔断&#x2F;限流：</p><ol><li>微服务整体维度：针对整个服务（如“order”服务）设规则，例：限制单位时间内“order”服务的总请求数，或错误率达阈值时熔断。</li><li>接口维度：针对服务下的具体接口（如“order”服务的下单接口）设独立规则，例：给下单接口设更高限流阈值，保障核心业务稳定性。</li></ol><h3 id="（五）与-Spring-Cloud-的整合要点及-YAML-配置示例"><a href="#（五）与-Spring-Cloud-的整合要点及-YAML-配置示例" class="headerlink" title="（五）与 Spring Cloud 的整合要点及 YAML 配置示例"></a>（五）与 Spring Cloud 的整合要点及 YAML 配置示例</h3><h4 id="1-OpenFeign-支持"><a href="#1-OpenFeign-支持" class="headerlink" title="1. OpenFeign 支持"></a>1. OpenFeign 支持</h4><p>需在 <code>application.yml</code> 中开启 OpenFeign 支持，并配置 fallback factory：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启 Sentinel 对 OpenFeign 的支持</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">fallbackFactory:</span> <span class="string">com.example.CustomFeignFallbackFactory</span> <span class="comment"># 配置自定义 fallback factory 类</span></span><br></pre></td></tr></table></figure><h4 id="2-流控规则持久化"><a href="#2-流控规则持久化" class="headerlink" title="2. 流控规则持久化"></a>2. 流控规则持久化</h4><p>引入 Nacos 数据源依赖（Maven），并在 <code>application.yml</code> 配置 Nacos 数据源：</p><ul><li>依赖引入：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>YAML 配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span> <span class="comment"># 流控规则数据源</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos 服务器地址</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-sentinel-flow</span> <span class="comment"># 规则数据 ID（结合服务名命名）</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span> <span class="comment"># 数据格式</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment"># 规则类型（流控）</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> 微服务治理 </tag>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Nacos Config 配置中心源码学习</title>
      <link href="/2025/08/30/Spring-Cloud-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/08/30/Spring-Cloud-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言：Nacos-Config-的核心定位"><a href="#一、引言：Nacos-Config-的核心定位" class="headerlink" title="一、引言：Nacos Config 的核心定位"></a>一、引言：Nacos Config 的核心定位</h2><p>在 Spring Cloud 微服务架构中，配置管理是保障服务弹性与可维护性的关键环节。Nacos Config 作为官方推荐的配置中心，不仅实现了配置的集中存储与动态推送，还通过<strong>SPI 机制适配 Spring Boot 自动配置</strong>，解决了传统本地配置“修改需重启”“环境配置混乱”等问题。</p><p>本文基于源码视角，从<strong>配置加载优先级</strong>、<strong>事件驱动的变更流程</strong>两大核心维度展开，同时补充一致性保障、多环境管理、安全加密等生产级关键特性，形成完整的 Nacos Config 知识体系。</p><h2 id="二、配置文件加载逻辑与优先级排序"><a href="#二、配置文件加载逻辑与优先级排序" class="headerlink" title="二、配置文件加载逻辑与优先级排序"></a>二、配置文件加载逻辑与优先级排序</h2><p>Nacos Config 本质是 Spring Boot 自动配置的扩展，其配置加载依赖 <strong>Bootstrap 上下文</strong>与 <strong>Spring 环境（Environment）</strong> 的初始化顺序，最终形成明确的优先级规则（优先级从高到低）：</p><table><thead><tr><th>优先级排序</th><th>配置文件类型</th><th>核心作用与场景</th></tr></thead><tbody><tr><td>1（最高）</td><td>服务名-环境名.yaml</td><td>如 <code>order-service-dev.yaml</code>，针对<strong>特定服务+特定环境</strong>的精准配置（如开发环境的数据库地址），优先级最高，覆盖所有其他配置。</td></tr><tr><td>2</td><td>服务名.yaml</td><td>如 <code>order-service.yaml</code>，该服务的<strong>通用基础配置</strong>（如服务端口、注册中心地址），无环境配置时作为默认值。</td></tr><tr><td>3</td><td>共享配置（shared-configs）</td><td>多服务共享的通用配置（如日志输出格式、公共 API 密钥），通过 Nacos 控制台配置“共享数据集”，避免重复配置。</td></tr><tr><td>4</td><td>本地 application.yaml&#x2F;props</td><td>应用级通用配置（如 Spring 全局参数），优先级低于 Nacos 远程配置，仅在远程配置缺失时生效。</td></tr><tr><td>5（最低）</td><td>本地 bootstrap.yaml&#x2F;props</td><td>启动级基础配置（如 Nacos Server 地址 <code>spring.cloud.nacos.config.server-addr</code>），仅用于初始化 Nacos 连接，不参与业务配置。</td></tr></tbody></table><h3 id="关键源码关联"><a href="#关键源码关联" class="headerlink" title="关键源码关联"></a>关键源码关联</h3><ul><li><strong>Bootstrap 上下文初始化</strong>：通过 <code>BootstrapApplicationListener</code> 触发，优先加载 <code>bootstrap.yaml</code>，确保 Nacos 地址等启动配置先于业务配置加载。</li><li><strong>配置优先级注入</strong>：<code>NacosConfigEnvironmentProcessor</code> 实现 <code>EnvironmentPostProcessor</code> 接口，将 Nacos 远程配置（按上述优先级）注入 Spring 环境，覆盖本地配置。</li></ul><h2 id="三、事件驱动模型：配置变更的全链路处理"><a href="#三、事件驱动模型：配置变更的全链路处理" class="headerlink" title="三、事件驱动模型：配置变更的全链路处理"></a>三、事件驱动模型：配置变更的全链路处理</h2><p>Nacos Config 的动态配置能力依赖<strong>事件驱动模型</strong>，核心是“变更触发→事件发布→监听器处理→客户端同步”的闭环流程，具体分为服务端与客户端两部分：</p><h3 id="3-1-服务端：配置变更的触发与持久化"><a href="#3-1-服务端：配置变更的触发与持久化" class="headerlink" title="3.1 服务端：配置变更的触发与持久化"></a>3.1 服务端：配置变更的触发与持久化</h3><p>当通过 Nacos 控制台&#x2F;API 修改配置后，服务端执行以下步骤：</p><ol><li><p><strong>配置校验与持久化</strong></p><ul><li>先将变更后的配置写入<strong>本地磁盘</strong>（路径：<code>nacos/data/config-data</code>），确保单机故障时配置不丢失；</li><li>同步写入 <strong>MySQL 数据库</strong>（表 <code>config_info</code>），通过数据库实现多节点（集群）间的配置一致性（Nacos 集群默认基于 MySQL 实现数据同步）。</li></ul></li><li><p><strong>事件发布与任务调度</strong></p><ul><li>持久化完成后，发布 <code>ConfigDataChangedEvent</code> 事件，触发内部监听器（如 <code>ConfigChangeNotifier</code>）；</li><li>监听器向客户端发送<strong>定时拉取任务</strong>（默认客户端每 30 秒拉取一次，可通过 <code>spring.cloud.nacos.config.refreshInterval</code> 调整），或通过 <strong>UDP 推送</strong>（需开启 <code>nacos.config.push.enabled=true</code>）主动通知客户端。</li></ul></li></ol><h3 id="3-2-客户端：配置变更的接收与应用"><a href="#3-2-客户端：配置变更的接收与应用" class="headerlink" title="3.2 客户端：配置变更的接收与应用"></a>3.2 客户端：配置变更的接收与应用</h3><p>客户端（微服务）通过 <code>NacosConfigManager</code> 与服务端交互，核心是<strong>阻塞队列+循环拉取</strong>的任务处理机制：</p><ol><li><strong>任务队列初始化</strong>：客户端启动时创建 <code>BlockingQueue</code>，用于存储服务端下发的“配置拉取任务”。</li><li><strong>任务消费逻辑</strong>：通过 <code>ConfigPullTaskRunner</code> 线程，以 <code>while(true)</code> 循环从队列中获取任务，避免线程频繁创建销毁。</li><li><strong>配置对比与更新</strong>：<ul><li>拉取服务端最新配置后，与本地缓存（内存+本地文件 <code>nacos/config</code>）对比；</li><li>若配置有变更，发布 <code>EnvironmentChangeEvent</code> 事件，触发 <code>@RefreshScope</code> 注解的 Bean 重新初始化，实现“零重启更新配置”。</li></ul></li></ol><h3 id="关键源码关联-1"><a href="#关键源码关联-1" class="headerlink" title="关键源码关联"></a>关键源码关联</h3><ul><li><strong>服务端事件机制</strong>：<code>EventDispatcher</code> 作为事件调度核心，管理 <code>ConfigDataChangedEvent</code> 等事件的监听器注册与触发。</li><li><strong>客户端缓存与刷新</strong>：<code>NacosConfigService</code> 负责缓存管理，<code>RefreshEventListener</code> 监听配置变更事件，触发 Bean 刷新。</li></ul><h2 id="四、生产级关键特性补充"><a href="#四、生产级关键特性补充" class="headerlink" title="四、生产级关键特性补充"></a>四、生产级关键特性补充</h2><h3 id="4-1-配置动态更新的一致性保障"><a href="#4-1-配置动态更新的一致性保障" class="headerlink" title="4.1 配置动态更新的一致性保障"></a>4.1 配置动态更新的一致性保障</h3><p>Nacos 通过“三重机制”确保服务端与客户端配置一致：</p><ul><li><strong>版本号校验</strong>：每个配置有唯一 <code>dataId</code> 和 <code>version</code>，客户端拉取时对比版本号，仅更新版本不同的配置；</li><li><strong>本地缓存兜底</strong>：客户端将远程配置缓存到本地文件，网络中断时优先使用缓存配置，避免服务不可用；</li><li><strong>集群数据同步</strong>：Nacos 集群通过 MySQL 主从同步或 Raft 协议（1.4.0+ 支持），确保多节点配置一致。</li></ul><h3 id="4-2-多环境与多版本管理"><a href="#4-2-多环境与多版本管理" class="headerlink" title="4.2 多环境与多版本管理"></a>4.2 多环境与多版本管理</h3><ul><li><strong>多环境隔离</strong>：通过 <code>namespace</code>（命名空间）区分环境（如 <code>dev</code>&#x2F;<code>test</code>&#x2F;<code>prod</code>），每个命名空间下的配置完全隔离，避免环境混淆；</li><li><strong>多版本回溯</strong>：Nacos 保留配置的历史版本（默认 30 天），支持一键回滚到历史版本，应对配置修改错误的场景。</li></ul><h3 id="4-3-配置安全：敏感信息加密"><a href="#4-3-配置安全：敏感信息加密" class="headerlink" title="4.3 配置安全：敏感信息加密"></a>4.3 配置安全：敏感信息加密</h3><p>针对数据库密码、AccessKey 等敏感配置，Nacos 提供两种加密方案：</p><ul><li><strong>传输加密</strong>：服务端与客户端通过 HTTPS 通信，避免配置在传输过程中被窃取；</li><li><strong>存储加密</strong>：使用 AES-128 或 RSA 算法对敏感配置加密后存储到 MySQL，客户端通过配置 <code>secretKey</code> 解密后使用（需在 <code>bootstrap.yaml</code> 中配置加密密钥）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Nacos </tag>
            
            <tag> 配置中心 </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 事件驱动 </tag>
            
            <tag> 动态配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub Actions 实现自动化部署完整指南</title>
      <link href="/2025/08/29/Hexo-GitHub-Actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/"/>
      <url>/2025/08/29/Hexo-GitHub-Actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Hexo 搭建个人博客时，当我们终于把hexo生成的页面挂载到github页面后，每次提交博客都需要使用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>来部署很麻烦，可以借助github actions来实现流水线布置，我们每次提交源代码到github存放源码的分支上，一旦监听到源代码的push事件，流水线就会就会自动拉取环境自动部署，所以我们需要一个存放源代码的分支，以及我们的发布分支，可以使用git命令创建这两个分支，自动CI&#x2F;CD,github需要密钥用来保证项目拉取和部署的权限，需要在本地生成ssh的密钥，公钥用来拉取项目，私钥用来部署推送更新页面，而且github对于npm安装有频率限制，我们可以通过配置国内镜像源+缓存配置，避免每次全量拉取，提高依赖安装以及部署的速度</p><h2 id="一-分支规划与准备工作"><a href="#一-分支规划与准备工作" class="headerlink" title="一.分支规划与准备工作"></a>一.分支规划与准备工作</h2><p>为了清晰分离源代码和部署文件，我们需要创建两个分支：</p><ul><li><code>source</code> 分支：存放 Hexo 源代码（包括 Markdown 文章、配置文件、主题文件等）</li><li><code>main</code> 分支：存放 Hexo 生成的静态网页文件，用于 GitHub Pages 展示</li></ul><h3 id="创建分支的具体操作"><a href="#创建分支的具体操作" class="headerlink" title="创建分支的具体操作"></a>创建分支的具体操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从当前分支创建并切换到 source 分支（源代码分支）</span></span><br><span class="line">git checkout -b <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送 source 分支到远程仓库</span></span><br><span class="line">git push -u origin <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 main 分支（部署分支）</span></span><br><span class="line">git checkout main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="二-SSH-密钥配置（核心权限控制）"><a href="#二-SSH-密钥配置（核心权限控制）" class="headerlink" title="二.SSH 密钥配置（核心权限控制）"></a>二.SSH 密钥配置（核心权限控制）</h2><p>要实现 GitHub Actions 的自动部署，必须配置 SSH 密钥对来授权 Actions 操作仓库的权限：</p><h3 id="1-生成专用-SSH-密钥对"><a href="#1-生成专用-SSH-密钥对" class="headerlink" title="1. 生成专用 SSH 密钥对"></a>1. 生成专用 SSH 密钥对</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成专用密钥对，替换为你的邮箱地址</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span> -f ~/.ssh/hexo-deploy</span><br></pre></td></tr></table></figure><p>执行后会在 <code>~/.ssh/</code> 目录下生成两个文件：</p><ul><li><code>hexo-deploy</code>：私钥文件（用于部署时推送代码）</li><li><code>hexo-deploy.pub</code>：公钥文件（用于拉取仓库代码）</li></ul><h3 id="2-配置公钥（Deploy-keys）"><a href="#2-配置公钥（Deploy-keys）" class="headerlink" title="2. 配置公钥（Deploy keys）"></a>2. 配置公钥（Deploy keys）</h3><p>公钥需要配置到你的 GitHub Pages 仓库（通常是 <code>username.github.io</code>）：</p><ol><li>打开 <code>hexo-deploy.pub</code> 文件，复制其中的全部内容</li><li>进入你的 GitHub Pages 仓库 → Settings → Deploy keys</li><li>点击 “Add deploy key”，粘贴公钥内容</li><li>务必勾选 “Allow write access” 选项（允许推送权限）</li><li>点击 “Add key” 完成配置<img width="902" height="479" alt="屏幕截图 2025-08-29 190446" src="https://github.com/user-attachments/assets/9befac08-b11e-4cdb-9086-5c36af4d5eb0" /></li></ol><h3 id="3-配置私钥（Repository-secrets）"><a href="#3-配置私钥（Repository-secrets）" class="headerlink" title="3. 配置私钥（Repository secrets）"></a>3. 配置私钥（Repository secrets）</h3><p>私钥需要配置到存放 Hexo 源代码的仓库：</p><ol><li>打开 <code>hexo-deploy</code> 文件，复制其中的全部内容</li><li>进入你的源代码仓库 → Settings → Secrets and variables → Actions</li><li>点击 “New repository secret”</li><li>名称填写 <code>HEXO_DEPLOY_PRI</code>（必须与后续配置文件中一致）</li><li>粘贴私钥内容，点击 “Add secret” 完成配置<img width="1829" height="847" alt="image" src="https://github.com/user-attachments/assets/f5798732-4256-4222-9a5d-020afe645f53" /></li></ol><img width="1213" height="678" alt="image" src="https://github.com/user-attachments/assets/d75ce0f6-41da-402c-9682-6d9384c9f3bb" /><h2 id="配置-GitHub-Actions-工作流"><a href="#配置-GitHub-Actions-工作流" class="headerlink" title="配置 GitHub Actions 工作流"></a>配置 GitHub Actions 工作流</h2><p>在源代码仓库中创建工作流配置文件，实现自动部署的核心逻辑：</p><h3 id="创建工作流文件"><a href="#创建工作流文件" class="headerlink" title="创建工作流文件"></a>创建工作流文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Hexo 项目根目录执行以下命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -p .github/workflows</span><br><span class="line"><span class="built_in">touch</span> .github/workflows/deploy.yml</span><br></pre></td></tr></table></figure><h3 id="完整配置内容"><a href="#完整配置内容" class="headerlink" title="完整配置内容"></a>完整配置内容</h3><p>编辑 <code>.github/workflows/deploy.yml</code> 文件，添加以下内容(没有这个目录需要自己手动创建)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">source</span> ] <span class="comment"># 方括号内填入拉取代码分支 当监听到push事件就会开启自动部署deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;18&#x27;</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span>  <span class="comment"># 启用 npm 缓存，减少重复下载</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        # 关键：切换为国内淘宝镜像，彻底解决 github 频率限制报错 429 限制</span></span><br><span class="line"><span class="string">        npm config set registry https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        # 清除缓存，避免镜像切换不生效</span></span><br><span class="line"><span class="string">        npm cache clean --force</span></span><br><span class="line"><span class="string">        # 安装依赖（全局和项目依赖都用国内镜像）</span></span><br><span class="line"><span class="string">        npm install -g hexo-cli --registry=https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        npm install --registry=https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        # 构建静态文件</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_PRI</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">main</span>  <span class="comment"># 与 _config.yml 中的 deploy.branch 一致</span></span><br></pre></td></tr></table></figure><h2 id="配置优化说明"><a href="#配置优化说明" class="headerlink" title="配置优化说明"></a>配置优化说明</h2><h3 id="1-国内镜像源优化"><a href="#1-国内镜像源优化" class="headerlink" title="1. 国内镜像源优化"></a>1. 国内镜像源优化</h3><p>通过配置淘宝 npm 镜像源（<code>https://registry.npmmirror.com/</code>），解决了 GitHub 服务器上安装依赖的两大问题：</p><ul><li>访问速度慢（国内镜像加速）</li><li>访问频率限制（避免 npm 官方源的限流）</li></ul><h3 id="2-缓存机制优化"><a href="#2-缓存机制优化" class="headerlink" title="2. 缓存机制优化"></a>2. 缓存机制优化</h3><ul><li>缓存 <code>node_modules</code> 目录，避免每次部署重复安装依赖</li><li>基于 <code>package-lock.json</code> 的哈希值生成缓存键，只有依赖变更时才重新安装</li><li>使用 <code>npm ci</code> 替代 <code>npm install</code>，利用锁文件实现更快、更一致的依赖安装</li></ul><h3 id="3-安全权限控制"><a href="#3-安全权限控制" class="headerlink" title="3. 安全权限控制"></a>3. 安全权限控制</h3><ul><li>采用 SSH 密钥对进行身份验证，比传统 token 更安全</li><li>私钥通过 GitHub Secrets 加密存储，不会暴露在代码中</li><li>细粒度权限控制：Deploy keys 仅对目标仓库有效，避免全局权限风险</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-初始配置提交"><a href="#1-初始配置提交" class="headerlink" title="1. 初始配置提交"></a>1. 初始配置提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交工作流配置文件</span></span><br><span class="line">git add .github/workflows/deploy.yml</span><br><span class="line"><span class="comment"># 提交其他源代码文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;配置 GitHub Actions 自动部署&quot;</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="2-查看部署状态"><a href="#2-查看部署状态" class="headerlink" title="2. 查看部署状态"></a>2. 查看部署状态</h3><ol><li>进入源代码仓库的 GitHub 页面</li><li>点击顶部的 “Actions” 标签</li><li>查看名为 “Hexo Auto Deploy” 的工作流运行状态</li><li>点击具体运行记录可查看详细日志（便于排查错误）</li></ol><h3 id="3-发布新文章流程"><a href="#3-发布新文章流程" class="headerlink" title="3. 发布新文章流程"></a>3. 发布新文章流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new <span class="string">&quot;我的新文章&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文章（在 source/_posts 目录下）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到源代码仓库</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;发布新文章：我的新文章&quot;</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>提交后，GitHub Actions 会自动触发部署流程，无需再执行手动部署命令，整个过程约 1-3 分钟。</p><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><ol><li><p><strong>部署失败提示权限错误</strong></p><ul><li>检查 SSH 密钥对是否匹配</li><li>确认公钥是否勾选了 “Allow write access”</li><li>检查私钥在 Secrets 中的名称是否为 <code>HEXO_DEPLOY_KEY</code></li></ul></li><li><p><strong>主题样式丢失</strong></p><ul><li>确保配置文件中 <code>submodules: true</code> 已设置（拉取主题子模块）</li><li>检查主题是否正确添加到源代码仓库</li></ul></li><li><p><strong>依赖安装失败</strong></p><ul><li>查看日志确认是否为网络问题</li><li>尝试删除缓存后重新部署（可在 GitHub 仓库的 Actions 缓存设置中操作）</li></ul></li><li><p><strong>部署成功但页面未更新</strong></p><ul><li>检查 GitHub Pages 配置的分支是否为 <code>main</code></li><li>浏览器强制刷新（Ctrl+Shift+R 或 Cmd+Shift+R）清除缓存</li></ul></li></ol><p>Hexo 博客的全自动部署流程，就可以只在source&#x2F;_post目录下只提交md文件（必须是md后缀文件）到github项目的分支上就可以自动部署了</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos 2.X 核心源码学习笔记</title>
      <link href="/2025/08/27/Nacos2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/27/Nacos2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Nacos 作为阿里开源的分布式服务发现与配置管理平台，2.X 版本在架构上进行了协议升级（HTTP→gRPC）、存储结构优化（嵌套 Map→扁平分层）、一致性增强（Distro→Raft）</p><p>Nacos 2.X 主要核心优化：</p><ol><li>协议升级：gRPC 长连接替代 HTTP，降低通信开销，提升实时性；</li><li>存储优化：扁平分层注册表替代嵌套 Map，提升查询与同步效率；</li><li>事件驱动：解耦模块依赖，增强扩展性；</li><li>健康检查：服务端主动探活替代客户端心跳，减少客户端负担；</li><li>一致性增强：Raft+Distro 混合协议，平衡一致性与性能。</li></ol><h2 id="二、服务注册核心源码剖析"><a href="#二、服务注册核心源码剖析" class="headerlink" title="二、服务注册核心源码剖析"></a>二、服务注册核心源码剖析</h2><p>服务注册是 Nacos 的基础能力，2.X 版本通过 gRPC 长连接异步通信替代 1.X 的 HTTP 短连接，同时优化了实例存储与一致性逻辑。</p><h3 id="（一）客户端：发起注册请求"><a href="#（一）客户端：发起注册请求" class="headerlink" title="（一）客户端：发起注册请求"></a>（一）客户端：发起注册请求</h3><p>客户端核心是封装实例信息、建立 gRPC 连接并发送注册请求，关键类集中在 <code>nacos-naming-client</code> 模块。</p><ol><li>入口类：<code>NacosNamingService</code></li></ol><p>客户端对外暴露的注册入口，负责参数预处理与代理分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务唯一标识：group@@serviceName（Nacos 服务的核心命名规则）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 补全实例默认值（如集群名默认值、命名空间）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.getClusterName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setClusterName(ClusterUtils.getDefaultClusterName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instance.getNamespaceId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setNamespaceId(<span class="built_in">this</span>.namespace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 委托 gRPC 代理发送注册请求（核心逻辑）</span></span><br><span class="line">    namingClientProxy.registerInstance(groupedServiceName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>gRPC 代理：<code>NamingGrpcClientProxy</code></li></ol><p>负责将注册请求封装为 gRPC 协议格式，通过长连接发送至服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 gRPC 注册请求（ProtoBuf 格式，适配 gRPC 传输）</span></span><br><span class="line">    <span class="type">RegisterInstanceRequest</span> <span class="variable">request</span> <span class="operator">=</span> RegisterInstanceRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setInstance(GrpcUtils.convertInstanceToProto(instance)) <span class="comment">// 实例信息转 Proto</span></span><br><span class="line">            .setNamespace(instance.getNamespaceId())</span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口（失败重试由底层 GrpcUtils 实现）</span></span><br><span class="line">    GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.registerInstance(request), <span class="comment">// namingStub 是 gRPC 自动生成的客户端存根</span></span><br><span class="line">        <span class="string">&quot;registerInstance&quot;</span>, </span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键细节：客户端初始化时会与服务端建立 gRPC 长连接（默认端口 9848），后续注册、心跳、订阅均复用该连接，减少 TCP 握手开销。</li></ul><h3 id="（二）服务端：处理注册请求"><a href="#（二）服务端：处理注册请求" class="headerlink" title="（二）服务端：处理注册请求"></a>（二）服务端：处理注册请求</h3><p>服务端核心是接收 gRPC 请求、校验参数、分层存储实例，并触发事件通知与集群同步，关键类集中在 <code>nacos-naming-core</code> 模块。</p><ol><li>gRPC 请求入口：<code>NamingGrpcService</code></li></ol><p>服务端 gRPC 服务实现类，负责接收客户端请求并转发至业务逻辑层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.controllers.v2.grpc.NamingGrpcService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(RegisterInstanceRequest request, StreamObserver&lt;CommonResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="type">CommonResponse</span> <span class="variable">response</span> <span class="operator">=</span> CommonResponse.newBuilder().build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 解析请求参数（服务名、命名空间、实例信息）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> GrpcUtils.convertProtoToInstance(request.getInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 委托 ServiceManager 处理注册核心逻辑</span></span><br><span class="line">        serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回成功响应</span></span><br><span class="line">        response.setSuccess(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;注册失败：&quot;</span> + e.getMessage());</span><br><span class="line">        log.error(<span class="string">&quot;Instance register failed&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        responseObserver.onNext(response);</span><br><span class="line">        responseObserver.onCompleted(); <span class="comment">// 结束 gRPC 流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务管理核心：<code>ServiceManager</code></li></ol><p>负责创建&#x2F;获取服务、调度实例注册，是服务端的”服务中枢”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 生成服务唯一 Key：namespaceId@@group@@serviceName（避免同名冲突）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 不存在则创建 Service（懒加载模式，减少内存占用）</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getOrCreateService(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将实例注册到对应集群（核心：分层存储的入口）</span></span><br><span class="line">    service.registerInstance(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 发布服务注册事件（触发后续健康检查、集群同步）</span></span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载创建 Service</span></span><br><span class="line"><span class="keyword">private</span> Service <span class="title function_">getOrCreateService</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">return</span> serviceMap.computeIfAbsent(serviceKey, key -&gt; &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">newService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">        newService.setNamespaceId(namespaceId);</span><br><span class="line">        newService.setServiceName(serviceName);</span><br><span class="line">        newService.setId(IdGenerator.generateServiceId(namespaceId, serviceName));</span><br><span class="line">        <span class="keyword">return</span> newService;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>分层存储：<code>Service</code> → <code>Cluster</code> → <code>Instance</code></li></ol><p>2.X 采用”服务-集群-实例”三层结构，替代 1.X 的嵌套 Map，每个层级独立管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取/创建实例所属集群（默认集群名：DEFAULT）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> instance.getClusterName();</span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> clusters.computeIfAbsent(clusterName, key -&gt; <span class="keyword">new</span> <span class="title class_">Cluster</span>(clusterName, <span class="built_in">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将实例注册到集群（集群维护实例集合）</span></span><br><span class="line">    cluster.addInstance(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Cluster</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 实例存储容器：线程安全的 ConcurrentHashMap（key=instanceId，避免重复注册）</span></span><br><span class="line">    ConcurrentHashMap&lt;String, Instance&gt; instanceMap = getInstanceMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分临时实例与持久化实例（核心差异：是否依赖心跳）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">        <span class="comment">// 临时实例：内存存储 + 心跳绑定</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        <span class="comment">// 注册心跳检测任务（服务端主动探活）</span></span><br><span class="line">        healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, <span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 持久化实例：内存 + 本地文件持久化（重启不丢失）</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        persistInstance(instance); <span class="comment">// 持久化到 data/nacos/naming/ 目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>请求校验：隐式在业务逻辑中</li></ol><p>2.X 未单独封装 <code>InstanceValidator</code>，而是在实例注册前通过 参数非空校验+格式校验 确保合法性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cluster.addInstance 中隐含的校验逻辑（简化）</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(instance.getIp()) || instance.getPort() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;IP/端口不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instance.getWeight() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;权重不能为负数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、事件驱动架构剖析"><a href="#三、事件驱动架构剖析" class="headerlink" title="三、事件驱动架构剖析"></a>三、事件驱动架构剖析</h2><p>Nacos 2.X 基于 “事件发布-订阅”模式 解耦模块依赖，核心由「事件、事件总线、发布者、订阅者」四部分组成，所有核心流程（注册、健康检查、同步）均通过事件触发。</p><h3 id="（一）事件：状态变化的载体"><a href="#（一）事件：状态变化的载体" class="headerlink" title="（一）事件：状态变化的载体"></a>（一）事件：状态变化的载体</h3><p>事件是系统状态变化的封装，所有事件均继承自顶层接口 <code>Event</code>，核心事件类如下：</p><table><thead><tr><th>事件类</th><th>触发场景</th><th>核心属性</th></tr></thead><tbody><tr><td><code>ServiceInstanceEvent</code></td><td>服务实例注册&#x2F;更新&#x2F;删除</td><td><code>service</code>（服务）、<code>instance</code>（实例）</td></tr><tr><td><code>HealthStateChangeEvent</code></td><td>实例健康状态变更（健康→不健康）</td><td><code>instanceId</code>、<code>newHealthyState</code></td></tr><tr><td><code>ConfigDataChangeEvent</code></td><td>配置中心数据变更</td><td><code>dataId</code>、<code>group</code>、<code>content</code></td></tr></tbody></table><p>示例：服务实例注册事件定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.event.ServiceInstanceRegisteredEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInstanceRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">AbstractEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service service;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInstanceRegisteredEvent</span><span class="params">(Service service, Instance instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）事件总线：事件路由的核心"><a href="#（二）事件总线：事件路由的核心" class="headerlink" title="（二）事件总线：事件路由的核心"></a>（二）事件总线：事件路由的核心</h3><p>事件总线负责连接发布者与订阅者，提供事件注册、发布、路由能力，核心实现类为 <code>NacosEventBus</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.common.event.NacosEventBus</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosEventBus</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventBus</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：事件类型 → 订阅者列表（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;, CopyOnWriteArrayList&lt;Subscriber&gt;&gt; subscriberMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 注册订阅者（根据事件类型关联）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Subscriber subscriber)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = subscriber.getSubscribeType();</span><br><span class="line">        subscriberMap.computeIfAbsent(eventType, key -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;())</span><br><span class="line">                     .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发布事件（路由到对应订阅者）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = event.getClass();</span><br><span class="line">        <span class="comment">// 找到订阅该事件的所有订阅者</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscriber&gt; subscribers = subscriberMap.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscribers == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步触发订阅者的事件处理（默认线程池：EventExecutor）</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            EventExecutor.execute(() -&gt; subscriber.onEvent(event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）发布者：事件的产生者"><a href="#（三）发布者：事件的产生者" class="headerlink" title="（三）发布者：事件的产生者"></a>（三）发布者：事件的产生者</h3><p>发布者在特定业务逻辑完成后发布事件，核心实现是 <code>EventPublisher</code> 接口，默认实现为 <code>DefaultEventPublisher</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManager 中发布注册事件的逻辑（前文已提及）</span></span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br></pre></td></tr></table></figure><p>常见发布场景：</p><ul><li>服务注册完成 → 发布 <code>ServiceInstanceRegisteredEvent</code></li><li>实例健康状态变更 → 发布 <code>HealthStateChangeEvent</code></li><li>配置数据更新 → 发布 <code>ConfigDataChangeEvent</code></li></ul><h3 id="（四）订阅者：事件的消费者"><a href="#（四）订阅者：事件的消费者" class="headerlink" title="（四）订阅者：事件的消费者"></a>（四）订阅者：事件的消费者</h3><p>订阅者通过 实现 <code>Subscriber</code> 接口 或 添加 <code>@EventListener</code> 注解 订阅事件，核心是编写事件处理逻辑。</p><p>示例：健康检查订阅者（监听注册事件，初始化探活任务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.subscriber.InstanceRegisteredSubscriber</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceRegisteredSubscriber</span> <span class="keyword">implements</span> <span class="title class_">Subscriber</span>&lt;ServiceInstanceRegisteredEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckReactor healthCheckReactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅的事件类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; getSubscribeType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceRegisteredEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ServiceInstanceRegisteredEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> event.getInstance();</span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> event.getService().getCluster(instance.getClusterName());</span><br><span class="line">        <span class="comment">// 为临时实例添加 gRPC 探活任务</span></span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, cluster));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键优势：模块间无需硬编码依赖（如注册模块不直接调用健康检查模块），只需通过事件交互，扩展性极强。</li></ul><h2 id="四、注册表结构变动剖析"><a href="#四、注册表结构变动剖析" class="headerlink" title="四、注册表结构变动剖析"></a>四、注册表结构变动剖析</h2><p>Nacos 2.X 对注册表的优化是性能提升的核心，主要解决 1.X 嵌套 Map 带来的 深拷贝开销大、查询效率低 问题。</p><h3 id="（一）旧结构（1-X）：嵌套-Map-的痛点"><a href="#（一）旧结构（1-X）：嵌套-Map-的痛点" class="headerlink" title="（一）旧结构（1.X）：嵌套 Map 的痛点"></a>（一）旧结构（1.X）：嵌套 Map 的痛点</h3><p>1.X 注册表采用 四层嵌套 Map，结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.X 注册表结构（简化）</span></span><br><span class="line">Map&lt;String, Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Instance&gt;&gt;&gt;&gt;&gt; registry;</span><br><span class="line"><span class="comment">// 层级：namespace → group → service → cluster → instanceList</span></span><br></pre></td></tr></table></figure><ul><li>痛点：</li></ul><ol><li>查询实例需逐层遍历（如 <code>registry.get(namespace).get(group).get(service).get(cluster)</code>），效率低；</li><li>数据同步&#x2F;备份时需深拷贝整个嵌套结构，内存与时间开销大；</li><li>新增维度（如元数据）需修改多层结构，扩展性差。</li></ol><h3 id="（二）新结构（2-X）：扁平分层存储"><a href="#（二）新结构（2-X）：扁平分层存储" class="headerlink" title="（二）新结构（2.X）：扁平分层存储"></a>（二）新结构（2.X）：扁平分层存储</h3><p>2.X 将注册表拆分为 独立的分层存储单元，通过 唯一 Key 关联，核心实现类为 <code>ServiceStorage</code>：</p><ol><li>核心存储结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.storage.ServiceStorage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceStorage</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式（注册表全局唯一）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ServiceStorage</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStorage</span>();</span><br><span class="line">    <span class="comment">// 存储：namespace → (serviceKey → ServiceInfo)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Namespace, ConcurrentHashMap&lt;Service, ServiceInfo&gt;&gt; namespaceServiceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务实例列表（通过 namespace + service 直接定位）</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(Namespace namespace, Service service)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;Service, ServiceInfo&gt; serviceInfoMap = namespaceServiceInfoMap.get(namespace);</span><br><span class="line">        <span class="keyword">if</span> (serviceInfoMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增/更新服务实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putServiceInfo</span><span class="params">(Namespace namespace, Service service, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        namespaceServiceInfoMap.computeIfAbsent(namespace, key -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;())</span><br><span class="line">                               .put(service, serviceInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>联合 Key 设计</li></ol><p>通过 <code>ServiceKeyGenerator</code> 生成 全局唯一 Key，替代多层嵌套的定位逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceKeyGenerator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceKeyGenerator</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 serviceKey：namespaceId@@groupName@@serviceName</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateServiceKey</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 serviceName 中解析出 groupName（serviceName 格式：group@@service）</span></span><br><span class="line">        String[] parts = serviceName.split(<span class="string">&quot;@@&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">0</span>] : Constants.DEFAULT_GROUP;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pureServiceName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">1</span>] : parts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s@@%s@@%s&quot;</span>, namespaceId, groupName, pureServiceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>优化效果</li></ol><ul><li>查询效率：从 O(n^4) 嵌套遍历降至 O(1) 哈希查询；</li><li>同步开销：数据同步时只需传输单个 <code>ServiceInfo</code> 对象，无需深拷贝；</li><li>扩展性：新增维度（如实例标签）只需在 <code>Instance</code> 类加字段，不影响存储结构。</li></ul><h2 id="五、服务发现与订阅核心源码剖析"><a href="#五、服务发现与订阅核心源码剖析" class="headerlink" title="五、服务发现与订阅核心源码剖析"></a>五、服务发现与订阅核心源码剖析</h2><p>服务发现是客户端获取健康实例的过程，2.X 通过 gRPC 长连接+主动推送 替代 1.X 的 HTTP 轮询，实时性与效率大幅提升。</p><h3 id="（一）通信方式转变：HTTP-→-gRPC"><a href="#（一）通信方式转变：HTTP-→-gRPC" class="headerlink" title="（一）通信方式转变：HTTP → gRPC"></a>（一）通信方式转变：HTTP → gRPC</h3><p>2.X 客户端默认使用 <code>RpcNamingClientProxy</code>（gRPC 代理），仅在兼容模式下使用 <code>HttpNamingClientProxy</code>，核心优势：</p><ul><li>长连接复用：减少 TCP 握手与挥手开销；</li><li>二进制传输：ProtoBuf 格式比 JSON 体积小 30%+；</li><li>主动推送：服务变动时服务端主动推送，无需客户端轮询。</li></ul><h3 id="（二）服务发现逻辑"><a href="#（二）服务发现逻辑" class="headerlink" title="（二）服务发现逻辑"></a>（二）服务发现逻辑</h3><p>客户端通过 gRPC 向服务端查询实例，服务端从注册表过滤健康实例后返回。</p><ol><li>客户端查询入口：<code>NacosNamingService</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 委托 gRPC 代理查询</span></span><br><span class="line">    <span class="keyword">return</span> namingClientProxy.selectInstances(groupedServiceName, healthy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>gRPC 代理查询实现：<code>RpcNamingClientProxy</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.RpcNamingClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建查询请求（指定服务名、健康状态过滤）</span></span><br><span class="line">    <span class="type">QueryInstancesRequest</span> <span class="variable">request</span> <span class="operator">=</span> QueryInstancesRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setNamespace(namespace)</span><br><span class="line">            .setHealthyOnly(healthy) <span class="comment">// 只返回健康实例</span></span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口</span></span><br><span class="line">    <span class="type">QueryInstancesResponse</span> <span class="variable">response</span> <span class="operator">=</span> GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.queryInstances(request),</span><br><span class="line">        <span class="string">&quot;queryInstances&quot;</span>,</span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 解析响应，返回实例列表</span></span><br><span class="line">    <span class="keyword">return</span> response.getInstancesList().stream()</span><br><span class="line">            .map(GrpcUtils::convertProtoToInstance)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端查询处理：<code>InstanceQueryHandler</code></li></ol><p>服务端接收查询请求后，从注册表过滤实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.remote.rpc.handler.InstanceQueryHandler</span></span><br><span class="line"><span class="keyword">public</span> QueryInstancesResponse <span class="title function_">handle</span><span class="params">(QueryInstancesRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">healthyOnly</span> <span class="operator">=</span> request.isHealthyOnly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取服务信息</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> QueryInstancesResponse.newBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 过滤实例（健康状态、权重&gt;0）</span></span><br><span class="line">    List&lt;Instance&gt; filteredInstances = service.getAllInstances().stream()</span><br><span class="line">            .filter(instance -&gt; !healthyOnly || instance.isHealthy()) <span class="comment">// 健康状态过滤</span></span><br><span class="line">            .filter(instance -&gt; instance.getWeight() &gt; <span class="number">0</span>) <span class="comment">// 权重过滤</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 构建响应</span></span><br><span class="line">    <span class="keyword">return</span> QueryInstancesResponse.newBuilder()</span><br><span class="line">            .addAllInstances(GrpcUtils.convertInstancesToProtos(filteredInstances))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）服务订阅逻辑"><a href="#（三）服务订阅逻辑" class="headerlink" title="（三）服务订阅逻辑"></a>（三）服务订阅逻辑</h3><p>订阅是”一次订阅，持续接收更新”的机制，客户端注册监听器，服务端变动时主动推送。</p><ol><li>客户端订阅入口：<code>NacosNamingService</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String groupName, EventListener listener)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 1. 本地注册监听器（避免重复订阅）</span></span><br><span class="line">    subscriptionManager.subscribe(groupedServiceName, listener);</span><br><span class="line">    <span class="comment">// 2. 向服务端发起订阅请求（建立推送关系）</span></span><br><span class="line">    namingClientProxy.subscribe(groupedServiceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务端订阅管理：<code>SubscriptionManager</code></li></ol><p>服务端存储”服务-客户端”订阅关系，核心是 <code>ConcurrentHashMap</code> 映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 订阅该服务的客户端集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Subscriber&gt;&gt; serviceSubscribers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册订阅关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceKey, Subscriber subscriber)</span> &#123;</span><br><span class="line">        serviceSubscribers.computeIfAbsent(serviceKey, key -&gt; ConcurrentHashMap.newKeySet())</span><br><span class="line">                          .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务的所有订阅者（用于推送）</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Subscriber&gt; <span class="title function_">getSubscribers</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceSubscribers.getOrDefault(serviceKey, Collections.emptySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端推送触发：事件驱动</li></ol><p>当服务实例变动时，通过事件触发推送逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.PushService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听实例变更事件，触发推送</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInstanceChange</span><span class="params">(ServiceInstanceEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> event.getService();</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(service.getNamespaceId(), service.getServiceName());</span><br><span class="line">        <span class="comment">// 1. 获取订阅该服务的所有客户端</span></span><br><span class="line">        Set&lt;Subscriber&gt; subscribers = subscriptionManager.getSubscribers(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (subscribers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建推送数据（最新实例列表）</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> serviceStorage.getServiceInfo(service.getNamespaceId(), service);</span><br><span class="line">        <span class="comment">// 3. 通过 gRPC 向客户端推送</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            pushToClient(subscriber, serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 推送实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushToClient</span><span class="params">(Subscriber subscriber, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">ServiceChangeResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServiceChangeResponse.newBuilder()</span><br><span class="line">                .setServiceInfo(GrpcUtils.convertServiceInfoToProto(serviceInfo))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 通过客户端的 gRPC 连接推送</span></span><br><span class="line">        subscriber.getGrpcChannel().writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、服务变动推送订阅客户端源码剖析"><a href="#六、服务变动推送订阅客户端源码剖析" class="headerlink" title="六、服务变动推送订阅客户端源码剖析"></a>六、服务变动推送订阅客户端源码剖析</h2><p>客户端接收服务端推送的核心是 gRPC 流监听+本地缓存更新+监听器回调，关键类集中在 <code>nacos-naming-client</code> 模块。</p><h3 id="（一）推送接收：NamingPushResponseHandler"><a href="#（一）推送接收：NamingPushResponseHandler" class="headerlink" title="（一）推送接收：NamingPushResponseHandler"></a>（一）推送接收：<code>NamingPushResponseHandler</code></h3><p>客户端通过 gRPC 流观察者监听服务端推送，核心是 <code>onNext</code> 方法（推送消息接收入口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingPushResponseHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NamingPushResponseHandler</span> <span class="keyword">implements</span> <span class="title class_">StreamObserver</span>&lt;ServiceChangeResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfoHolder serviceInfoHolder; <span class="comment">// 本地缓存管理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager; <span class="comment">// 本地监听器管理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务端推送的变动消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(ServiceChangeResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 解析推送数据（Proto → ServiceInfo）</span></span><br><span class="line">            <span class="type">ServiceInfoProto</span> <span class="variable">serviceInfoProto</span> <span class="operator">=</span> response.getServiceInfo();</span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">newServiceInfo</span> <span class="operator">=</span> GrpcUtils.convertProtoToServiceInfo(serviceInfoProto);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 更新本地缓存（覆盖旧数据，保证一致性）</span></span><br><span class="line">            serviceInfoHolder.processServiceInfo(newServiceInfo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 触发本地监听器回调（通知业务层）</span></span><br><span class="line">            subscriptionManager.notifyListeners(newServiceInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;处理服务推送失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流异常处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;gRPC 推送流异常&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流关闭处理（重连机制）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;gRPC 推送流关闭，尝试重连&quot;</span>);</span><br><span class="line">        reconnect(); <span class="comment">// 内部实现重连逻辑，确保推送不中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）本地缓存更新：ServiceInfoHolder"><a href="#（二）本地缓存更新：ServiceInfoHolder" class="headerlink" title="（二）本地缓存更新：ServiceInfoHolder"></a>（二）本地缓存更新：<code>ServiceInfoHolder</code></h3><p>客户端维护本地实例缓存，避免重复查询服务端，核心是 <code>serviceInfoMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.cache.ServiceInfoHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfoHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 本地缓存：serviceKey → ServiceInfo（serviceKey 格式：group@@service@@cluster）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ServiceInfo&gt; serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新缓存（版本校验，避免旧数据覆盖新数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processServiceInfo</span><span class="params">(ServiceInfo newServiceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> newServiceInfo.getKey();</span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldServiceInfo</span> <span class="operator">=</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 版本校验：仅更新比本地新的数据（lastRefTime 为数据最后更新时间）</span></span><br><span class="line">        <span class="keyword">if</span> (oldServiceInfo != <span class="literal">null</span> &amp;&amp; newServiceInfo.getLastRefTime() &lt;= oldServiceInfo.getLastRefTime()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        serviceInfoMap.put(serviceKey, newServiceInfo);</span><br><span class="line">        newServiceInfo.setLastRefTime(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地缓存的实例列表</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）监听器回调：SubscriptionManager"><a href="#（三）监听器回调：SubscriptionManager" class="headerlink" title="（三）监听器回调：SubscriptionManager"></a>（三）监听器回调：<code>SubscriptionManager</code></h3><p>客户端通知业务层服务变动，核心是遍历监听器并调用 <code>onEvent</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.subscription.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 监听器集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;EventListener&gt;&gt; listenerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发监听器回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyListeners</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> serviceInfo.getKey();</span><br><span class="line">        Set&lt;EventListener&gt; listeners = listenerMap.get(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历监听器，触发业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.onEvent(<span class="keyword">new</span> <span class="title class_">NamingEvent</span>(serviceInfo.getName(), serviceInfo.getHosts()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;监听器回调失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层示例：客户端通过实现 <code>EventListener</code> 感知变动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务层订阅示例</span></span><br><span class="line">namingService.subscribe(<span class="string">&quot;user-service&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="type">NamingEvent</span> <span class="variable">namingEvent</span> <span class="operator">=</span> (NamingEvent) event;</span><br><span class="line">        List&lt;Instance&gt; instances = namingEvent.getInstances();</span><br><span class="line">        <span class="comment">// 业务逻辑：更新本地服务列表、重新计算负载均衡等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务变动，新实例列表：&quot;</span> + instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="七、服务端健康检查源码剖析"><a href="#七、服务端健康检查源码剖析" class="headerlink" title="七、服务端健康检查源码剖析"></a>七、服务端健康检查源码剖析</h2><p>Nacos 2.X 健康检查从 客户端主动心跳 改为 服务端主动探活，减少客户端开销，同时提高探活准确性。</p><h3 id="（一）核心机制：服务端-gRPC-主动探活"><a href="#（一）核心机制：服务端-gRPC-主动探活" class="headerlink" title="（一）核心机制：服务端 gRPC 主动探活"></a>（一）核心机制：服务端 gRPC 主动探活</h3><p>2.X 对临时实例（默认）采用 gRPC 探活，对持久化实例采用 HTTP 探活（可配置），核心由 <code>HealthCheckReactor</code> 调度探活任务。</p><h3 id="（二）探活任务管理：HealthCheckReactor"><a href="#（二）探活任务管理：HealthCheckReactor" class="headerlink" title="（二）探活任务管理：HealthCheckReactor"></a>（二）探活任务管理：<code>HealthCheckReactor</code></h3><p>负责创建、调度探活任务，采用线程池异步执行，避免阻塞主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.HealthCheckReactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthCheckReactor</span> &#123;</span><br><span class="line">    <span class="comment">// 探活线程池（核心线程数：CPU 核心数 * 2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">healthCheckExecutor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;nacos-health-check-%d&quot;</span>).build()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加探活任务（延迟 0 秒，周期 20 秒执行一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHealthCheckTask</span><span class="params">(HealthCheckTask task)</span> &#123;</span><br><span class="line">        healthCheckExecutor.scheduleAtFixedRate(</span><br><span class="line">            task,</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 初始延迟</span></span><br><span class="line">            <span class="number">20000</span>, <span class="comment">// 周期（20 秒，默认值）</span></span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）gRPC-探活实现：GrpcHealthCheckTask"><a href="#（三）gRPC-探活实现：GrpcHealthCheckTask" class="headerlink" title="（三）gRPC 探活实现：GrpcHealthCheckTask"></a>（三）gRPC 探活实现：<code>GrpcHealthCheckTask</code></h3><p>临时实例的探活任务，通过 gRPC 向客户端发送探活请求，判断实例是否存活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.processor.GrpcHealthCheckTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcHealthCheckTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line">    <span class="comment">// 探活超时时间（5 秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建 gRPC 探活请求</span></span><br><span class="line">            <span class="type">HealthCheckRequest</span> <span class="variable">request</span> <span class="operator">=</span> HealthCheckRequest.newBuilder()</span><br><span class="line">                    .setInstanceId(instance.getInstanceId())</span><br><span class="line">                    .build();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 向实例发送探活请求（客户端需实现 gRPC 健康检查接口）</span></span><br><span class="line">            <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> GrpcChannelFactory.getChannel(instance.getIp(), instance.getPort());</span><br><span class="line">            HealthCheckGrpc.<span class="type">HealthCheckBlockingStub</span> <span class="variable">stub</span> <span class="operator">=</span> HealthCheckGrpc.newBlockingStub(channel)</span><br><span class="line">                    .withDeadlineAfter(TIMEOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="type">HealthCheckResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.check(request);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 更新实例健康状态</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newHealthy</span> <span class="operator">=</span> response.getStatus() == HealthCheckResponse.ServingStatus.SERVING;</span><br><span class="line">            updateInstanceHealthStatus(newHealthy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 探活失败，标记为不健康</span></span><br><span class="line">            updateInstanceHealthStatus(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新实例健康状态并发布事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInstanceHealthStatus</span><span class="params">(<span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oldHealthy</span> <span class="operator">=</span> instance.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (oldHealthy == healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 状态无变化，不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新健康状态</span></span><br><span class="line">        instance.setHealthy(healthy);</span><br><span class="line">        <span class="comment">// 发布健康状态变更事件（触发推送、集群同步）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">HealthStateChangeEvent</span>(instance.getInstanceId(), healthy));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（四）健康状态判断与实例剔除"><a href="#（四）健康状态判断与实例剔除" class="headerlink" title="（四）健康状态判断与实例剔除"></a>（四）健康状态判断与实例剔除</h3><p>服务端通过 “探活失败次数” 而非固定时间判断实例状态，默认规则：</p><ol><li>连续 1 次探活失败 → 标记实例为 <code>healthy=false</code>；</li><li>连续 3 次探活失败（累计 60 秒） → 从注册表中移除实例（仅临时实例）；</li><li>持久化实例探活失败不会被剔除，仅标记为不健康。</li></ol><p>实例剔除逻辑在 <code>InstanceCleaner</code> 中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.InstanceCleaner</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCleaner</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceManager serviceManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听健康状态变更事件，触发剔除判断</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHealthChange</span><span class="params">(HealthStateChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">instanceId</span> <span class="operator">=</span> event.getInstanceId();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> event.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询实例</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> instanceManager.getInstanceById(instanceId);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span> || !instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累计探活失败次数</span></span><br><span class="line">        instance.incrementHealthFailureCount();</span><br><span class="line">        <span class="comment">// 连续 3 次失败，剔除实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance.getHealthFailureCount() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            serviceManager.removeInstance(instance.getNamespaceId(), instance.getServiceName(), instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、服务变动集群同步源码剖析"><a href="#八、服务变动集群同步源码剖析" class="headerlink" title="八、服务变动集群同步源码剖析"></a>八、服务变动集群同步源码剖析</h2><p>Nacos 2.X 集群同步采用 “Raft 协议（持久化实例）+ Distro 协议（临时实例）” 混合方案，确保数据一致性与性能平衡。</p><h3 id="（一）临时实例同步：Distro-协议"><a href="#（一）临时实例同步：Distro-协议" class="headerlink" title="（一）临时实例同步：Distro 协议"></a>（一）临时实例同步：Distro 协议</h3><p>临时实例存储在内存，通过 Distro 协议实现 最终一致性 同步，核心是”分片+主动推送”。</p><ol><li>Distro 分片策略</li></ol><p>每个 Nacos 节点负责部分实例的同步（按 <code>instanceId</code> 哈希分片），避免全量同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroHashMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroHashMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 instanceId 计算分片，确定负责节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">mapInstanceToServers</span><span class="params">(String instanceId, List&lt;String&gt; allServers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> Math.abs(instanceId.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % allServers.size();</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(allServers.get(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步实现：<code>DistroDataSyncService</code></li></ol><p>当临时实例变动时，节点向负责该实例的其他节点推送同步数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroDataSyncService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroDataSyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DistroHashMapper hashMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GrpcClient grpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步临时实例变动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncEphemeralInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 计算负责该实例的节点</span></span><br><span class="line">        List&lt;String&gt; targetServers = hashMapper.mapInstanceToServers(instance.getInstanceId(), serverListManager.getServerList());</span><br><span class="line">        <span class="comment">// 2. 构建同步数据</span></span><br><span class="line">        <span class="type">DistroData</span> <span class="variable">data</span> <span class="operator">=</span> DistroDataBuilder.buildInstanceData(instance);</span><br><span class="line">        <span class="comment">// 3. 向目标节点推送同步请求</span></span><br><span class="line">        <span class="keyword">for</span> (String server : targetServers) &#123;</span><br><span class="line">            syncToServer(server, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 同步请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">syncToServer</span><span class="params">(String server, DistroData data)</span> &#123;</span><br><span class="line">        <span class="type">DistroSyncRequest</span> <span class="variable">request</span> <span class="operator">=</span> DistroSyncRequest.newBuilder()</span><br><span class="line">                .setData(ByteString.copyFrom(data.getContent()))</span><br><span class="line">                .build();</span><br><span class="line">        grpcClient.sendRequest(server, request, DistroSyncResponse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）持久化实例同步：Raft-协议"><a href="#（二）持久化实例同步：Raft-协议" class="headerlink" title="（二）持久化实例同步：Raft 协议"></a>（二）持久化实例同步：Raft 协议</h3><p>持久化实例存储在 MySQL，通过 Raft 协议实现 强一致性 同步，确保所有节点数据一致。</p><ol><li>Raft 核心实现：<code>RaftCore</code></li></ol><p>负责 Raft 协议的 ** Leader 选举、日志复制、数据提交**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.raft.RaftCore</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaftCore</span> &#123;</span><br><span class="line">    <span class="comment">// Raft 状态（FOLLOWER/CANDIDATE/LEADER）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RaftPeer.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> RaftPeer.State.FOLLOWER;</span><br><span class="line">    <span class="comment">// Raft 日志（存储所有变更操作）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Leader 选举（省略细节，核心是投票机制）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 触发选举逻辑，获取其他节点投票，得票超过半数成为 Leader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 日志复制（Leader 向 Follower 同步日志）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replicateLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != RaftPeer.State.LEADER) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;非 Leader 节点，无法复制日志&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加日志到本地</span></span><br><span class="line">        logEntries.add(entry);</span><br><span class="line">        <span class="comment">// 向所有 Follower 节点复制日志</span></span><br><span class="line">        <span class="keyword">for</span> (String follower : followerList) &#123;</span><br><span class="line">            replicateToFollower(follower, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 数据提交（日志复制到多数节点后，提交数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查日志是否已复制到多数节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLogReplicatedToMajority(entry.getIndex())) &#123;</span><br><span class="line">            <span class="comment">// 提交日志（更新本地注册表）</span></span><br><span class="line">            commitEntry(entry);</span><br><span class="line">            <span class="comment">// 通知 Follower 提交日志</span></span><br><span class="line">            notifyFollowersCommit(entry.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>持久化实例同步触发</li></ol><p>当持久化实例变动时，Leader 节点通过 Raft 日志复制同步到所有 Follower 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.RaftConsistencyServiceImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 Raft 日志条目</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> LogEntry.newBuilder()</span><br><span class="line">            .setKey(key)</span><br><span class="line">            .setValue(ByteString.copyFrom(SerializeUtils.serialize(value)))</span><br><span class="line">            .setType(LogEntryType.WRITE)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2. Leader 节点复制日志</span></span><br><span class="line">    raftCore.replicateLog(entry);</span><br><span class="line">    <span class="comment">// 3. 等待日志提交</span></span><br><span class="line">    raftCore.waitForLogCommit(entry.getIndex(), <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> 源码剖析 </tag>
            
            <tag> 分布式服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos 核心源码学习笔记</title>
      <link href="/2025/08/26/Nacos-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/26/Nacos-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos-核心源码学习笔记"><a href="#Nacos-核心源码学习笔记" class="headerlink" title="Nacos 核心源码学习笔记"></a>Nacos 核心源码学习笔记</h1><p>Nacos 作为微服务架构中核心的服务注册发现与配置中心，其底层设计与实现逻辑对理解微服务治理至关重要。本文从源码入口、服务注册、心跳检测、集群一致性四个核心维度，梳理 Nacos 关键机制的实现原理。</p><h2 id="一、源码入口与初始化机制"><a href="#一、源码入口与初始化机制" class="headerlink" title="一、源码入口与初始化机制"></a>一、源码入口与初始化机制</h2><h3 id="1-源码入口定位"><a href="#1-源码入口定位" class="headerlink" title="1. 源码入口定位"></a>1. 源码入口定位</h3><p>分析 Nacos 源码时，可通过启动脚本定位启动类，或直接聚焦服务发现核心 Jar 包（如 <code>nacos-discovery</code>）。其初始化逻辑依赖 <strong>Spring Boot SPI 机制</strong>，核心流程如下：</p><ul><li>在 <code>META-INF/spring.factories</code> 中配置自动配置类（如服务发现场景的 <code>NacosDiscoveryAutoConfiguration</code>）；</li><li>启用 Jar 包时，Spring 容器通过 <code>@EnableAutoConfiguration</code> 触发自动配置类加载；</li><li>自动配置类初始化 <code>NacosServiceRegistry</code>（服务注册）、<code>NacosDiscoveryClient</code>（服务发现）等核心组件，并向 Nacos 服务端发起请求，建立基础通信链路。</li></ul><h2 id="二、服务注册流程与高并发设计"><a href="#二、服务注册流程与高并发设计" class="headerlink" title="二、服务注册流程与高并发设计"></a>二、服务注册流程与高并发设计</h2><h3 id="1-核心注册流程"><a href="#1-核心注册流程" class="headerlink" title="1. 核心注册流程"></a>1. 核心注册流程</h3><ol><li>客户端封装服务信息（IP、端口、服务名等）为 <code>Instance</code> 对象，发送注册请求至服务端；</li><li>服务端接收请求后，先将 <code>Instance</code> 存入 <code>BlockingQueue</code> 阻塞队列，作为请求缓冲层；</li><li>后台专用线程从队列中持续取出 <code>Instance</code>，写入注册表（嵌套 <code>Map</code> 结构：<code>serviceName -&gt; cluster -&gt; Instance</code>）。</li></ol><h3 id="2-高并发支撑策略"><a href="#2-高并发支撑策略" class="headerlink" title="2. 高并发支撑策略"></a>2. 高并发支撑策略</h3><ul><li><strong>阻塞队列缓冲</strong>：通过“生产者-消费者”模式解耦请求接收与数据写入，避免直接操作注册表导致的锁竞争；</li><li><strong>读写分离架构</strong>：<ul><li>写操作（注册&#x2F;更新）：拷贝目标服务的 <code>Instance</code> 集合（<code>Set</code>），在副本中修改，不影响原集合；</li><li>读操作（服务发现）：直接从原 <code>Set</code> 读取数据，保证查询无阻塞；</li></ul></li><li><strong>原子替换</strong>：修改完成后，用新 <code>Set</code> 原子替换原 <code>Set</code>，兼顾数据一致性与并发效率。</li></ul><h2 id="三、心跳检测机制"><a href="#三、心跳检测机制" class="headerlink" title="三、心跳检测机制"></a>三、心跳检测机制</h2><h3 id="1-客户端心跳发送"><a href="#1-客户端心跳发送" class="headerlink" title="1. 客户端心跳发送"></a>1. 客户端心跳发送</h3><p>服务实例注册成功后，客户端默认每 <strong>5 秒</strong> 向 Nacos 服务端发送心跳请求，携带实例 ID 等唯一标识信息。</p><h3 id="2-服务端健康检查"><a href="#2-服务端健康检查" class="headerlink" title="2. 服务端健康检查"></a>2. 服务端健康检查</h3><p>服务端维护每个实例的“最后心跳时间”，通过时间差判断实例健康状态：</p><ul><li>若 <code>当前时间 - 最后心跳时间 &gt; 15 秒</code>：标记实例为不健康（<code>healthy = false</code>），服务发现时不返回该实例；</li><li>若 <code>当前时间 - 最后心跳时间 &gt; 30 秒</code>：直接从注册表中移除实例，视为服务下线。</li></ul><h2 id="四、集群-CP-模式与-Raft-协议"><a href="#四、集群-CP-模式与-Raft-协议" class="headerlink" title="四、集群 CP 模式与 Raft 协议"></a>四、集群 CP 模式与 Raft 协议</h2><h3 id="1-CP-模式适用场景"><a href="#1-CP-模式适用场景" class="headerlink" title="1. CP 模式适用场景"></a>1. CP 模式适用场景</h3><p>通过配置 <code>nacos.core.protocol=cp</code> 开启 CP 模式，适用于数据一致性要求极高的场景（如金融领域服务注册）。</p><h3 id="2-Raft-协议核心作用"><a href="#2-Raft-协议核心作用" class="headerlink" title="2. Raft 协议核心作用"></a>2. Raft 协议核心作用</h3><p>服务注册、实例状态变更等操作会触发 Raft 协议，保障集群数据一致性：</p><ul><li><strong>Leader 选举</strong>：集群节点通过 Raft 选举产生 Leader，由 Leader 统一处理客户端请求并协调数据同步；</li><li><strong>日志复制</strong>：Leader 将数据变更记录为日志，同步至所有 Follower 节点，待多数节点确认后才提交变更（如写入注册表）；</li><li>基于 Raft 协议，Nacos 集群在节点故障、网络分区时仍能保证数据一致，实现高可靠服务治理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud OpenFeign 学习笔记</title>
      <link href="/2025/08/26/Spring-Cloud-OpenFeign-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/26/Spring-Cloud-OpenFeign-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一、服务调用方式对比<br>在 Spring Cloud 中，引入 OpenFeign 之前，常使用 Ribbon（负载均衡器）与 RestTemplate 进行服务间调用。但此方式代码耦合性强，维护性与可读性差，修改不便。而 Spring Cloud OpenFeign 采用依赖注入方式调用，如同调用本地 service，极大提升了代码的简洁性与可维护性。</p><p>二、OpenFeign 使用步骤</p><ol><li>引入依赖：在项目中引入 OpenFeign 的相关 Maven 依赖。</li><li>添加注解：在 Spring Boot 启动类上添加 @EnableFeignClients 注解，开启 Feign 客户端功能。</li><li>定义接口：</li></ol><ul><li>方式一：在自定义的 SDK 中定义带有 @FeignClient 注解的接口。</li><li>方式二：自行定义 OpenFeign 接口，该接口用于声明服务调用方法。</li></ul><ol start="4"><li>注入使用：将定义好的 Feign 接口注入到需要调用的地方，即可实现服务间的远程调用。<br>三、OpenFeign 接口参数处理</li></ol><ul><li>默认 <strong>@RequestBody</strong>：若接口参数未添加其他注解，OpenFeign 默认添加 @RequestBody 注解。但 @RequestBody 通常只能接收一个对象，传入多个对象会报错。</li><li>GET 请求参数：对于 GET 类型请求，可写多个基本类型参数，这些参数会自动拼接到 URL 上。若想用 form 表单形式传递参数，可使用 @SpringQueryMap 注解，同样会将参数拼接到 URL 上。<br>四、OpenFeign 结构与原理</li><li>服务端与调用端：<ul><li>服务提供端：通过在接口方法上添加 @FeignClient 注解，将服务封装成接口方法，并打包成 SDK。</li><li>服务调用端：引入服务提供端的 SDK，在 Spring Boot 启动时，利用 JDK 动态代理生成代理对象，并注入到 Bean 容器中。当调用接口方法时，通过 InvocationHandler 调用处理器进行远程调用。</li></ul></li><li>处理流程：<ul><li>调用接口方法后，<strong>Contract</strong> 根据注解声明的规则解析底层的 <strong>MethodHandler</strong>。</li><li>MethodHandler 底层调用 <strong>RequestTemplate</strong>，<strong>RequestTemplate</strong> 内部实现了编码和解码功能。服务发起端对请求进行编码，服务调用端在解析返回结果时进行解码。</li><li>最外层有 Interceptors 拦截器，用于对请求和响应进行拦截，例如记录日志等操作。</li><li>Feign Client 基于负载均衡器和重试器进行策略调控。请求到达服务调用端后，经过解码，<strong>MethodHandler</strong> 根据规则映射找到调用的方法，通过处理器获取 InvocationHandler 的调用结果，并解析成 Response 的 Bean。<br>五、OpenFeign 增强方式<br>（一）日志增强</li></ul></li><li>配置 Feign 的 Config Bean 对象：通过配置该 Bean 对象可实现日志增强。</li><li>YAML 文件配置：在 YAML 文件中进行配置，更为灵活且支持配置中心实时更改。</li><li>日志级别：<ul><li>NONE：不记录日志。</li><li>BASIC：仅记录请求方法、URL、响应状态代码及执行时间。</li><li>HEADERS：在 BASIC 基础上记录请求和响应的 Header。</li><li>FULL：全量记录请求、响应的 Header、Body 及原始数据。<br>（二）HTTP 连接优化</li></ul></li><li>引入 Feign HC5：OpenFeign 默认的 HTTP 连接无连接池，性能较差。引入 <strong>Feign HC5</strong>（Apache HTTP5 的实现）依赖，其内部自带连接池，可优化调用效率，减少连接的频繁创建与销毁。由于 OpenFeign 的自动配置类已将相关属性默认配置为启用状态，因此即便不在 YAML 中配置，引入依赖后也会生效。</li><li>替换为 OKHTTP：除 Feign HC5 外，还可引入 OKHTTP 依赖，并在 YAML 中开启 OKHTTP 配置，将底层 HTTP 请求替换为 OKHTTP。<br>（三）压缩配置</li><li>gzip 压缩：OpenFeign 支持 gzip 压缩配置，当请求超过某个阈值（如 1024 字节），可在 YAML 中开启 gzip 压缩，并配置需要压缩的请求类型及最小压缩阈值等参数，以优化请求体大小和传输效率。</li><li>OKHTTP 特殊情况：若使用 OKHTTP 作为底层 HTTP 请求，因其内部默认使用 transparent 压缩方式，一般无需额外配置 gzip 压缩。<br>（四）自定义编解码器<br>OpenFeign 提供扩展点，可通过实现 Encoder 和 Decoder 接口来自定义编解码器，并在 YAML 中进行配置。</li></ul><p>（五）拦截器实现</p><ul><li>BasicAuthRequestInterceptor：通过注入该 Bean 并进行配置来实现拦截器功能，但此方式灵活性欠佳。</li><li>实现 RequestInterceptor 接口：推荐使用此方式，通过实现接口来定义拦截逻辑，更加灵活。<br>六、YAML 基本配置示例<br>feign:<br>client:<br>config:<br>default:<br>loggerLevel: FULL # 日志级别设置为 FULL<br>httpclient:<br>enabled: true # 启用 Feign HC5 连接池<br>max-connections: 200 # 最大连接数<br>max-connections-per-route: 50 # 每个路由的最大连接数<br>compression:<br>request:<br>enabled: true # 开启请求压缩<br>mime-types: text&#x2F;xml,application&#x2F;xml,application&#x2F;json # 需要压缩的请求类型<br>min-request-size: 1024 # 最小压缩阈值<br>okhttp:<br>enabled: true # 启用 OKHTTP</li></ul><p>在对 OpenFeign 进行配置时，优先考虑 YAML 配置方式，因其可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客文章发布教程</title>
      <link href="/2025/05/03/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/"/>
      <url>/2025/05/03/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客文章发布教程"><a href="#Hexo-博客文章发布教程" class="headerlink" title="Hexo 博客文章发布教程"></a>Hexo 博客文章发布教程</h1><p>本教程将详细介绍如何在 Hexo 博客中创建和发布文章，包括文章的基本结构、常用配置和发布流程。</p><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><h3 id="1-使用命令行创建"><a href="#1-使用命令行创建" class="headerlink" title="1. 使用命令行创建"></a>1. 使用命令行创建</h3><p>在博客根目录下，使用以下命令创建新文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>这将在 <code>source/_posts</code> 目录下创建一个新的 Markdown 文件，文件名格式为：<code>年-月-日-文章标题.md</code></p><h3 id="2-手动创建"><a href="#2-手动创建" class="headerlink" title="2. 手动创建"></a>2. 手动创建</h3><p>你也可以直接在 <code>source/_posts</code> 目录下手动创建 Markdown 文件，但需要确保文件名格式正确。</p><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>每篇文章都包含两个主要部分：</p><ol><li><strong>Front-matter</strong>：文章头部配置</li><li><strong>正文内容</strong>：文章主体内容</li></ol><h3 id="Front-matter-配置"><a href="#Front-matter-配置" class="headerlink" title="Front-matter 配置"></a>Front-matter 配置</h3><p>Front-matter 是文章开头的配置部分，使用 <code>---</code> 包裹。常用配置项包括：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">年-月-日</span> <span class="string">时:分:秒</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">封面图片路径</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>常用配置项说明：</p><ul><li><code>title</code>: 文章标题</li><li><code>date</code>: 文章创建时间</li><li><code>tags</code>: 文章标签，可以设置多个</li><li><code>categories</code>: 文章分类</li><li><code>cover</code>: 文章封面图片</li><li><code>comments</code>: 是否开启评论（默认为 true）</li></ul><h3 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h3><p>正文使用 Markdown 语法编写，支持：</p><ul><li>标题</li><li>段落</li><li>列表</li><li>代码块</li><li>图片</li><li>表格</li><li>等等</li></ul><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>在发布文章前，建议先在本地预览：</p><ol><li><p>启动本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</p></li></ol><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="1-生成静态文件"><a href="#1-生成静态文件" class="headerlink" title="1. 生成静态文件"></a>1. 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="2-部署到服务器"><a href="#2-部署到服务器" class="headerlink" title="2. 部署到服务器"></a>2. 部署到服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一键生成并部署</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="文章写作建议"><a href="#文章写作建议" class="headerlink" title="文章写作建议"></a>文章写作建议</h2><ol><li><strong>保持结构清晰</strong>：使用合适的标题层级</li><li><strong>添加适当的标签</strong>：便于文章分类和检索</li><li><strong>使用图片</strong>：适当添加图片使文章更生动</li><li><strong>代码格式化</strong>：使用代码块展示代码</li><li><strong>预览检查</strong>：发布前务必预览检查</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p><strong>文章不显示</strong>：</p><ul><li>检查文件名格式是否正确</li><li>确保 Front-matter 格式正确</li><li>尝试清理缓存后重新生成</li></ul></li><li><p><strong>图片不显示</strong>：</p><ul><li>检查图片路径是否正确</li><li>确保图片文件存在</li></ul></li><li><p><strong>格式问题</strong>：</p><ul><li>检查 Markdown 语法是否正确</li><li>确保缩进正确</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，你应该已经掌握了在 Hexo 博客中创建和发布文章的基本方法。记住，好的文章不仅需要好的内容，还需要正确的格式和配置。如果你有任何问题，欢迎在评论区留言讨论！ </p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日学习笔记：Sentinel 核心原理与关键算法</title>
      <link href="/2024/05/20/Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/20/Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>一、Sentinel 对外部请求的感知机制</p><p>Sentinel 对请求的感知依赖于 Web 框架适配与拦截器机制，核心是通过自动装配实现请求链路的透明化监控，为后续流量控制提供数据基础。</p><ol><li>实现基础：SPI 与 Spring Boot 自动装配</li></ol><p>Sentinel 提供  sentinel-spring-webmvc-adapter  等适配模块，基于 Spring Boot 的 SPI 机制（META-INF&#x2F;spring.factories） 实现自动配置，无需手动注入拦截器，降低集成成本。</p><ol start="2"><li>启动流程</li></ol><ul><li>Spring Boot 容器启动时，Sentinel 自动加载并注册配置类 SentinelWebAutoConfiguration（用户原表述中“config-auto configuration”修正为标准类名）。</li><li>该配置类向 Spring 容器注入 SentinelWebInterceptor（网络拦截器），拦截所有符合规则的 HTTP 请求（默认拦截 &#x2F;* 路径，可通过配置自定义）。</li></ul><ol start="3"><li>请求处理逻辑</li></ol><ul><li>拦截器的  preHandle  方法（请求处理前执行）会提取请求关键信息：URL 路径（如 &#x2F;api&#x2F;user）、请求来源（serviceName）、HTTP 方法（GET&#x2F;POST）等。</li><li>将提取的信息封装为 ResourceEntry 对象（Sentinel 中的“资源”载体，每个 ResourceEntry 对应一个可监控的请求节点），并将该资源的调用数据（如调用次数、耗时）上报至 Sentinel 核心引擎。</li><li>核心引擎基于 ResourceEntry 的数据感知请求链路，为后续的限流、熔断、降级规则提供“靶向监控”能力（仅针对已感知的资源生效规则）。</li></ul><p>二、Sentinel 核心算法</p><p>Sentinel 的流量控制、熔断降级功能依赖三大核心算法，分别对应“实时统计”“匀速排队”“突发流量兼容”三类场景，覆盖不同业务需求。</p><ol><li>滑动时间窗口算法（核心统计算法）</li></ol><p>核心思想</p><p>基于 前缀和思想 实现实时流量统计：将“一段时间区间”（如1秒）划分为多个连续的“小格子”（如10个100ms的格子），每个格子存储该时间段内的请求数、QPS、异常数等指标；统计时通过“当前时间对应的格子数据 + 未过期格子数据总和”计算总流量，避免传统“固定时间窗口”的统计偏差（如1秒窗口在0:59和1:01的瞬时高流量无法识别）。</p><p>底层实现</p><ul><li>数据存储：将时间窗口抽象为  MetricBucket  类（存储 pass&#x2F;block&#x2F;exception 等指标），用数组（ MetricArray ）存储多个  MetricBucket ，每个数组元素对应一个“小格子”（格子粒度可配置，粒度越细统计越精准，但内存消耗略高）。</li><li>初始化逻辑：首次有请求进入时，初始化时间窗口数组，确定每个格子的时间范围（如第1个格子对应 0-100ms，第2个对应 100-200ms）。</li><li>时钟回拨处理：若服务器时钟发生回拨（如窗口终止时间 &lt; 当前时间），直接丢弃过期格子数据并创建新窗口，避免因时钟异常导致的统计错误（正常生产环境极少触发，属于容错机制）。</li><li>适用场景：所有需要实时统计流量的场景（如 QPS 限流、并发数控制），是 Sentinel 最基础的算法。</li></ul><ol start="2"><li>漏桶算法（匀速排队机制）</li></ol><p>核心思想</p><p>模拟“漏桶倒水”过程：请求像“水流”一样进入漏桶，漏桶以 固定速率（如每秒100个请求）将请求“漏出”到业务系统；若请求进入速率超过漏桶漏出速率，多余请求会在桶内排队（或直接丢弃，取决于配置），确保业务系统接收的请求速率平稳，避免瞬时高负载。</p><p>处理逻辑</p><ul><li>计算请求等待时间：根据“当前桶内排队请求数”和“漏出速率”，计算当前请求需等待的最小时间（如桶内有5个请求，漏出速率100个&#x2F;秒，则需等待 5*10ms&#x3D;50ms）。</li><li>等待与放行：若等待时间在“最大排队时间”（如100ms）内，请求会睡眠至等待时间结束后放行；若等待时间超出最大排队时间，直接放行（避免请求排队过久导致超时）。</li><li>超时拦截：校验“请求到达时间 + 等待时间”是否超过“请求超时时间”，若已超时则直接拦截（返回 block 信号），避免无效等待。</li><li>适用场景：要求请求严格匀速处理的场景（如数据库写入、第三方接口调用，避免瞬时请求压垮下游服务）。</li></ul><ol start="3"><li>令牌桶算法（缓存预热机制）</li></ol><p>核心思想</p><p>模拟“令牌生成与消耗”过程：Sentinel 按 预设速率（可配置） 定时向“令牌桶”中放入令牌（如每秒生成100个令牌），请求必须从桶中获取1个令牌才能放行；若桶内无令牌，请求会被限流（返回降级&#x2F;熔断信息）。同时支持“缓存预热（冷启动）”，避免服务刚启动时令牌生成过多导致的瞬时高负载。</p><p>处理逻辑</p><ul><li>令牌生成：令牌桶有固定容量（如200个令牌），当桶内令牌数未达容量时，按“预热速率”生成令牌（预热阶段速率从低到高逐步提升，如初始50个&#x2F;秒，10秒后升至100个&#x2F;秒）；当桶满时，新生成的令牌直接丢弃。</li><li>请求处理：请求到达时，先检查桶内是否有剩余令牌：</li><li>若有令牌：获取1个令牌，请求正常放行，并记录请求数据。</li><li>若无令牌：触发限流逻辑，返回降级响应（如默认提示“系统繁忙，请稍后再试”，可自定义降级页面）。</li><li>突发流量兼容：令牌桶的容量决定了最大突发流量处理能力（如桶容量200，当瞬时有200个请求时，可一次性消耗所有令牌，后续请求需等待新令牌生成）。</li><li>适用场景：允许一定突发流量的场景（如 API 网关、用户登录接口，既控制长期流量，又兼容短时间内的流量峰值）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> 流量控制 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Gateway 学习总结（优化版）</title>
      <link href="/2024/05/20/Gateway%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/20/Gateway%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、核心原理补充（易混淆点）"><a href="#一、核心原理补充（易混淆点）" class="headerlink" title="一、核心原理补充（易混淆点）"></a>一、核心原理补充（易混淆点）</h2><h3 id="1-响应式架构本质"><a href="#1-响应式架构本质" class="headerlink" title="1. 响应式架构本质"></a>1. 响应式架构本质</h3><p>Spring Cloud Gateway 基于 WebFlux 框架实现，底层依赖 Netty 实现异步非阻塞通信，与传统 Spring MVC 框架存在本质区别：</p><ul><li>严禁引入 <code>spring-boot-starter-web</code> 依赖，否则会因 Servlet API 与 Netty 通信模型冲突导致启动失败</li><li>核心优势：高并发场景下资源利用率更高，适合作为微服务入口网关承载大流量</li></ul><h3 id="2-路由核心组件逻辑"><a href="#2-路由核心组件逻辑" class="headerlink" title="2. 路由核心组件逻辑"></a>2. 路由核心组件逻辑</h3><ul><li><strong>断言（Predicate）</strong>：路由匹配的”判断条件”，支持路径、请求头、参数等多种匹配规则，多个断言需<strong>同时满足</strong>才会触发路由</li><li><strong>过滤器（Filter）</strong>：路由执行的”动作处理器”，按顺序对请求&#x2F;响应进行加工<ul><li>局部过滤器：仅对当前路由生效</li><li>全局过滤器（Global Filter）：对所有路由生效，适合实现认证、限流等通用功能</li></ul></li></ul><h2 id="二、实战配置核心要点"><a href="#二、实战配置核心要点" class="headerlink" title="二、实战配置核心要点"></a>二、实战配置核心要点</h2><h3 id="1-基础依赖配置（Spring-Boot-3-x）"><a href="#1-基础依赖配置（Spring-Boot-3-x）" class="headerlink" title="1. 基础依赖配置（Spring Boot 3.x）"></a>1. 基础依赖配置（Spring Boot 3.x）</h3><pre><code class="xml">&lt;!-- Gateway 核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 服务发现（配合 Nacos 使用） --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 负载均衡（配合 lb:// 协议使用） --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;  2. 核心配置示例（application.yml） spring:  cloud:    gateway:      # 路由配置      routes:        - id: user-service-route  # 路由唯一标识          uri: lb://user-service  # 目标服务（lb:// 表示启用负载均衡）          predicates:             # 路由断言（匹配条件）            - Path=/user/**       # 路径匹配：以 /user 开头的请求            - Method=GET,POST     # 限制请求方法          filters:                # 路由过滤器            - AddRequestHeader=X-Request-Source, gateway  # 添加请求头            - AddRequestParameter=version, v1              # 添加请求参数            - name: RequestRateLimiter                     # 限流配置              args:                redis-rate-limiter.replenishRate: 10       # 令牌生成速率                redis-rate-limiter.burstCapacity: 20       # 令牌桶容量      # 全局跨域配置      globalcors:        cors-configurations:          &#39;[/**]&#39;:            allowed-origins:               - &quot;https://example.com&quot;              - &quot;https://api.example.com&quot;            allowed-methods: &quot;*&quot;  # 允许所有请求方法            allowed-headers: &quot;*&quot;  # 允许所有请求头            allow-credentials: true  # 允许携带cookie            max-age: 3600         # 预检请求缓存时间（秒）  三、进阶功能实现指南 1. 自定义全局过滤器 推荐实现  GlobalFilter + Ordered  接口，实现全路由生效的通用功能： @Componentpublic class LoggingFilter implements GlobalFilter, Ordered &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 前置处理：记录请求信息        log.info(&quot;Request: &#123;&#125; &#123;&#125;&quot;,                  exchange.getRequest().getMethod(),                  exchange.getRequest().getPath());                // 继续执行过滤器链        return chain.filter(exchange)            // 后置处理：记录响应信息            .doFinally(signal -&gt; log.info(&quot;Response: &#123;&#125;&quot;,                                           exchange.getResponse().getStatusCode()));    &#125;    @Override    public int getOrder() &#123;        return -10;  // 数值越小，执行优先级越高    &#125;&#125;  2. 令牌桶限流实现 基于 Redis + Lua 脚本实现分布式限流，核心依赖： &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;  关键配置：通过  KeyResolver  指定限流维度（如IP、用户ID） @Beanpublic KeyResolver ipKeyResolver() &#123;    return exchange -&gt; Mono.just(        exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()    );&#125;  3. 请求生命周期流程 客户端请求 → HandlerMapping（路由匹配） → GatewayWebHandler（构建过滤器链） → 「前置过滤」 → NettyRoutingFilter（转发请求到目标服务） → 「后置过滤」 → 返回响应给客户端  四、常见问题解决方案 问题场景 排查方向 解决方案 路由匹配失效 1. 断言条件冲突 2. 路由ID重复 3. 依赖冲突 1. 调整断言顺序 2. 保证路由ID唯一性 3. 移除 spring-boot-starter-web 依赖 跨域配置不生效 1. 允许源与credentials冲突 2. 路径匹配不全 1. 明确指定allowed-origins而非* 2. 用&#39;/**&#39;覆盖所有路径 过滤器执行顺序异常 1. Ordered接口实现错误 2. 过滤器类型冲突（局部/全局） 1. 统一通过getOrder()定义顺序 2. 全局过滤器优先使用较低order值 服务路由超时 1. 后端服务响应慢 2. 超时配置缺失 1. 优化后端服务性能 2. 配置 connect-timeout 和 response-timeout  五、生产环境部署建议 1. 高可用部署- 多实例集群部署，配合 Nginx 实现负载均衡- 避免单点故障：Redis、服务注册中心等依赖组件同样需要集群部署2. 性能优化- 调整 Netty 线程池参数： spring.cloud.gateway.netty.worker-threads - 启用连接池： spring.cloud.gateway.httpclient.pool.enabled=true - 合理设置超时时间，避免长连接阻塞3. 监控与运维- 集成 Spring Boot Actuator 暴露监控端点：management:  endpoints:    web:      exposure:        include: gateway,health,info,metrics - 配置日志输出关键信息：路由匹配结果、过滤器执行耗时、异常堆栈等4. 安全防护- 前置 WAF 防护Web攻击- 实现 JWT 令牌验证过滤器拦截未授权请求- 配置 HTTPS： spring.cloud.gateway.httpserver.ssl.enabled=true## 六、与其他Spring Cloud组件集成### 1. 服务发现集成（Nacos）通过Nacos实现服务自动注册与发现，路由配置示例：```yamlspring:  cloud:    gateway:      discovery:        locator:          enabled: true        # 启用服务发现路由          lower-case-service-id: true  # 服务名转小写          predicates:            - Path=/nacos/**  # 自动生成以服务名开头的路由  2. 链路追踪（Sleuth） 添加依赖： &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;&lt;/dependency&gt;  配置日志格式（logback.xml）： &lt;encoder&gt;    &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [$&#123;spring.application.name:&#125;,%X&#123;traceId:-&#125;,%X&#123;spanId:-&#125;] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;&lt;/encoder&gt;  3. 服务降级（Resilience4j） 添加依赖： &lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-reactor-resilience4j&lt;/artifactId&gt;&lt;/dependency&gt;  配置降级逻辑（自定义过滤器）： @Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;    return builder.routes()        .route(&quot;user-service&quot;, r -&gt; r            .path(&quot;/user/**&quot;)            .filters(f -&gt; f                .circuitBreaker(c -&gt; c                    .name(&quot;userService&quot;)                    .fallbackUri(&quot;forward:/fallback/user&quot;)                )            )            .uri(&quot;lb://user-service&quot;)        )        .build();&#125;  七、性能调优策略 1. Netty线程池优化 spring:  cloud:    gateway:      httpclient:        # 连接池配置        pool:          max-concurrent-connections: 2000  # 最大并发连接数          max-pending-connections: 500     # 最大等待连接数        # 超时配置        connect-timeout: 1000ms        response-timeout: 5000ms      netty:        worker-threads: 40  # 根据CPU核心数调整（推荐公式：CPU核心数 * 2）  2. 缓存优化 // 配置缓存管理器@Beanpublic RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer(RedisConnectionFactory connectionFactory) &#123;    return builder -&gt; builder        .withCacheConfiguration(&quot;route-cache&quot;,            RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofHours(1))                .disableCachingNullValues());&#125;// 在路由配置中使用缓存spring:  cloud:    gateway:      routes:        - id: cached-route          uri: lb://product-service          predicates:            - Path=/product/**          metadata:            caching:              cacheName: route-cache              cacheKey: &quot;#&#123;request.path&#125;&quot;  八、版本升级注意事项 1. Spring Boot 3.x 升级要点 - 必须使用 Java 17+- WebFlux 默认使用 Reactor 3.5+- 移除  spring-boot-starter-actuator  依赖，改为  spring-boot-starter-management  2. Spring Cloud Gateway 4.x 新特性 - 支持 WebFlux.fn 函数式路由定义- 增强的限流支持（RateLimiter 改进）- 新增 WebClient 集成方式 3. 依赖版本矩阵 组件 Spring Boot 3.x 版本 Spring Cloud 版本 Gateway 3.2.0+ 2023.0.3+ Nacos Discovery 0.13.0+ 2023.0.3+ LoadBalancer 3.2.0+ 2023.0.3+  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 微服务架构 </category>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务网关 </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
