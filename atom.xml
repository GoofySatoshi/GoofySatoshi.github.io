<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoofySatoshi&#39;s Blog</title>
  
  <subtitle>生活、技术与阅读</subtitle>
  <link href="https://goofysatoshi.github.io/atom.xml" rel="self"/>
  
  <link href="https://goofysatoshi.github.io/"/>
  <updated>2025-09-04T15:08:01.038Z</updated>
  <id>https://goofysatoshi.github.io/</id>
  
  <author>
    <name>GoofySatoshi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel源码学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/09/02/Sentinel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/09/02/Sentinel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-09-02T18:05:00.000Z</published>
    <updated>2025-09-04T15:08:01.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sentinel源码学习笔记"><a href="#Sentinel源码学习笔记" class="headerlink" title="Sentinel源码学习笔记"></a>Sentinel源码学习笔记</h1><p>一、客户端与服务端的交互流程</p><p>1. 连接建立：客户端启动时通过配置的服务端地址（如  spring.cloud.sentinel.transport.dashboard.server ）与Sentinel Dashboard建立长连接（HTTP长轮询或WebSocket），定期发送心跳包保持连接。<br>2. 数据同步：</p><ul><li>客户端将实时统计的监控数据（QPS、异常数等）通过长连接上报给服务端，服务端在控制台展示实时监控图表。</li><li>服务端通过长连接向客户端推送规则配置（流控、熔断等），客户端接收后更新本地规则缓存并生效。<br>3. 指令交互：服务端可通过控制台手动触发客户端规则更新、熔断状态重置等指令，客户端接收后执行对应操作并返回结果。</li></ul><p>二、自动配置类（以Spring Cloud整合为例）的核心逻辑</p><p> SentinelAutoConfiguration  是核心自动配置类，主要执行以下操作：</p><p>1. 初始化核心组件：注册  SentinelResourceAspect  切面，通过AOP拦截被  @SentinelResource  注解标记的资源（方法&#x2F;接口），触发责任链执行。<br>2. 规则加载：通过  DataSource  加载预设规则（如Nacos、Apollo配置的流控&#x2F;熔断规则），初始化到  RuleManager  中。<br>3. 适配Spring生态：注册  SentinelWebInterceptor  拦截HTTP请求，将URL自动作为资源进行监控；适配Feign、Dubbo等组件，自动拦截远程调用作为资源。<br>4. 异常处理：注册  SentinelExceptionHandler ，统一处理流控、熔断等异常（如  BlockException ），返回自定义响应。</p><p>三、责任链（ProcessorSlotChain）的构建与核心插槽</p><ol><li>构建流程</li></ol><ul><li>客户端初始化时， SlotChainProvider  会通过SPI机制加载默认插槽链，并允许通过  SlotChainBuilder  自定义扩展。</li><li>默认链顺序（按优先级执行）： NodeSelectorSlot  →  ClusterBuilderSlot  →  LogSlot  →  StatisticSlot  →  AuthoritySlot  →  FlowSlot  →  DegradeSlot  →  SystemSlot （顺序固定）。</li></ul><ol start="2"><li>关键插槽工作原理</li></ol><ul><li>StatisticSlot（统计插槽）：责任链核心，负责收集资源实时指标（QPS、响应时间、异常数等），为后续插槽提供数据支持；通过  ArrayMetric  维护滑动窗口统计，记录每个时间窗口的请求数、成功数等。</li><li>FlowSlot（流控插槽）：使用  StatisticSlot  提供的QPS&#x2F;线程数数据，与预设流控规则对比，超过阈值则抛出  FlowException  拦截请求。</li><li>DegradeSlot（熔断插槽）：通过  StatisticSlot  获取异常比例&#x2F;数、响应时间等数据，判断是否触发熔断（OPEN状态），拦截请求并抛出  DegradeException 。</li><li>NodeSelectorSlot：为资源创建唯一统计节点（ DefaultNode ），用于区分不同上下文的资源调用（如不同服务调用同一接口）。</li></ul><p>四、断路器（熔断）实现逻辑</p><ol><li>状态机设计</li></ol><ul><li>CLOSED：正常允许请求， DegradeSlot  实时统计异常比例&#x2F;数、响应时间。</li><li>OPEN：触发熔断（如异常比例超阈值），拦截所有请求；持续  waitTimeout  时间后转为 HALF_OPEN。</li><li>HALF_OPEN：允许少量请求通过，请求成功则转为 CLOSED，失败则重回 OPEN。</li></ul><ol start="2"><li>判断逻辑</li></ol><ul><li>基于异常比例： （异常数 &#x2F; 总请求数）&gt; 阈值  且 总请求数≥最小请求数。</li><li>基于响应时间：慢调用比例（响应时间&gt;阈值的请求数&#x2F;总请求数）&gt; 阈值。</li></ul><p>五、限流实现逻辑</p><p>1.  FlowSlot  在责任链中检查  StatisticSlot  统计的实时QPS&#x2F;线程数，若超过预设规则阈值，直接抛出  FlowException  拦截请求。</p><p>六、Fallback（降级）逻辑</p><p>1. 触发场景：当资源被限流（ FlowException ）、熔断（ DegradeException ）或抛出业务异常时，执行预设的fallback逻辑。<br>2. 实现方式：</p><ul><li>注解指定： @SentinelResource(fallback &#x3D; “xxx”) ，方法  xxx  需与原方法参数一致，可接收异常参数。</li><li>全局配置：通过  GlobalFallback  定义全局fallback，统一处理未指定局部fallback的资源。<br>3. 执行流程： SentinelResourceAspect  拦截到  BlockException  或业务异常后，通过反射调用fallback方法，返回降级结果。</li></ul><p>七、降级逻辑（与熔断的区别）</p><ul><li>熔断（Degrade）：服务端主动触发的保护机制（如异常率过高），属于“被动降级”，状态随指标自动切换（CLOSED→OPEN→HALF_OPEN→CLOSED）。</li><li>限流（Flow）：主动限制请求量以防止资源耗尽，属于“主动降级”，触发条件是实时请求量超阈值。</li><li>共性：两者最终均通过抛出异常被fallback逻辑捕获，返回降级响应，避免服务雪崩。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Sentinel源码学习笔记&quot;&gt;&lt;a href=&quot;#Sentinel源码学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Sentinel源码学习笔记&quot;&gt;&lt;/a&gt;Sentinel源码学习笔记&lt;/h1&gt;&lt;p&gt;一、客户端与服务端的交互流程&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="中间件学习" scheme="https://goofysatoshi.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/Sentinel/"/>
    
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/tags/Sentinel/"/>
    
    <category term="源码解析" scheme="https://goofysatoshi.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="中间件" scheme="https://goofysatoshi.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 控制台用法与工作原理学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/09/01/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%94%A8%E6%B3%95%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/09/01/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%94%A8%E6%B3%95%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-09-01T15:05:00.000Z</published>
    <updated>2025-09-04T15:08:01.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sentinel-控制台用法与工作原理学习笔记"><a href="#Sentinel-控制台用法与工作原理学习笔记" class="headerlink" title="Sentinel 控制台用法与工作原理学习笔记"></a>Sentinel 控制台用法与工作原理学习笔记</h1><h2 id="一、流控规则配置"><a href="#一、流控规则配置" class="headerlink" title="一、流控规则配置"></a>一、流控规则配置</h2><ol><li><strong>基础控制维度</strong>：支持对 QPS（每秒查询率）和并发线程数进行控制。</li><li><strong>三种流控模式</strong>：<ul><li>直接关系：直接针对接口配置流量规则，可设置 QPS 或并发线程数阈值，当触发阈值时直接对该接口进行限流。</li><li>关联关系：适用于存在关联的服务，例如调用 A 服务的请求过多时，可配置当 A 服务的 QPS 或并发线程数达到阈值后，对关联的 B 服务进行流量控制，避免因 A 服务过载影响 B 服务。</li><li>链路关系：针对具有调用关系的链路进行配置，可对链路上的特定节点或多个节点限流，进而控制整个链路的流量。需注意：1.7 版本后，链路控制功能需在配置文件中设置 <code>WebContextUtile</code> 参数为 <code>false</code> 才能生效。</li></ul></li><li><strong>三种流控类型</strong>：<ul><li>快速失败：当接口请求超过设定阈值（QPS 或并发线程数）时，直接返回失败结果。</li><li>接口预热：服务启动时，通过模拟线程加载缓存等资源，避免刚启动就被大量流量击垮，逐渐提升接口处理能力至阈值。</li><li>排队等待：可设置超时时间，请求会进入队列等待处理。若超时则被剔除并返回失败；未超时则正常响应。例如，阈值设为 20 时，每秒处理 20 个请求，超出部分进入队列等待。</li></ul></li></ol><h2 id="二、熔断降级配置"><a href="#二、熔断降级配置" class="headerlink" title="二、熔断降级配置"></a>二、熔断降级配置</h2><p>基于三种情况设置阈值，触发后进入熔断状态，熔断时间结束后恢复正常：</p><ol><li>慢调用比例：当慢调用（如慢查询接口）占比超过配置阈值时，触发熔断。</li><li>异常比例：接口异常请求占比超过阈值时，触发熔断。</li><li>异常数：接口异常请求数量达到阈值时，触发熔断。</li></ol><h2 id="三、热点限流"><a href="#三、热点限流" class="headerlink" title="三、热点限流"></a>三、热点限流</h2><p>针对接口的热点参数（仅支持 Java 7 种基本数据类型）进行 QPS 配置。例如，查询用户 ID 为 1 的数据是热点，可设置当该参数的 QPS 达到阈值时进行限流。</p><h2 id="四、系统规则限流"><a href="#四、系统规则限流" class="headerlink" title="四、系统规则限流"></a>四、系统规则限流</h2><p>从系统整体层面限制流量，包含五种模式：</p><ol><li>Load：仅对 Linux&#x2F;Unix 机器生效，根据系统负载进行限流。</li><li>RT（响应时间）：当系统整体响应时间超过阈值时，触发限流。</li><li>线程数：限制系统最大支持的并发线程数，超过则限流。</li><li>入口 QPS：限制单位时间内整体进入系统的 QPS，超过则限流。</li><li>CPU 使用率：当 CPU 使用率超过阈值时，触发限流。</li></ol><h2 id="五、授权规则限流"><a href="#五、授权规则限流" class="headerlink" title="五、授权规则限流"></a>五、授权规则限流</h2><p>支持通过黑白名单实现微服务间的调用控制：</p><ul><li>需手动实现 <code>RequestOriginParser</code> 接口，并将其注册为 Spring 管理的 Bean，用于解析请求来源。</li><li>根据解析的来源，结合黑白名单规则，允许或限制微服务间的调用。</li></ul><h2 id="六、集群流控"><a href="#六、集群流控" class="headerlink" title="六、集群流控"></a>六、集群流控</h2><ol><li>基础配置：在流控规则中可选择是否为集群模式，支持单机均摊或整体阈值设置。</li><li>差异化配置：通过 <code>Token Server</code> 和 <code>Token Client</code> 实现，可针对不同机器（如配置高低）设置差异化 QPS 阈值，配置高的机器可适当提高 QPS，配置低的则降低。</li></ol><h2 id="七、工作原理"><a href="#七、工作原理" class="headerlink" title="七、工作原理"></a>七、工作原理</h2><ol><li><strong>核心抽象</strong>：将流量规则控制、集群节点聚簇等功能抽象为一个个 <code>Slot</code>（插槽）。</li><li><strong>责任链模式</strong>：所有插槽构成一条责任链，请求需依次经过链路上的各个插槽检查。</li><li><strong>执行流程</strong>：<ul><li>外部请求进入后，先进行统计簇点构建和监控统计。</li><li>依次经过热点参数限流、系统保护限流、来源访问控制限流、流量控制、熔断降级等插槽的检查。</li><li>若链路上任何一个插槽的限流规则未通过，返回快速失败结果；全部通过则执行接口逻辑。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Sentinel-控制台用法与工作原理学习笔记&quot;&gt;&lt;a href=&quot;#Sentinel-控制台用法与工作原理学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Sentinel 控制台用法与工作原理学习笔记&quot;&gt;&lt;/a&gt;Sentinel 控制台用法与工作</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中间件学习" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/tags/Sentinel/"/>
    
    <category term="流量控制" scheme="https://goofysatoshi.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
    <category term="熔断降级" scheme="https://goofysatoshi.github.io/tags/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/08/31/Sentinel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/08/31/Sentinel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-31T15:56:00.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Sentinel-基础概念与服务雪崩背景"><a href="#一、Sentinel-基础概念与服务雪崩背景" class="headerlink" title="一、Sentinel 基础概念与服务雪崩背景"></a>一、Sentinel 基础概念与服务雪崩背景</h2><h3 id="（一）服务雪崩现象剖析"><a href="#（一）服务雪崩现象剖析" class="headerlink" title="（一）服务雪崩现象剖析"></a>（一）服务雪崩现象剖析</h3><p>服务雪崩是微服务架构中的严重问题：当某服务因高并发不堪重负，其依赖链上的其他服务会受波及，影响层层传递，最终导致大量服务瘫痪。</p><p>服务不可用的核心原因包括：</p><ol><li>程序 Bug：隐藏错误在特定场景（输入、环境、业务）下触发，导致服务异常。</li><li>高并发冲击：突发请求远超服务器承载能力，资源被耗尽，无法及时处理请求。</li><li>硬件故障：服务器硬件老化、损坏等物理问题，直接导致服务停运。</li><li>缓存击穿：热点数据缓存过期瞬间，大量请求穿透缓存直达后端，造成服务压力激增。</li></ol><h3 id="（二）服务雪崩解决方案概述"><a href="#（二）服务雪崩解决方案概述" class="headerlink" title="（二）服务雪崩解决方案概述"></a>（二）服务雪崩解决方案概述</h3><p>应对服务雪崩的常见方案有四类：</p><ol><li>超时机制：为服务调用设超时时间，超时未响应则返回默认结果（如 false），避免调用方长时间等待。</li><li>服务限流：限制单位时间内通过的请求数，拦截超额流量并返回“服务繁忙”提示，保护服务不被压垮。</li><li>资源隔离：划分独立资源池（线程池、数据库连接等）给不同服务&#x2F;模块，某资源池耗尽不影响其他服务。</li><li>熔断降级：若被调用服务频繁错误或崩溃，直接返回默认结果，防止影响在服务链蔓延。</li></ol><h3 id="（三）微服务流量治理技术选型对比"><a href="#（三）微服务流量治理技术选型对比" class="headerlink" title="（三）微服务流量治理技术选型对比"></a>（三）微服务流量治理技术选型对比</h3><p>微服务流量治理中，Hystrix 与 Sentinel 是主流选择，核心差异如下：</p><ol><li>Hystrix：核心聚焦“隔断+资源隔离+熔断”，提供 fallback 机制，服务异常时执行备用逻辑，保障基础可用性。</li><li>Sentinel：功能更全面，除流量控制、熔断降级外，还支持系统负载保护、实时监控，且有控制台支持规则动态调整，灵活性更强。</li></ol><h2 id="二、Sentinel-核心概念与使用方式"><a href="#二、Sentinel-核心概念与使用方式" class="headerlink" title="二、Sentinel 核心概念与使用方式"></a>二、Sentinel 核心概念与使用方式</h2><h3 id="（一）Sentinel-核心概念详解"><a href="#（一）Sentinel-核心概念详解" class="headerlink" title="（一）Sentinel 核心概念详解"></a>（一）Sentinel 核心概念详解</h3><ol><li>资源：经 Sentinel AOP 增强的代码接口（如微服务业务方法），是 Sentinel 监控和控制的核心对象。</li><li>规则：围绕资源设定的控制策略，用于实现限流、降级等功能，支持在控制台实时动态调整，适配业务和系统变化。</li></ol><h3 id="（二）Sentinel-使用方式对比"><a href="#（二）Sentinel-使用方式对比" class="headerlink" title="（二）Sentinel 使用方式对比"></a>（二）Sentinel 使用方式对比</h3><ol><li>原生使用：需引入多依赖，通过代码手动定义资源、规则，并在 post constructor 注入。弊端是业务代码与 Sentinel 配置耦合，可维护性差。</li><li>灵活使用：微服务推荐方式，引入切面依赖后，通过配置函数、配置类或 YAML 文件配置，实现业务代码与配置逻辑分离，结构清晰易维护。</li></ol><h2 id="三、Sentinel-在微服务中的具体应用"><a href="#三、Sentinel-在微服务中的具体应用" class="headerlink" title="三、Sentinel 在微服务中的具体应用"></a>三、Sentinel 在微服务中的具体应用</h2><h3 id="（一）常用处理机制"><a href="#（一）常用处理机制" class="headerlink" title="（一）常用处理机制"></a>（一）常用处理机制</h3><ol><li>block 流控异常处理：触发流控规则时，通过自定义逻辑返回友好提示（如“当前请求受限，请稍后重试”），提升用户体验。</li><li>fallback 熔断降级函数：服务熔断时自动调用，返回备用结果，确保系统在部分服务不可用的情况下仍能提供基础功能。</li></ol><h3 id="（二）与-Sentinel-控制台交互"><a href="#（二）与-Sentinel-控制台交互" class="headerlink" title="（二）与 Sentinel 控制台交互"></a>（二）与 Sentinel 控制台交互</h3><ol><li>注册流程：微服务 API 被调用时，Sentinel 读取 IP、端口等配置，在 HandlerInterceptor 预处理阶段，将客户端请求信息注册到 Sentinel Dashboard。</li><li>提示优化：默认提示为 Sentinel 配置信息，可通过实现 block interceptor handler 或熔断 interceptor handler，自定义提示内容，适配业务需求。</li></ol><h3 id="（三）使用过程中的坑点及解决办法"><a href="#（三）使用过程中的坑点及解决办法" class="headerlink" title="（三）使用过程中的坑点及解决办法"></a>（三）使用过程中的坑点及解决办法</h3><p><strong>核心坑点</strong>：服务重启后，控制台手动配置的规则会丢失，导致流量控制&#x2F;熔断策略失效。<br><strong>解决方案</strong>：规则持久化，如结合 Nacos 配置中心，将规则存储在 Nacos，服务启动时从 Nacos 加载规则，避免规则丢失。</p><h3 id="（四）微服务调用控制维度"><a href="#（四）微服务调用控制维度" class="headerlink" title="（四）微服务调用控制维度"></a>（四）微服务调用控制维度</h3><p>Sentinel 支持从两个维度对微服务调用进行熔断&#x2F;限流：</p><ol><li>微服务整体维度：针对整个服务（如“order”服务）设规则，例：限制单位时间内“order”服务的总请求数，或错误率达阈值时熔断。</li><li>接口维度：针对服务下的具体接口（如“order”服务的下单接口）设独立规则，例：给下单接口设更高限流阈值，保障核心业务稳定性。</li></ol><h3 id="（五）与-Spring-Cloud-的整合要点及-YAML-配置示例"><a href="#（五）与-Spring-Cloud-的整合要点及-YAML-配置示例" class="headerlink" title="（五）与 Spring Cloud 的整合要点及 YAML 配置示例"></a>（五）与 Spring Cloud 的整合要点及 YAML 配置示例</h3><h4 id="1-OpenFeign-支持"><a href="#1-OpenFeign-支持" class="headerlink" title="1. OpenFeign 支持"></a>1. OpenFeign 支持</h4><p>需在 <code>application.yml</code> 中开启 OpenFeign 支持，并配置 fallback factory：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启 Sentinel 对 OpenFeign 的支持</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">fallbackFactory:</span> <span class="string">com.example.CustomFeignFallbackFactory</span> <span class="comment"># 配置自定义 fallback factory 类</span></span><br></pre></td></tr></table></figure><h4 id="2-流控规则持久化"><a href="#2-流控规则持久化" class="headerlink" title="2. 流控规则持久化"></a>2. 流控规则持久化</h4><p>引入 Nacos 数据源依赖（Maven），并在 <code>application.yml</code> 配置 Nacos 数据源：</p><ul><li>依赖引入：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>YAML 配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span> <span class="comment"># 流控规则数据源</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos 服务器地址</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-sentinel-flow</span> <span class="comment"># 规则数据 ID（结合服务名命名）</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span> <span class="comment"># 数据格式</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment"># 规则类型（流控）</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Sentinel-基础概念与服务雪崩背景&quot;&gt;&lt;a href=&quot;#一、Sentinel-基础概念与服务雪崩背景&quot; class=&quot;headerlink&quot; title=&quot;一、Sentinel 基础概念与服务雪崩背景&quot;&gt;&lt;/a&gt;一、Sentinel 基础概念与服务雪崩</summary>
      
    
    
    
    <category term="微服务" scheme="https://goofysatoshi.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/tags/Sentinel/"/>
    
    <category term="微服务治理" scheme="https://goofysatoshi.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    <category term="流量控制" scheme="https://goofysatoshi.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Nacos Config 配置中心源码学习</title>
    <link href="https://goofysatoshi.github.io/2025/08/30/Spring-Cloud-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://goofysatoshi.github.io/2025/08/30/Spring-Cloud-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-08-30T16:38:40.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言：Nacos-Config-的核心定位"><a href="#一、引言：Nacos-Config-的核心定位" class="headerlink" title="一、引言：Nacos Config 的核心定位"></a>一、引言：Nacos Config 的核心定位</h2><p>在 Spring Cloud 微服务架构中，配置管理是保障服务弹性与可维护性的关键环节。Nacos Config 作为官方推荐的配置中心，不仅实现了配置的集中存储与动态推送，还通过<strong>SPI 机制适配 Spring Boot 自动配置</strong>，解决了传统本地配置“修改需重启”“环境配置混乱”等问题。</p><p>本文基于源码视角，从<strong>配置加载优先级</strong>、<strong>事件驱动的变更流程</strong>两大核心维度展开，同时补充一致性保障、多环境管理、安全加密等生产级关键特性，形成完整的 Nacos Config 知识体系。</p><h2 id="二、配置文件加载逻辑与优先级排序"><a href="#二、配置文件加载逻辑与优先级排序" class="headerlink" title="二、配置文件加载逻辑与优先级排序"></a>二、配置文件加载逻辑与优先级排序</h2><p>Nacos Config 本质是 Spring Boot 自动配置的扩展，其配置加载依赖 <strong>Bootstrap 上下文</strong>与 <strong>Spring 环境（Environment）</strong> 的初始化顺序，最终形成明确的优先级规则（优先级从高到低）：</p><table><thead><tr><th>优先级排序</th><th>配置文件类型</th><th>核心作用与场景</th></tr></thead><tbody><tr><td>1（最高）</td><td>服务名-环境名.yaml</td><td>如 <code>order-service-dev.yaml</code>，针对<strong>特定服务+特定环境</strong>的精准配置（如开发环境的数据库地址），优先级最高，覆盖所有其他配置。</td></tr><tr><td>2</td><td>服务名.yaml</td><td>如 <code>order-service.yaml</code>，该服务的<strong>通用基础配置</strong>（如服务端口、注册中心地址），无环境配置时作为默认值。</td></tr><tr><td>3</td><td>共享配置（shared-configs）</td><td>多服务共享的通用配置（如日志输出格式、公共 API 密钥），通过 Nacos 控制台配置“共享数据集”，避免重复配置。</td></tr><tr><td>4</td><td>本地 application.yaml&#x2F;props</td><td>应用级通用配置（如 Spring 全局参数），优先级低于 Nacos 远程配置，仅在远程配置缺失时生效。</td></tr><tr><td>5（最低）</td><td>本地 bootstrap.yaml&#x2F;props</td><td>启动级基础配置（如 Nacos Server 地址 <code>spring.cloud.nacos.config.server-addr</code>），仅用于初始化 Nacos 连接，不参与业务配置。</td></tr></tbody></table><h3 id="关键源码关联"><a href="#关键源码关联" class="headerlink" title="关键源码关联"></a>关键源码关联</h3><ul><li><strong>Bootstrap 上下文初始化</strong>：通过 <code>BootstrapApplicationListener</code> 触发，优先加载 <code>bootstrap.yaml</code>，确保 Nacos 地址等启动配置先于业务配置加载。</li><li><strong>配置优先级注入</strong>：<code>NacosConfigEnvironmentProcessor</code> 实现 <code>EnvironmentPostProcessor</code> 接口，将 Nacos 远程配置（按上述优先级）注入 Spring 环境，覆盖本地配置。</li></ul><h2 id="三、事件驱动模型：配置变更的全链路处理"><a href="#三、事件驱动模型：配置变更的全链路处理" class="headerlink" title="三、事件驱动模型：配置变更的全链路处理"></a>三、事件驱动模型：配置变更的全链路处理</h2><p>Nacos Config 的动态配置能力依赖<strong>事件驱动模型</strong>，核心是“变更触发→事件发布→监听器处理→客户端同步”的闭环流程，具体分为服务端与客户端两部分：</p><h3 id="3-1-服务端：配置变更的触发与持久化"><a href="#3-1-服务端：配置变更的触发与持久化" class="headerlink" title="3.1 服务端：配置变更的触发与持久化"></a>3.1 服务端：配置变更的触发与持久化</h3><p>当通过 Nacos 控制台&#x2F;API 修改配置后，服务端执行以下步骤：</p><ol><li><p><strong>配置校验与持久化</strong></p><ul><li>先将变更后的配置写入<strong>本地磁盘</strong>（路径：<code>nacos/data/config-data</code>），确保单机故障时配置不丢失；</li><li>同步写入 <strong>MySQL 数据库</strong>（表 <code>config_info</code>），通过数据库实现多节点（集群）间的配置一致性（Nacos 集群默认基于 MySQL 实现数据同步）。</li></ul></li><li><p><strong>事件发布与任务调度</strong></p><ul><li>持久化完成后，发布 <code>ConfigDataChangedEvent</code> 事件，触发内部监听器（如 <code>ConfigChangeNotifier</code>）；</li><li>监听器向客户端发送<strong>定时拉取任务</strong>（默认客户端每 30 秒拉取一次，可通过 <code>spring.cloud.nacos.config.refreshInterval</code> 调整），或通过 <strong>UDP 推送</strong>（需开启 <code>nacos.config.push.enabled=true</code>）主动通知客户端。</li></ul></li></ol><h3 id="3-2-客户端：配置变更的接收与应用"><a href="#3-2-客户端：配置变更的接收与应用" class="headerlink" title="3.2 客户端：配置变更的接收与应用"></a>3.2 客户端：配置变更的接收与应用</h3><p>客户端（微服务）通过 <code>NacosConfigManager</code> 与服务端交互，核心是<strong>阻塞队列+循环拉取</strong>的任务处理机制：</p><ol><li><strong>任务队列初始化</strong>：客户端启动时创建 <code>BlockingQueue</code>，用于存储服务端下发的“配置拉取任务”。</li><li><strong>任务消费逻辑</strong>：通过 <code>ConfigPullTaskRunner</code> 线程，以 <code>while(true)</code> 循环从队列中获取任务，避免线程频繁创建销毁。</li><li><strong>配置对比与更新</strong>：<ul><li>拉取服务端最新配置后，与本地缓存（内存+本地文件 <code>nacos/config</code>）对比；</li><li>若配置有变更，发布 <code>EnvironmentChangeEvent</code> 事件，触发 <code>@RefreshScope</code> 注解的 Bean 重新初始化，实现“零重启更新配置”。</li></ul></li></ol><h3 id="关键源码关联-1"><a href="#关键源码关联-1" class="headerlink" title="关键源码关联"></a>关键源码关联</h3><ul><li><strong>服务端事件机制</strong>：<code>EventDispatcher</code> 作为事件调度核心，管理 <code>ConfigDataChangedEvent</code> 等事件的监听器注册与触发。</li><li><strong>客户端缓存与刷新</strong>：<code>NacosConfigService</code> 负责缓存管理，<code>RefreshEventListener</code> 监听配置变更事件，触发 Bean 刷新。</li></ul><h2 id="四、生产级关键特性补充"><a href="#四、生产级关键特性补充" class="headerlink" title="四、生产级关键特性补充"></a>四、生产级关键特性补充</h2><h3 id="4-1-配置动态更新的一致性保障"><a href="#4-1-配置动态更新的一致性保障" class="headerlink" title="4.1 配置动态更新的一致性保障"></a>4.1 配置动态更新的一致性保障</h3><p>Nacos 通过“三重机制”确保服务端与客户端配置一致：</p><ul><li><strong>版本号校验</strong>：每个配置有唯一 <code>dataId</code> 和 <code>version</code>，客户端拉取时对比版本号，仅更新版本不同的配置；</li><li><strong>本地缓存兜底</strong>：客户端将远程配置缓存到本地文件，网络中断时优先使用缓存配置，避免服务不可用；</li><li><strong>集群数据同步</strong>：Nacos 集群通过 MySQL 主从同步或 Raft 协议（1.4.0+ 支持），确保多节点配置一致。</li></ul><h3 id="4-2-多环境与多版本管理"><a href="#4-2-多环境与多版本管理" class="headerlink" title="4.2 多环境与多版本管理"></a>4.2 多环境与多版本管理</h3><ul><li><strong>多环境隔离</strong>：通过 <code>namespace</code>（命名空间）区分环境（如 <code>dev</code>&#x2F;<code>test</code>&#x2F;<code>prod</code>），每个命名空间下的配置完全隔离，避免环境混淆；</li><li><strong>多版本回溯</strong>：Nacos 保留配置的历史版本（默认 30 天），支持一键回滚到历史版本，应对配置修改错误的场景。</li></ul><h3 id="4-3-配置安全：敏感信息加密"><a href="#4-3-配置安全：敏感信息加密" class="headerlink" title="4.3 配置安全：敏感信息加密"></a>4.3 配置安全：敏感信息加密</h3><p>针对数据库密码、AccessKey 等敏感配置，Nacos 提供两种加密方案：</p><ul><li><strong>传输加密</strong>：服务端与客户端通过 HTTPS 通信，避免配置在传输过程中被窃取；</li><li><strong>存储加密</strong>：使用 AES-128 或 RSA 算法对敏感配置加密后存储到 MySQL，客户端通过配置 <code>secretKey</code> 解密后使用（需在 <code>bootstrap.yaml</code> 中配置加密密钥）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、引言：Nacos-Config-的核心定位&quot;&gt;&lt;a href=&quot;#一、引言：Nacos-Config-的核心定位&quot; class=&quot;headerlink&quot; title=&quot;一、引言：Nacos Config 的核心定位&quot;&gt;&lt;/a&gt;一、引言：Nacos Config</summary>
      
    
    
    
    <category term="技术学习" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Spring Cloud" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Spring-Cloud/"/>
    
    
    <category term="Spring Cloud" scheme="https://goofysatoshi.github.io/tags/Spring-Cloud/"/>
    
    <category term="Nacos" scheme="https://goofysatoshi.github.io/tags/Nacos/"/>
    
    <category term="配置中心" scheme="https://goofysatoshi.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
    <category term="源码解析" scheme="https://goofysatoshi.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    <category term="事件驱动" scheme="https://goofysatoshi.github.io/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="动态配置" scheme="https://goofysatoshi.github.io/tags/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Actions 实现自动化部署完整指南</title>
    <link href="https://goofysatoshi.github.io/2025/08/29/Hexo-GitHub-Actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/"/>
    <id>https://goofysatoshi.github.io/2025/08/29/Hexo-GitHub-Actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</id>
    <published>2025-08-29T02:00:00.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Hexo 搭建个人博客时，当我们终于把hexo生成的页面挂载到github页面后，每次提交博客都需要使用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>来部署很麻烦，可以借助github actions来实现流水线布置，我们每次提交源代码到github存放源码的分支上，一旦监听到源代码的push事件，流水线就会就会自动拉取环境自动部署，所以我们需要一个存放源代码的分支，以及我们的发布分支，可以使用git命令创建这两个分支，自动CI&#x2F;CD,github需要密钥用来保证项目拉取和部署的权限，需要在本地生成ssh的密钥，公钥用来拉取项目，私钥用来部署推送更新页面，而且github对于npm安装有频率限制，我们可以通过配置国内镜像源+缓存配置，避免每次全量拉取，提高依赖安装以及部署的速度</p><h2 id="一-分支规划与准备工作"><a href="#一-分支规划与准备工作" class="headerlink" title="一.分支规划与准备工作"></a>一.分支规划与准备工作</h2><p>为了清晰分离源代码和部署文件，我们需要创建两个分支：</p><ul><li><code>source</code> 分支：存放 Hexo 源代码（包括 Markdown 文章、配置文件、主题文件等）</li><li><code>main</code> 分支：存放 Hexo 生成的静态网页文件，用于 GitHub Pages 展示</li></ul><h3 id="创建分支的具体操作"><a href="#创建分支的具体操作" class="headerlink" title="创建分支的具体操作"></a>创建分支的具体操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从当前分支创建并切换到 source 分支（源代码分支）</span></span><br><span class="line">git checkout -b <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送 source 分支到远程仓库</span></span><br><span class="line">git push -u origin <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 main 分支（部署分支）</span></span><br><span class="line">git checkout main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="二-SSH-密钥配置（核心权限控制）"><a href="#二-SSH-密钥配置（核心权限控制）" class="headerlink" title="二.SSH 密钥配置（核心权限控制）"></a>二.SSH 密钥配置（核心权限控制）</h2><p>要实现 GitHub Actions 的自动部署，必须配置 SSH 密钥对来授权 Actions 操作仓库的权限：</p><h3 id="1-生成专用-SSH-密钥对"><a href="#1-生成专用-SSH-密钥对" class="headerlink" title="1. 生成专用 SSH 密钥对"></a>1. 生成专用 SSH 密钥对</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成专用密钥对，替换为你的邮箱地址</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span> -f ~/.ssh/hexo-deploy</span><br></pre></td></tr></table></figure><p>执行后会在 <code>~/.ssh/</code> 目录下生成两个文件：</p><ul><li><code>hexo-deploy</code>：私钥文件（用于部署时推送代码）</li><li><code>hexo-deploy.pub</code>：公钥文件（用于拉取仓库代码）</li></ul><h3 id="2-配置公钥（Deploy-keys）"><a href="#2-配置公钥（Deploy-keys）" class="headerlink" title="2. 配置公钥（Deploy keys）"></a>2. 配置公钥（Deploy keys）</h3><p>公钥需要配置到你的 GitHub Pages 仓库（通常是 <code>username.github.io</code>）：</p><ol><li>打开 <code>hexo-deploy.pub</code> 文件，复制其中的全部内容</li><li>进入你的 GitHub Pages 仓库 → Settings → Deploy keys</li><li>点击 “Add deploy key”，粘贴公钥内容</li><li>务必勾选 “Allow write access” 选项（允许推送权限）</li><li>点击 “Add key” 完成配置<img width="902" height="479" alt="屏幕截图 2025-08-29 190446" src="https://github.com/user-attachments/assets/9befac08-b11e-4cdb-9086-5c36af4d5eb0" /></li></ol><h3 id="3-配置私钥（Repository-secrets）"><a href="#3-配置私钥（Repository-secrets）" class="headerlink" title="3. 配置私钥（Repository secrets）"></a>3. 配置私钥（Repository secrets）</h3><p>私钥需要配置到存放 Hexo 源代码的仓库：</p><ol><li>打开 <code>hexo-deploy</code> 文件，复制其中的全部内容</li><li>进入你的源代码仓库 → Settings → Secrets and variables → Actions</li><li>点击 “New repository secret”</li><li>名称填写 <code>HEXO_DEPLOY_PRI</code>（必须与后续配置文件中一致）</li><li>粘贴私钥内容，点击 “Add secret” 完成配置<img width="1829" height="847" alt="image" src="https://github.com/user-attachments/assets/f5798732-4256-4222-9a5d-020afe645f53" /></li></ol><img width="1213" height="678" alt="image" src="https://github.com/user-attachments/assets/d75ce0f6-41da-402c-9682-6d9384c9f3bb" /><h2 id="配置-GitHub-Actions-工作流"><a href="#配置-GitHub-Actions-工作流" class="headerlink" title="配置 GitHub Actions 工作流"></a>配置 GitHub Actions 工作流</h2><p>在源代码仓库中创建工作流配置文件，实现自动部署的核心逻辑：</p><h3 id="创建工作流文件"><a href="#创建工作流文件" class="headerlink" title="创建工作流文件"></a>创建工作流文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Hexo 项目根目录执行以下命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -p .github/workflows</span><br><span class="line"><span class="built_in">touch</span> .github/workflows/deploy.yml</span><br></pre></td></tr></table></figure><h3 id="完整配置内容"><a href="#完整配置内容" class="headerlink" title="完整配置内容"></a>完整配置内容</h3><p>编辑 <code>.github/workflows/deploy.yml</code> 文件，添加以下内容(没有这个目录需要自己手动创建)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">source</span> ] <span class="comment"># 方括号内填入拉取代码分支 当监听到push事件就会开启自动部署deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;18&#x27;</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span>  <span class="comment"># 启用 npm 缓存，减少重复下载</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        # 关键：切换为国内淘宝镜像，彻底解决 github 频率限制报错 429 限制</span></span><br><span class="line"><span class="string">        npm config set registry https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        # 清除缓存，避免镜像切换不生效</span></span><br><span class="line"><span class="string">        npm cache clean --force</span></span><br><span class="line"><span class="string">        # 安装依赖（全局和项目依赖都用国内镜像）</span></span><br><span class="line"><span class="string">        npm install -g hexo-cli --registry=https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        npm install --registry=https://registry.npmmirror.com/</span></span><br><span class="line"><span class="string">        # 构建静态文件</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_PRI</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">main</span>  <span class="comment"># 与 _config.yml 中的 deploy.branch 一致</span></span><br></pre></td></tr></table></figure><h2 id="配置优化说明"><a href="#配置优化说明" class="headerlink" title="配置优化说明"></a>配置优化说明</h2><h3 id="1-国内镜像源优化"><a href="#1-国内镜像源优化" class="headerlink" title="1. 国内镜像源优化"></a>1. 国内镜像源优化</h3><p>通过配置淘宝 npm 镜像源（<code>https://registry.npmmirror.com/</code>），解决了 GitHub 服务器上安装依赖的两大问题：</p><ul><li>访问速度慢（国内镜像加速）</li><li>访问频率限制（避免 npm 官方源的限流）</li></ul><h3 id="2-缓存机制优化"><a href="#2-缓存机制优化" class="headerlink" title="2. 缓存机制优化"></a>2. 缓存机制优化</h3><ul><li>缓存 <code>node_modules</code> 目录，避免每次部署重复安装依赖</li><li>基于 <code>package-lock.json</code> 的哈希值生成缓存键，只有依赖变更时才重新安装</li><li>使用 <code>npm ci</code> 替代 <code>npm install</code>，利用锁文件实现更快、更一致的依赖安装</li></ul><h3 id="3-安全权限控制"><a href="#3-安全权限控制" class="headerlink" title="3. 安全权限控制"></a>3. 安全权限控制</h3><ul><li>采用 SSH 密钥对进行身份验证，比传统 token 更安全</li><li>私钥通过 GitHub Secrets 加密存储，不会暴露在代码中</li><li>细粒度权限控制：Deploy keys 仅对目标仓库有效，避免全局权限风险</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-初始配置提交"><a href="#1-初始配置提交" class="headerlink" title="1. 初始配置提交"></a>1. 初始配置提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交工作流配置文件</span></span><br><span class="line">git add .github/workflows/deploy.yml</span><br><span class="line"><span class="comment"># 提交其他源代码文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;配置 GitHub Actions 自动部署&quot;</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="2-查看部署状态"><a href="#2-查看部署状态" class="headerlink" title="2. 查看部署状态"></a>2. 查看部署状态</h3><ol><li>进入源代码仓库的 GitHub 页面</li><li>点击顶部的 “Actions” 标签</li><li>查看名为 “Hexo Auto Deploy” 的工作流运行状态</li><li>点击具体运行记录可查看详细日志（便于排查错误）</li></ol><h3 id="3-发布新文章流程"><a href="#3-发布新文章流程" class="headerlink" title="3. 发布新文章流程"></a>3. 发布新文章流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new <span class="string">&quot;我的新文章&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文章（在 source/_posts 目录下）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到源代码仓库</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;发布新文章：我的新文章&quot;</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>提交后，GitHub Actions 会自动触发部署流程，无需再执行手动部署命令，整个过程约 1-3 分钟。</p><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><ol><li><p><strong>部署失败提示权限错误</strong></p><ul><li>检查 SSH 密钥对是否匹配</li><li>确认公钥是否勾选了 “Allow write access”</li><li>检查私钥在 Secrets 中的名称是否为 <code>HEXO_DEPLOY_KEY</code></li></ul></li><li><p><strong>主题样式丢失</strong></p><ul><li>确保配置文件中 <code>submodules: true</code> 已设置（拉取主题子模块）</li><li>检查主题是否正确添加到源代码仓库</li></ul></li><li><p><strong>依赖安装失败</strong></p><ul><li>查看日志确认是否为网络问题</li><li>尝试删除缓存后重新部署（可在 GitHub 仓库的 Actions 缓存设置中操作）</li></ul></li><li><p><strong>部署成功但页面未更新</strong></p><ul><li>检查 GitHub Pages 配置的分支是否为 <code>main</code></li><li>浏览器强制刷新（Ctrl+Shift+R 或 Cmd+Shift+R）清除缓存</li></ul></li></ol><p>Hexo 博客的全自动部署流程，就可以只在source&#x2F;_post目录下只提交md文件（必须是md后缀文件）到github项目的分支上就可以自动部署了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在使用 Hexo 搭建个人博客时，当我们终于把hexo生成的页面挂载到github页面后，每次提交博客都需要使用&lt;code&gt;hexo cle</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://goofysatoshi.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://goofysatoshi.github.io/tags/Hexo/"/>
    
    <category term="GitHub" scheme="https://goofysatoshi.github.io/tags/GitHub/"/>
    
    <category term="CI/CD" scheme="https://goofysatoshi.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 2.X 核心源码学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/08/27/Nacos2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/08/27/Nacos2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-27T15:11:00.000Z</published>
    <updated>2025-09-04T15:08:01.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Nacos 作为阿里开源的分布式服务发现与配置管理平台，2.X 版本在架构上进行了协议升级（HTTP→gRPC）、存储结构优化（嵌套 Map→扁平分层）、一致性增强（Distro→Raft）</p><p>Nacos 2.X 主要核心优化：</p><ol><li>协议升级：gRPC 长连接替代 HTTP，降低通信开销，提升实时性；</li><li>存储优化：扁平分层注册表替代嵌套 Map，提升查询与同步效率；</li><li>事件驱动：解耦模块依赖，增强扩展性；</li><li>健康检查：服务端主动探活替代客户端心跳，减少客户端负担；</li><li>一致性增强：Raft+Distro 混合协议，平衡一致性与性能。</li></ol><h2 id="二、服务注册核心源码剖析"><a href="#二、服务注册核心源码剖析" class="headerlink" title="二、服务注册核心源码剖析"></a>二、服务注册核心源码剖析</h2><p>服务注册是 Nacos 的基础能力，2.X 版本通过 gRPC 长连接异步通信替代 1.X 的 HTTP 短连接，同时优化了实例存储与一致性逻辑。</p><h3 id="（一）客户端：发起注册请求"><a href="#（一）客户端：发起注册请求" class="headerlink" title="（一）客户端：发起注册请求"></a>（一）客户端：发起注册请求</h3><p>客户端核心是封装实例信息、建立 gRPC 连接并发送注册请求，关键类集中在 <code>nacos-naming-client</code> 模块。</p><ol><li>入口类：<code>NacosNamingService</code></li></ol><p>客户端对外暴露的注册入口，负责参数预处理与代理分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务唯一标识：group@@serviceName（Nacos 服务的核心命名规则）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 补全实例默认值（如集群名默认值、命名空间）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.getClusterName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setClusterName(ClusterUtils.getDefaultClusterName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instance.getNamespaceId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.setNamespaceId(<span class="built_in">this</span>.namespace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 委托 gRPC 代理发送注册请求（核心逻辑）</span></span><br><span class="line">    namingClientProxy.registerInstance(groupedServiceName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>gRPC 代理：<code>NamingGrpcClientProxy</code></li></ol><p>负责将注册请求封装为 gRPC 协议格式，通过长连接发送至服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingGrpcClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 gRPC 注册请求（ProtoBuf 格式，适配 gRPC 传输）</span></span><br><span class="line">    <span class="type">RegisterInstanceRequest</span> <span class="variable">request</span> <span class="operator">=</span> RegisterInstanceRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setInstance(GrpcUtils.convertInstanceToProto(instance)) <span class="comment">// 实例信息转 Proto</span></span><br><span class="line">            .setNamespace(instance.getNamespaceId())</span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口（失败重试由底层 GrpcUtils 实现）</span></span><br><span class="line">    GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.registerInstance(request), <span class="comment">// namingStub 是 gRPC 自动生成的客户端存根</span></span><br><span class="line">        <span class="string">&quot;registerInstance&quot;</span>, </span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键细节：客户端初始化时会与服务端建立 gRPC 长连接（默认端口 9848），后续注册、心跳、订阅均复用该连接，减少 TCP 握手开销。</li></ul><h3 id="（二）服务端：处理注册请求"><a href="#（二）服务端：处理注册请求" class="headerlink" title="（二）服务端：处理注册请求"></a>（二）服务端：处理注册请求</h3><p>服务端核心是接收 gRPC 请求、校验参数、分层存储实例，并触发事件通知与集群同步，关键类集中在 <code>nacos-naming-core</code> 模块。</p><ol><li>gRPC 请求入口：<code>NamingGrpcService</code></li></ol><p>服务端 gRPC 服务实现类，负责接收客户端请求并转发至业务逻辑层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.controllers.v2.grpc.NamingGrpcService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(RegisterInstanceRequest request, StreamObserver&lt;CommonResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="type">CommonResponse</span> <span class="variable">response</span> <span class="operator">=</span> CommonResponse.newBuilder().build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 解析请求参数（服务名、命名空间、实例信息）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> GrpcUtils.convertProtoToInstance(request.getInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 委托 ServiceManager 处理注册核心逻辑</span></span><br><span class="line">        serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回成功响应</span></span><br><span class="line">        response.setSuccess(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        response.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;注册失败：&quot;</span> + e.getMessage());</span><br><span class="line">        log.error(<span class="string">&quot;Instance register failed&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        responseObserver.onNext(response);</span><br><span class="line">        responseObserver.onCompleted(); <span class="comment">// 结束 gRPC 流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务管理核心：<code>ServiceManager</code></li></ol><p>负责创建&#x2F;获取服务、调度实例注册，是服务端的”服务中枢”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 生成服务唯一 Key：namespaceId@@group@@serviceName（避免同名冲突）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 不存在则创建 Service（懒加载模式，减少内存占用）</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> getOrCreateService(namespaceId, serviceName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将实例注册到对应集群（核心：分层存储的入口）</span></span><br><span class="line">    service.registerInstance(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 发布服务注册事件（触发后续健康检查、集群同步）</span></span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载创建 Service</span></span><br><span class="line"><span class="keyword">private</span> Service <span class="title function_">getOrCreateService</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">return</span> serviceMap.computeIfAbsent(serviceKey, key -&gt; &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">newService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">        newService.setNamespaceId(namespaceId);</span><br><span class="line">        newService.setServiceName(serviceName);</span><br><span class="line">        newService.setId(IdGenerator.generateServiceId(namespaceId, serviceName));</span><br><span class="line">        <span class="keyword">return</span> newService;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>分层存储：<code>Service</code> → <code>Cluster</code> → <code>Instance</code></li></ol><p>2.X 采用”服务-集群-实例”三层结构，替代 1.X 的嵌套 Map，每个层级独立管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取/创建实例所属集群（默认集群名：DEFAULT）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> instance.getClusterName();</span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> clusters.computeIfAbsent(clusterName, key -&gt; <span class="keyword">new</span> <span class="title class_">Cluster</span>(clusterName, <span class="built_in">this</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将实例注册到集群（集群维护实例集合）</span></span><br><span class="line">    cluster.addInstance(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.entity.Cluster</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 实例存储容器：线程安全的 ConcurrentHashMap（key=instanceId，避免重复注册）</span></span><br><span class="line">    ConcurrentHashMap&lt;String, Instance&gt; instanceMap = getInstanceMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分临时实例与持久化实例（核心差异：是否依赖心跳）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">        <span class="comment">// 临时实例：内存存储 + 心跳绑定</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        <span class="comment">// 注册心跳检测任务（服务端主动探活）</span></span><br><span class="line">        healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, <span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 持久化实例：内存 + 本地文件持久化（重启不丢失）</span></span><br><span class="line">        instanceMap.put(instance.getInstanceId(), instance);</span><br><span class="line">        persistInstance(instance); <span class="comment">// 持久化到 data/nacos/naming/ 目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>请求校验：隐式在业务逻辑中</li></ol><p>2.X 未单独封装 <code>InstanceValidator</code>，而是在实例注册前通过 参数非空校验+格式校验 确保合法性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cluster.addInstance 中隐含的校验逻辑（简化）</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(instance.getIp()) || instance.getPort() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;IP/端口不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instance.getWeight() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(NacosException.INVALID_PARAM, <span class="string">&quot;权重不能为负数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、事件驱动架构剖析"><a href="#三、事件驱动架构剖析" class="headerlink" title="三、事件驱动架构剖析"></a>三、事件驱动架构剖析</h2><p>Nacos 2.X 基于 “事件发布-订阅”模式 解耦模块依赖，核心由「事件、事件总线、发布者、订阅者」四部分组成，所有核心流程（注册、健康检查、同步）均通过事件触发。</p><h3 id="（一）事件：状态变化的载体"><a href="#（一）事件：状态变化的载体" class="headerlink" title="（一）事件：状态变化的载体"></a>（一）事件：状态变化的载体</h3><p>事件是系统状态变化的封装，所有事件均继承自顶层接口 <code>Event</code>，核心事件类如下：</p><table><thead><tr><th>事件类</th><th>触发场景</th><th>核心属性</th></tr></thead><tbody><tr><td><code>ServiceInstanceEvent</code></td><td>服务实例注册&#x2F;更新&#x2F;删除</td><td><code>service</code>（服务）、<code>instance</code>（实例）</td></tr><tr><td><code>HealthStateChangeEvent</code></td><td>实例健康状态变更（健康→不健康）</td><td><code>instanceId</code>、<code>newHealthyState</code></td></tr><tr><td><code>ConfigDataChangeEvent</code></td><td>配置中心数据变更</td><td><code>dataId</code>、<code>group</code>、<code>content</code></td></tr></tbody></table><p>示例：服务实例注册事件定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.event.ServiceInstanceRegisteredEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInstanceRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">AbstractEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service service;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInstanceRegisteredEvent</span><span class="params">(Service service, Instance instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）事件总线：事件路由的核心"><a href="#（二）事件总线：事件路由的核心" class="headerlink" title="（二）事件总线：事件路由的核心"></a>（二）事件总线：事件路由的核心</h3><p>事件总线负责连接发布者与订阅者，提供事件注册、发布、路由能力，核心实现类为 <code>NacosEventBus</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.common.event.NacosEventBus</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosEventBus</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventBus</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：事件类型 → 订阅者列表（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;, CopyOnWriteArrayList&lt;Subscriber&gt;&gt; subscriberMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 注册订阅者（根据事件类型关联）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Subscriber subscriber)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = subscriber.getSubscribeType();</span><br><span class="line">        subscriberMap.computeIfAbsent(eventType, key -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;())</span><br><span class="line">                     .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发布事件（路由到对应订阅者）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; eventType = event.getClass();</span><br><span class="line">        <span class="comment">// 找到订阅该事件的所有订阅者</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscriber&gt; subscribers = subscriberMap.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscribers == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步触发订阅者的事件处理（默认线程池：EventExecutor）</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            EventExecutor.execute(() -&gt; subscriber.onEvent(event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）发布者：事件的产生者"><a href="#（三）发布者：事件的产生者" class="headerlink" title="（三）发布者：事件的产生者"></a>（三）发布者：事件的产生者</h3><p>发布者在特定业务逻辑完成后发布事件，核心实现是 <code>EventPublisher</code> 接口，默认实现为 <code>DefaultEventPublisher</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManager 中发布注册事件的逻辑（前文已提及）</span></span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">ServiceInstanceRegisteredEvent</span>(service, instance));</span><br></pre></td></tr></table></figure><p>常见发布场景：</p><ul><li>服务注册完成 → 发布 <code>ServiceInstanceRegisteredEvent</code></li><li>实例健康状态变更 → 发布 <code>HealthStateChangeEvent</code></li><li>配置数据更新 → 发布 <code>ConfigDataChangeEvent</code></li></ul><h3 id="（四）订阅者：事件的消费者"><a href="#（四）订阅者：事件的消费者" class="headerlink" title="（四）订阅者：事件的消费者"></a>（四）订阅者：事件的消费者</h3><p>订阅者通过 实现 <code>Subscriber</code> 接口 或 添加 <code>@EventListener</code> 注解 订阅事件，核心是编写事件处理逻辑。</p><p>示例：健康检查订阅者（监听注册事件，初始化探活任务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.subscriber.InstanceRegisteredSubscriber</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceRegisteredSubscriber</span> <span class="keyword">implements</span> <span class="title class_">Subscriber</span>&lt;ServiceInstanceRegisteredEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HealthCheckReactor healthCheckReactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅的事件类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; getSubscribeType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceInstanceRegisteredEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ServiceInstanceRegisteredEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> event.getInstance();</span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> event.getService().getCluster(instance.getClusterName());</span><br><span class="line">        <span class="comment">// 为临时实例添加 gRPC 探活任务</span></span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            healthCheckReactor.addHealthCheckTask(<span class="keyword">new</span> <span class="title class_">GrpcHealthCheckTask</span>(instance, cluster));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键优势：模块间无需硬编码依赖（如注册模块不直接调用健康检查模块），只需通过事件交互，扩展性极强。</li></ul><h2 id="四、注册表结构变动剖析"><a href="#四、注册表结构变动剖析" class="headerlink" title="四、注册表结构变动剖析"></a>四、注册表结构变动剖析</h2><p>Nacos 2.X 对注册表的优化是性能提升的核心，主要解决 1.X 嵌套 Map 带来的 深拷贝开销大、查询效率低 问题。</p><h3 id="（一）旧结构（1-X）：嵌套-Map-的痛点"><a href="#（一）旧结构（1-X）：嵌套-Map-的痛点" class="headerlink" title="（一）旧结构（1.X）：嵌套 Map 的痛点"></a>（一）旧结构（1.X）：嵌套 Map 的痛点</h3><p>1.X 注册表采用 四层嵌套 Map，结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.X 注册表结构（简化）</span></span><br><span class="line">Map&lt;String, Map&lt;String, Map&lt;String, Map&lt;String, List&lt;Instance&gt;&gt;&gt;&gt;&gt; registry;</span><br><span class="line"><span class="comment">// 层级：namespace → group → service → cluster → instanceList</span></span><br></pre></td></tr></table></figure><ul><li>痛点：</li></ul><ol><li>查询实例需逐层遍历（如 <code>registry.get(namespace).get(group).get(service).get(cluster)</code>），效率低；</li><li>数据同步&#x2F;备份时需深拷贝整个嵌套结构，内存与时间开销大；</li><li>新增维度（如元数据）需修改多层结构，扩展性差。</li></ol><h3 id="（二）新结构（2-X）：扁平分层存储"><a href="#（二）新结构（2-X）：扁平分层存储" class="headerlink" title="（二）新结构（2.X）：扁平分层存储"></a>（二）新结构（2.X）：扁平分层存储</h3><p>2.X 将注册表拆分为 独立的分层存储单元，通过 唯一 Key 关联，核心实现类为 <code>ServiceStorage</code>：</p><ol><li>核心存储结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.v2.storage.ServiceStorage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceStorage</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式（注册表全局唯一）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ServiceStorage</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceStorage</span>();</span><br><span class="line">    <span class="comment">// 存储：namespace → (serviceKey → ServiceInfo)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Namespace, ConcurrentHashMap&lt;Service, ServiceInfo&gt;&gt; namespaceServiceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务实例列表（通过 namespace + service 直接定位）</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(Namespace namespace, Service service)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;Service, ServiceInfo&gt; serviceInfoMap = namespaceServiceInfoMap.get(namespace);</span><br><span class="line">        <span class="keyword">if</span> (serviceInfoMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增/更新服务实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putServiceInfo</span><span class="params">(Namespace namespace, Service service, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        namespaceServiceInfoMap.computeIfAbsent(namespace, key -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;())</span><br><span class="line">                               .put(service, serviceInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>联合 Key 设计</li></ol><p>通过 <code>ServiceKeyGenerator</code> 生成 全局唯一 Key，替代多层嵌套的定位逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.ServiceKeyGenerator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceKeyGenerator</span> &#123;</span><br><span class="line">    <span class="comment">// 生成 serviceKey：namespaceId@@groupName@@serviceName</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateServiceKey</span><span class="params">(String namespaceId, String serviceName)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 serviceName 中解析出 groupName（serviceName 格式：group@@service）</span></span><br><span class="line">        String[] parts = serviceName.split(<span class="string">&quot;@@&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">0</span>] : Constants.DEFAULT_GROUP;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pureServiceName</span> <span class="operator">=</span> parts.length &gt; <span class="number">1</span> ? parts[<span class="number">1</span>] : parts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s@@%s@@%s&quot;</span>, namespaceId, groupName, pureServiceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>优化效果</li></ol><ul><li>查询效率：从 O(n^4) 嵌套遍历降至 O(1) 哈希查询；</li><li>同步开销：数据同步时只需传输单个 <code>ServiceInfo</code> 对象，无需深拷贝；</li><li>扩展性：新增维度（如实例标签）只需在 <code>Instance</code> 类加字段，不影响存储结构。</li></ul><h2 id="五、服务发现与订阅核心源码剖析"><a href="#五、服务发现与订阅核心源码剖析" class="headerlink" title="五、服务发现与订阅核心源码剖析"></a>五、服务发现与订阅核心源码剖析</h2><p>服务发现是客户端获取健康实例的过程，2.X 通过 gRPC 长连接+主动推送 替代 1.X 的 HTTP 轮询，实时性与效率大幅提升。</p><h3 id="（一）通信方式转变：HTTP-→-gRPC"><a href="#（一）通信方式转变：HTTP-→-gRPC" class="headerlink" title="（一）通信方式转变：HTTP → gRPC"></a>（一）通信方式转变：HTTP → gRPC</h3><p>2.X 客户端默认使用 <code>RpcNamingClientProxy</code>（gRPC 代理），仅在兼容模式下使用 <code>HttpNamingClientProxy</code>，核心优势：</p><ul><li>长连接复用：减少 TCP 握手与挥手开销；</li><li>二进制传输：ProtoBuf 格式比 JSON 体积小 30%+；</li><li>主动推送：服务变动时服务端主动推送，无需客户端轮询。</li></ul><h3 id="（二）服务发现逻辑"><a href="#（二）服务发现逻辑" class="headerlink" title="（二）服务发现逻辑"></a>（二）服务发现逻辑</h3><p>客户端通过 gRPC 向服务端查询实例，服务端从注册表过滤健康实例后返回。</p><ol><li>客户端查询入口：<code>NacosNamingService</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, String groupName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 封装服务标识</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 2. 委托 gRPC 代理查询</span></span><br><span class="line">    <span class="keyword">return</span> namingClientProxy.selectInstances(groupedServiceName, healthy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>gRPC 代理查询实现：<code>RpcNamingClientProxy</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.RpcNamingClientProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title function_">selectInstances</span><span class="params">(String serviceName, <span class="type">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建查询请求（指定服务名、健康状态过滤）</span></span><br><span class="line">    <span class="type">QueryInstancesRequest</span> <span class="variable">request</span> <span class="operator">=</span> QueryInstancesRequest.newBuilder()</span><br><span class="line">            .setServiceName(serviceName)</span><br><span class="line">            .setNamespace(namespace)</span><br><span class="line">            .setHealthyOnly(healthy) <span class="comment">// 只返回健康实例</span></span><br><span class="line">            .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 同步调用服务端 gRPC 接口</span></span><br><span class="line">    <span class="type">QueryInstancesResponse</span> <span class="variable">response</span> <span class="operator">=</span> GrpcUtils.invokeGrpcSync(</span><br><span class="line">        () -&gt; namingStub.queryInstances(request),</span><br><span class="line">        <span class="string">&quot;queryInstances&quot;</span>,</span><br><span class="line">        serviceName</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 解析响应，返回实例列表</span></span><br><span class="line">    <span class="keyword">return</span> response.getInstancesList().stream()</span><br><span class="line">            .map(GrpcUtils::convertProtoToInstance)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端查询处理：<code>InstanceQueryHandler</code></li></ol><p>服务端接收查询请求后，从注册表过滤实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.remote.rpc.handler.InstanceQueryHandler</span></span><br><span class="line"><span class="keyword">public</span> QueryInstancesResponse <span class="title function_">handle</span><span class="params">(QueryInstancesRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> request.getNamespace();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> request.getServiceName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">healthyOnly</span> <span class="operator">=</span> request.isHealthyOnly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取服务信息</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> serviceManager.getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> QueryInstancesResponse.newBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 过滤实例（健康状态、权重&gt;0）</span></span><br><span class="line">    List&lt;Instance&gt; filteredInstances = service.getAllInstances().stream()</span><br><span class="line">            .filter(instance -&gt; !healthyOnly || instance.isHealthy()) <span class="comment">// 健康状态过滤</span></span><br><span class="line">            .filter(instance -&gt; instance.getWeight() &gt; <span class="number">0</span>) <span class="comment">// 权重过滤</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 构建响应</span></span><br><span class="line">    <span class="keyword">return</span> QueryInstancesResponse.newBuilder()</span><br><span class="line">            .addAllInstances(GrpcUtils.convertInstancesToProtos(filteredInstances))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）服务订阅逻辑"><a href="#（三）服务订阅逻辑" class="headerlink" title="（三）服务订阅逻辑"></a>（三）服务订阅逻辑</h3><p>订阅是”一次订阅，持续接收更新”的机制，客户端注册监听器，服务端变动时主动推送。</p><ol><li>客户端订阅入口：<code>NacosNamingService</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.NacosNamingService</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceName, String groupName, EventListener listener)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">groupedServiceName</span> <span class="operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    <span class="comment">// 1. 本地注册监听器（避免重复订阅）</span></span><br><span class="line">    subscriptionManager.subscribe(groupedServiceName, listener);</span><br><span class="line">    <span class="comment">// 2. 向服务端发起订阅请求（建立推送关系）</span></span><br><span class="line">    namingClientProxy.subscribe(groupedServiceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>服务端订阅管理：<code>SubscriptionManager</code></li></ol><p>服务端存储”服务-客户端”订阅关系，核心是 <code>ConcurrentHashMap</code> 映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 订阅该服务的客户端集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Subscriber&gt;&gt; serviceSubscribers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册订阅关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String serviceKey, Subscriber subscriber)</span> &#123;</span><br><span class="line">        serviceSubscribers.computeIfAbsent(serviceKey, key -&gt; ConcurrentHashMap.newKeySet())</span><br><span class="line">                          .add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务的所有订阅者（用于推送）</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Subscriber&gt; <span class="title function_">getSubscribers</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceSubscribers.getOrDefault(serviceKey, Collections.emptySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>服务端推送触发：事件驱动</li></ol><p>当服务实例变动时，通过事件触发推送逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.PushService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听实例变更事件，触发推送</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInstanceChange</span><span class="params">(ServiceInstanceEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> event.getService();</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> ServiceKeyGenerator.generateServiceKey(service.getNamespaceId(), service.getServiceName());</span><br><span class="line">        <span class="comment">// 1. 获取订阅该服务的所有客户端</span></span><br><span class="line">        Set&lt;Subscriber&gt; subscribers = subscriptionManager.getSubscribers(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (subscribers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建推送数据（最新实例列表）</span></span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> serviceStorage.getServiceInfo(service.getNamespaceId(), service);</span><br><span class="line">        <span class="comment">// 3. 通过 gRPC 向客户端推送</span></span><br><span class="line">        <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            pushToClient(subscriber, serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 推送实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushToClient</span><span class="params">(Subscriber subscriber, ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">ServiceChangeResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServiceChangeResponse.newBuilder()</span><br><span class="line">                .setServiceInfo(GrpcUtils.convertServiceInfoToProto(serviceInfo))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 通过客户端的 gRPC 连接推送</span></span><br><span class="line">        subscriber.getGrpcChannel().writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、服务变动推送订阅客户端源码剖析"><a href="#六、服务变动推送订阅客户端源码剖析" class="headerlink" title="六、服务变动推送订阅客户端源码剖析"></a>六、服务变动推送订阅客户端源码剖析</h2><p>客户端接收服务端推送的核心是 gRPC 流监听+本地缓存更新+监听器回调，关键类集中在 <code>nacos-naming-client</code> 模块。</p><h3 id="（一）推送接收：NamingPushResponseHandler"><a href="#（一）推送接收：NamingPushResponseHandler" class="headerlink" title="（一）推送接收：NamingPushResponseHandler"></a>（一）推送接收：<code>NamingPushResponseHandler</code></h3><p>客户端通过 gRPC 流观察者监听服务端推送，核心是 <code>onNext</code> 方法（推送消息接收入口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.remote.gprc.NamingPushResponseHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NamingPushResponseHandler</span> <span class="keyword">implements</span> <span class="title class_">StreamObserver</span>&lt;ServiceChangeResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfoHolder serviceInfoHolder; <span class="comment">// 本地缓存管理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SubscriptionManager subscriptionManager; <span class="comment">// 本地监听器管理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务端推送的变动消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(ServiceChangeResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 解析推送数据（Proto → ServiceInfo）</span></span><br><span class="line">            <span class="type">ServiceInfoProto</span> <span class="variable">serviceInfoProto</span> <span class="operator">=</span> response.getServiceInfo();</span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">newServiceInfo</span> <span class="operator">=</span> GrpcUtils.convertProtoToServiceInfo(serviceInfoProto);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 更新本地缓存（覆盖旧数据，保证一致性）</span></span><br><span class="line">            serviceInfoHolder.processServiceInfo(newServiceInfo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 触发本地监听器回调（通知业务层）</span></span><br><span class="line">            subscriptionManager.notifyListeners(newServiceInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;处理服务推送失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流异常处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;gRPC 推送流异常&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流关闭处理（重连机制）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;gRPC 推送流关闭，尝试重连&quot;</span>);</span><br><span class="line">        reconnect(); <span class="comment">// 内部实现重连逻辑，确保推送不中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）本地缓存更新：ServiceInfoHolder"><a href="#（二）本地缓存更新：ServiceInfoHolder" class="headerlink" title="（二）本地缓存更新：ServiceInfoHolder"></a>（二）本地缓存更新：<code>ServiceInfoHolder</code></h3><p>客户端维护本地实例缓存，避免重复查询服务端，核心是 <code>serviceInfoMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.cache.ServiceInfoHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceInfoHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 本地缓存：serviceKey → ServiceInfo（serviceKey 格式：group@@service@@cluster）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ServiceInfo&gt; serviceInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新缓存（版本校验，避免旧数据覆盖新数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processServiceInfo</span><span class="params">(ServiceInfo newServiceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> newServiceInfo.getKey();</span><br><span class="line">        <span class="type">ServiceInfo</span> <span class="variable">oldServiceInfo</span> <span class="operator">=</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 版本校验：仅更新比本地新的数据（lastRefTime 为数据最后更新时间）</span></span><br><span class="line">        <span class="keyword">if</span> (oldServiceInfo != <span class="literal">null</span> &amp;&amp; newServiceInfo.getLastRefTime() &lt;= oldServiceInfo.getLastRefTime()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        serviceInfoMap.put(serviceKey, newServiceInfo);</span><br><span class="line">        newServiceInfo.setLastRefTime(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地缓存的实例列表</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">getServiceInfo</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceInfoMap.get(serviceKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）监听器回调：SubscriptionManager"><a href="#（三）监听器回调：SubscriptionManager" class="headerlink" title="（三）监听器回调：SubscriptionManager"></a>（三）监听器回调：<code>SubscriptionManager</code></h3><p>客户端通知业务层服务变动，核心是遍历监听器并调用 <code>onEvent</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.naming.subscription.SubscriptionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 存储：serviceKey → 监听器集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;EventListener&gt;&gt; listenerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发监听器回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyListeners</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> serviceInfo.getKey();</span><br><span class="line">        Set&lt;EventListener&gt; listeners = listenerMap.get(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历监听器，触发业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.onEvent(<span class="keyword">new</span> <span class="title class_">NamingEvent</span>(serviceInfo.getName(), serviceInfo.getHosts()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;监听器回调失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层示例：客户端通过实现 <code>EventListener</code> 感知变动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务层订阅示例</span></span><br><span class="line">namingService.subscribe(<span class="string">&quot;user-service&quot;</span>, <span class="string">&quot;DEFAULT_GROUP&quot;</span>, <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="type">NamingEvent</span> <span class="variable">namingEvent</span> <span class="operator">=</span> (NamingEvent) event;</span><br><span class="line">        List&lt;Instance&gt; instances = namingEvent.getInstances();</span><br><span class="line">        <span class="comment">// 业务逻辑：更新本地服务列表、重新计算负载均衡等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务变动，新实例列表：&quot;</span> + instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="七、服务端健康检查源码剖析"><a href="#七、服务端健康检查源码剖析" class="headerlink" title="七、服务端健康检查源码剖析"></a>七、服务端健康检查源码剖析</h2><p>Nacos 2.X 健康检查从 客户端主动心跳 改为 服务端主动探活，减少客户端开销，同时提高探活准确性。</p><h3 id="（一）核心机制：服务端-gRPC-主动探活"><a href="#（一）核心机制：服务端-gRPC-主动探活" class="headerlink" title="（一）核心机制：服务端 gRPC 主动探活"></a>（一）核心机制：服务端 gRPC 主动探活</h3><p>2.X 对临时实例（默认）采用 gRPC 探活，对持久化实例采用 HTTP 探活（可配置），核心由 <code>HealthCheckReactor</code> 调度探活任务。</p><h3 id="（二）探活任务管理：HealthCheckReactor"><a href="#（二）探活任务管理：HealthCheckReactor" class="headerlink" title="（二）探活任务管理：HealthCheckReactor"></a>（二）探活任务管理：<code>HealthCheckReactor</code></h3><p>负责创建、调度探活任务，采用线程池异步执行，避免阻塞主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.HealthCheckReactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthCheckReactor</span> &#123;</span><br><span class="line">    <span class="comment">// 探活线程池（核心线程数：CPU 核心数 * 2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">healthCheckExecutor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;nacos-health-check-%d&quot;</span>).build()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加探活任务（延迟 0 秒，周期 20 秒执行一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHealthCheckTask</span><span class="params">(HealthCheckTask task)</span> &#123;</span><br><span class="line">        healthCheckExecutor.scheduleAtFixedRate(</span><br><span class="line">            task,</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 初始延迟</span></span><br><span class="line">            <span class="number">20000</span>, <span class="comment">// 周期（20 秒，默认值）</span></span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）gRPC-探活实现：GrpcHealthCheckTask"><a href="#（三）gRPC-探活实现：GrpcHealthCheckTask" class="headerlink" title="（三）gRPC 探活实现：GrpcHealthCheckTask"></a>（三）gRPC 探活实现：<code>GrpcHealthCheckTask</code></h3><p>临时实例的探活任务，通过 gRPC 向客户端发送探活请求，判断实例是否存活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.healthcheck.v2.processor.GrpcHealthCheckTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcHealthCheckTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instance instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line">    <span class="comment">// 探活超时时间（5 秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建 gRPC 探活请求</span></span><br><span class="line">            <span class="type">HealthCheckRequest</span> <span class="variable">request</span> <span class="operator">=</span> HealthCheckRequest.newBuilder()</span><br><span class="line">                    .setInstanceId(instance.getInstanceId())</span><br><span class="line">                    .build();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 向实例发送探活请求（客户端需实现 gRPC 健康检查接口）</span></span><br><span class="line">            <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> GrpcChannelFactory.getChannel(instance.getIp(), instance.getPort());</span><br><span class="line">            HealthCheckGrpc.<span class="type">HealthCheckBlockingStub</span> <span class="variable">stub</span> <span class="operator">=</span> HealthCheckGrpc.newBlockingStub(channel)</span><br><span class="line">                    .withDeadlineAfter(TIMEOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="type">HealthCheckResponse</span> <span class="variable">response</span> <span class="operator">=</span> stub.check(request);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 更新实例健康状态</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newHealthy</span> <span class="operator">=</span> response.getStatus() == HealthCheckResponse.ServingStatus.SERVING;</span><br><span class="line">            updateInstanceHealthStatus(newHealthy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 探活失败，标记为不健康</span></span><br><span class="line">            updateInstanceHealthStatus(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新实例健康状态并发布事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInstanceHealthStatus</span><span class="params">(<span class="type">boolean</span> healthy)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oldHealthy</span> <span class="operator">=</span> instance.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (oldHealthy == healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 状态无变化，不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新健康状态</span></span><br><span class="line">        instance.setHealthy(healthy);</span><br><span class="line">        <span class="comment">// 发布健康状态变更事件（触发推送、集群同步）</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">HealthStateChangeEvent</span>(instance.getInstanceId(), healthy));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（四）健康状态判断与实例剔除"><a href="#（四）健康状态判断与实例剔除" class="headerlink" title="（四）健康状态判断与实例剔除"></a>（四）健康状态判断与实例剔除</h3><p>服务端通过 “探活失败次数” 而非固定时间判断实例状态，默认规则：</p><ol><li>连续 1 次探活失败 → 标记实例为 <code>healthy=false</code>；</li><li>连续 3 次探活失败（累计 60 秒） → 从注册表中移除实例（仅临时实例）；</li><li>持久化实例探活失败不会被剔除，仅标记为不健康。</li></ol><p>实例剔除逻辑在 <code>InstanceCleaner</code> 中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.core.InstanceCleaner</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCleaner</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceManager serviceManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听健康状态变更事件，触发剔除判断</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHealthChange</span><span class="params">(HealthStateChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">instanceId</span> <span class="operator">=</span> event.getInstanceId();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">healthy</span> <span class="operator">=</span> event.isHealthy();</span><br><span class="line">        <span class="keyword">if</span> (healthy) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询实例</span></span><br><span class="line">        <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> instanceManager.getInstanceById(instanceId);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span> || !instance.isEphemeral()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累计探活失败次数</span></span><br><span class="line">        instance.incrementHealthFailureCount();</span><br><span class="line">        <span class="comment">// 连续 3 次失败，剔除实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance.getHealthFailureCount() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            serviceManager.removeInstance(instance.getNamespaceId(), instance.getServiceName(), instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、服务变动集群同步源码剖析"><a href="#八、服务变动集群同步源码剖析" class="headerlink" title="八、服务变动集群同步源码剖析"></a>八、服务变动集群同步源码剖析</h2><p>Nacos 2.X 集群同步采用 “Raft 协议（持久化实例）+ Distro 协议（临时实例）” 混合方案，确保数据一致性与性能平衡。</p><h3 id="（一）临时实例同步：Distro-协议"><a href="#（一）临时实例同步：Distro-协议" class="headerlink" title="（一）临时实例同步：Distro 协议"></a>（一）临时实例同步：Distro 协议</h3><p>临时实例存储在内存，通过 Distro 协议实现 最终一致性 同步，核心是”分片+主动推送”。</p><ol><li>Distro 分片策略</li></ol><p>每个 Nacos 节点负责部分实例的同步（按 <code>instanceId</code> 哈希分片），避免全量同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroHashMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroHashMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 instanceId 计算分片，确定负责节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">mapInstanceToServers</span><span class="params">(String instanceId, List&lt;String&gt; allServers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> Math.abs(instanceId.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash % allServers.size();</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(allServers.get(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步实现：<code>DistroDataSyncService</code></li></ol><p>当临时实例变动时，节点向负责该实例的其他节点推送同步数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.DistroDataSyncService</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistroDataSyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DistroHashMapper hashMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GrpcClient grpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步临时实例变动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncEphemeralInstance</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 计算负责该实例的节点</span></span><br><span class="line">        List&lt;String&gt; targetServers = hashMapper.mapInstanceToServers(instance.getInstanceId(), serverListManager.getServerList());</span><br><span class="line">        <span class="comment">// 2. 构建同步数据</span></span><br><span class="line">        <span class="type">DistroData</span> <span class="variable">data</span> <span class="operator">=</span> DistroDataBuilder.buildInstanceData(instance);</span><br><span class="line">        <span class="comment">// 3. 向目标节点推送同步请求</span></span><br><span class="line">        <span class="keyword">for</span> (String server : targetServers) &#123;</span><br><span class="line">            syncToServer(server, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 同步请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">syncToServer</span><span class="params">(String server, DistroData data)</span> &#123;</span><br><span class="line">        <span class="type">DistroSyncRequest</span> <span class="variable">request</span> <span class="operator">=</span> DistroSyncRequest.newBuilder()</span><br><span class="line">                .setData(ByteString.copyFrom(data.getContent()))</span><br><span class="line">                .build();</span><br><span class="line">        grpcClient.sendRequest(server, request, DistroSyncResponse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）持久化实例同步：Raft-协议"><a href="#（二）持久化实例同步：Raft-协议" class="headerlink" title="（二）持久化实例同步：Raft 协议"></a>（二）持久化实例同步：Raft 协议</h3><p>持久化实例存储在 MySQL，通过 Raft 协议实现 强一致性 同步，确保所有节点数据一致。</p><ol><li>Raft 核心实现：<code>RaftCore</code></li></ol><p>负责 Raft 协议的 ** Leader 选举、日志复制、数据提交**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.raft.RaftCore</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaftCore</span> &#123;</span><br><span class="line">    <span class="comment">// Raft 状态（FOLLOWER/CANDIDATE/LEADER）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RaftPeer.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> RaftPeer.State.FOLLOWER;</span><br><span class="line">    <span class="comment">// Raft 日志（存储所有变更操作）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogEntry&gt; logEntries = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Leader 选举（省略细节，核心是投票机制）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 触发选举逻辑，获取其他节点投票，得票超过半数成为 Leader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 日志复制（Leader 向 Follower 同步日志）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replicateLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != RaftPeer.State.LEADER) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;非 Leader 节点，无法复制日志&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加日志到本地</span></span><br><span class="line">        logEntries.add(entry);</span><br><span class="line">        <span class="comment">// 向所有 Follower 节点复制日志</span></span><br><span class="line">        <span class="keyword">for</span> (String follower : followerList) &#123;</span><br><span class="line">            replicateToFollower(follower, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 数据提交（日志复制到多数节点后，提交数据）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitLog</span><span class="params">(LogEntry entry)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查日志是否已复制到多数节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLogReplicatedToMajority(entry.getIndex())) &#123;</span><br><span class="line">            <span class="comment">// 提交日志（更新本地注册表）</span></span><br><span class="line">            commitEntry(entry);</span><br><span class="line">            <span class="comment">// 通知 Follower 提交日志</span></span><br><span class="line">            notifyFollowersCommit(entry.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>持久化实例同步触发</li></ol><p>当持久化实例变动时，Leader 节点通过 Raft 日志复制同步到所有 Follower 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.naming.consistency.implementation.RaftConsistencyServiceImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 Raft 日志条目</span></span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> LogEntry.newBuilder()</span><br><span class="line">            .setKey(key)</span><br><span class="line">            .setValue(ByteString.copyFrom(SerializeUtils.serialize(value)))</span><br><span class="line">            .setType(LogEntryType.WRITE)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2. Leader 节点复制日志</span></span><br><span class="line">    raftCore.replicateLog(entry);</span><br><span class="line">    <span class="comment">// 3. 等待日志提交</span></span><br><span class="line">    raftCore.waitForLogCommit(entry.getIndex(), <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h2&gt;&lt;p&gt;Nacos 作为阿里开源的分布式服务发现与配置管理平台，2.X 版本在架构上进行了协议升级（HTTP→gRPC）、存储结构优</summary>
      
    
    
    
    <category term="中间件" scheme="https://goofysatoshi.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Nacos" scheme="https://goofysatoshi.github.io/tags/Nacos/"/>
    
    <category term="源码剖析" scheme="https://goofysatoshi.github.io/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="分布式服务治理" scheme="https://goofysatoshi.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 核心源码学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/08/26/Nacos-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/08/26/Nacos-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-26T15:43:00.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-核心源码学习笔记"><a href="#Nacos-核心源码学习笔记" class="headerlink" title="Nacos 核心源码学习笔记"></a>Nacos 核心源码学习笔记</h1><p>Nacos 作为微服务架构中核心的服务注册发现与配置中心，其底层设计与实现逻辑对理解微服务治理至关重要。本文从源码入口、服务注册、心跳检测、集群一致性四个核心维度，梳理 Nacos 关键机制的实现原理。</p><h2 id="一、源码入口与初始化机制"><a href="#一、源码入口与初始化机制" class="headerlink" title="一、源码入口与初始化机制"></a>一、源码入口与初始化机制</h2><h3 id="1-源码入口定位"><a href="#1-源码入口定位" class="headerlink" title="1. 源码入口定位"></a>1. 源码入口定位</h3><p>分析 Nacos 源码时，可通过启动脚本定位启动类，或直接聚焦服务发现核心 Jar 包（如 <code>nacos-discovery</code>）。其初始化逻辑依赖 <strong>Spring Boot SPI 机制</strong>，核心流程如下：</p><ul><li>在 <code>META-INF/spring.factories</code> 中配置自动配置类（如服务发现场景的 <code>NacosDiscoveryAutoConfiguration</code>）；</li><li>启用 Jar 包时，Spring 容器通过 <code>@EnableAutoConfiguration</code> 触发自动配置类加载；</li><li>自动配置类初始化 <code>NacosServiceRegistry</code>（服务注册）、<code>NacosDiscoveryClient</code>（服务发现）等核心组件，并向 Nacos 服务端发起请求，建立基础通信链路。</li></ul><h2 id="二、服务注册流程与高并发设计"><a href="#二、服务注册流程与高并发设计" class="headerlink" title="二、服务注册流程与高并发设计"></a>二、服务注册流程与高并发设计</h2><h3 id="1-核心注册流程"><a href="#1-核心注册流程" class="headerlink" title="1. 核心注册流程"></a>1. 核心注册流程</h3><ol><li>客户端封装服务信息（IP、端口、服务名等）为 <code>Instance</code> 对象，发送注册请求至服务端；</li><li>服务端接收请求后，先将 <code>Instance</code> 存入 <code>BlockingQueue</code> 阻塞队列，作为请求缓冲层；</li><li>后台专用线程从队列中持续取出 <code>Instance</code>，写入注册表（嵌套 <code>Map</code> 结构：<code>serviceName -&gt; cluster -&gt; Instance</code>）。</li></ol><h3 id="2-高并发支撑策略"><a href="#2-高并发支撑策略" class="headerlink" title="2. 高并发支撑策略"></a>2. 高并发支撑策略</h3><ul><li><strong>阻塞队列缓冲</strong>：通过“生产者-消费者”模式解耦请求接收与数据写入，避免直接操作注册表导致的锁竞争；</li><li><strong>读写分离架构</strong>：<ul><li>写操作（注册&#x2F;更新）：拷贝目标服务的 <code>Instance</code> 集合（<code>Set</code>），在副本中修改，不影响原集合；</li><li>读操作（服务发现）：直接从原 <code>Set</code> 读取数据，保证查询无阻塞；</li></ul></li><li><strong>原子替换</strong>：修改完成后，用新 <code>Set</code> 原子替换原 <code>Set</code>，兼顾数据一致性与并发效率。</li></ul><h2 id="三、心跳检测机制"><a href="#三、心跳检测机制" class="headerlink" title="三、心跳检测机制"></a>三、心跳检测机制</h2><h3 id="1-客户端心跳发送"><a href="#1-客户端心跳发送" class="headerlink" title="1. 客户端心跳发送"></a>1. 客户端心跳发送</h3><p>服务实例注册成功后，客户端默认每 <strong>5 秒</strong> 向 Nacos 服务端发送心跳请求，携带实例 ID 等唯一标识信息。</p><h3 id="2-服务端健康检查"><a href="#2-服务端健康检查" class="headerlink" title="2. 服务端健康检查"></a>2. 服务端健康检查</h3><p>服务端维护每个实例的“最后心跳时间”，通过时间差判断实例健康状态：</p><ul><li>若 <code>当前时间 - 最后心跳时间 &gt; 15 秒</code>：标记实例为不健康（<code>healthy = false</code>），服务发现时不返回该实例；</li><li>若 <code>当前时间 - 最后心跳时间 &gt; 30 秒</code>：直接从注册表中移除实例，视为服务下线。</li></ul><h2 id="四、集群-CP-模式与-Raft-协议"><a href="#四、集群-CP-模式与-Raft-协议" class="headerlink" title="四、集群 CP 模式与 Raft 协议"></a>四、集群 CP 模式与 Raft 协议</h2><h3 id="1-CP-模式适用场景"><a href="#1-CP-模式适用场景" class="headerlink" title="1. CP 模式适用场景"></a>1. CP 模式适用场景</h3><p>通过配置 <code>nacos.core.protocol=cp</code> 开启 CP 模式，适用于数据一致性要求极高的场景（如金融领域服务注册）。</p><h3 id="2-Raft-协议核心作用"><a href="#2-Raft-协议核心作用" class="headerlink" title="2. Raft 协议核心作用"></a>2. Raft 协议核心作用</h3><p>服务注册、实例状态变更等操作会触发 Raft 协议，保障集群数据一致性：</p><ul><li><strong>Leader 选举</strong>：集群节点通过 Raft 选举产生 Leader，由 Leader 统一处理客户端请求并协调数据同步；</li><li><strong>日志复制</strong>：Leader 将数据变更记录为日志，同步至所有 Follower 节点，待多数节点确认后才提交变更（如写入注册表）；</li><li>基于 Raft 协议，Nacos 集群在节点故障、网络分区时仍能保证数据一致，实现高可靠服务治理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos-核心源码学习笔记&quot;&gt;&lt;a href=&quot;#Nacos-核心源码学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Nacos 核心源码学习笔记&quot;&gt;&lt;/a&gt;Nacos 核心源码学习笔记&lt;/h1&gt;&lt;p&gt;Nacos 作为微服务架构中核心的服务注册发</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Nacos" scheme="https://goofysatoshi.github.io/tags/Nacos/"/>
    
    <category term="微服务" scheme="https://goofysatoshi.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="源码分析" scheme="https://goofysatoshi.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud OpenFeign 学习笔记</title>
    <link href="https://goofysatoshi.github.io/2025/08/26/Spring-Cloud-OpenFeign-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goofysatoshi.github.io/2025/08/26/Spring-Cloud-OpenFeign-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-26T07:13:19.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<p>一、服务调用方式对比<br>在 Spring Cloud 中，引入 OpenFeign 之前，常使用 Ribbon（负载均衡器）与 RestTemplate 进行服务间调用。但此方式代码耦合性强，维护性与可读性差，修改不便。而 Spring Cloud OpenFeign 采用依赖注入方式调用，如同调用本地 service，极大提升了代码的简洁性与可维护性。</p><p>二、OpenFeign 使用步骤</p><ol><li>引入依赖：在项目中引入 OpenFeign 的相关 Maven 依赖。</li><li>添加注解：在 Spring Boot 启动类上添加 @EnableFeignClients 注解，开启 Feign 客户端功能。</li><li>定义接口：</li></ol><ul><li>方式一：在自定义的 SDK 中定义带有 @FeignClient 注解的接口。</li><li>方式二：自行定义 OpenFeign 接口，该接口用于声明服务调用方法。</li></ul><ol start="4"><li>注入使用：将定义好的 Feign 接口注入到需要调用的地方，即可实现服务间的远程调用。<br>三、OpenFeign 接口参数处理</li></ol><ul><li>默认 <strong>@RequestBody</strong>：若接口参数未添加其他注解，OpenFeign 默认添加 @RequestBody 注解。但 @RequestBody 通常只能接收一个对象，传入多个对象会报错。</li><li>GET 请求参数：对于 GET 类型请求，可写多个基本类型参数，这些参数会自动拼接到 URL 上。若想用 form 表单形式传递参数，可使用 @SpringQueryMap 注解，同样会将参数拼接到 URL 上。<br>四、OpenFeign 结构与原理</li><li>服务端与调用端：<ul><li>服务提供端：通过在接口方法上添加 @FeignClient 注解，将服务封装成接口方法，并打包成 SDK。</li><li>服务调用端：引入服务提供端的 SDK，在 Spring Boot 启动时，利用 JDK 动态代理生成代理对象，并注入到 Bean 容器中。当调用接口方法时，通过 InvocationHandler 调用处理器进行远程调用。</li></ul></li><li>处理流程：<ul><li>调用接口方法后，<strong>Contract</strong> 根据注解声明的规则解析底层的 <strong>MethodHandler</strong>。</li><li>MethodHandler 底层调用 <strong>RequestTemplate</strong>，<strong>RequestTemplate</strong> 内部实现了编码和解码功能。服务发起端对请求进行编码，服务调用端在解析返回结果时进行解码。</li><li>最外层有 Interceptors 拦截器，用于对请求和响应进行拦截，例如记录日志等操作。</li><li>Feign Client 基于负载均衡器和重试器进行策略调控。请求到达服务调用端后，经过解码，<strong>MethodHandler</strong> 根据规则映射找到调用的方法，通过处理器获取 InvocationHandler 的调用结果，并解析成 Response 的 Bean。<br>五、OpenFeign 增强方式<br>（一）日志增强</li></ul></li><li>配置 Feign 的 Config Bean 对象：通过配置该 Bean 对象可实现日志增强。</li><li>YAML 文件配置：在 YAML 文件中进行配置，更为灵活且支持配置中心实时更改。</li><li>日志级别：<ul><li>NONE：不记录日志。</li><li>BASIC：仅记录请求方法、URL、响应状态代码及执行时间。</li><li>HEADERS：在 BASIC 基础上记录请求和响应的 Header。</li><li>FULL：全量记录请求、响应的 Header、Body 及原始数据。<br>（二）HTTP 连接优化</li></ul></li><li>引入 Feign HC5：OpenFeign 默认的 HTTP 连接无连接池，性能较差。引入 <strong>Feign HC5</strong>（Apache HTTP5 的实现）依赖，其内部自带连接池，可优化调用效率，减少连接的频繁创建与销毁。由于 OpenFeign 的自动配置类已将相关属性默认配置为启用状态，因此即便不在 YAML 中配置，引入依赖后也会生效。</li><li>替换为 OKHTTP：除 Feign HC5 外，还可引入 OKHTTP 依赖，并在 YAML 中开启 OKHTTP 配置，将底层 HTTP 请求替换为 OKHTTP。<br>（三）压缩配置</li><li>gzip 压缩：OpenFeign 支持 gzip 压缩配置，当请求超过某个阈值（如 1024 字节），可在 YAML 中开启 gzip 压缩，并配置需要压缩的请求类型及最小压缩阈值等参数，以优化请求体大小和传输效率。</li><li>OKHTTP 特殊情况：若使用 OKHTTP 作为底层 HTTP 请求，因其内部默认使用 transparent 压缩方式，一般无需额外配置 gzip 压缩。<br>（四）自定义编解码器<br>OpenFeign 提供扩展点，可通过实现 Encoder 和 Decoder 接口来自定义编解码器，并在 YAML 中进行配置。</li></ul><p>（五）拦截器实现</p><ul><li>BasicAuthRequestInterceptor：通过注入该 Bean 并进行配置来实现拦截器功能，但此方式灵活性欠佳。</li><li>实现 RequestInterceptor 接口：推荐使用此方式，通过实现接口来定义拦截逻辑，更加灵活。<br>六、YAML 基本配置示例<br>feign:<br>client:<br>config:<br>default:<br>loggerLevel: FULL # 日志级别设置为 FULL<br>httpclient:<br>enabled: true # 启用 Feign HC5 连接池<br>max-connections: 200 # 最大连接数<br>max-connections-per-route: 50 # 每个路由的最大连接数<br>compression:<br>request:<br>enabled: true # 开启请求压缩<br>mime-types: text&#x2F;xml,application&#x2F;xml,application&#x2F;json # 需要压缩的请求类型<br>min-request-size: 1024 # 最小压缩阈值<br>okhttp:<br>enabled: true # 启用 OKHTTP</li></ul><p>在对 OpenFeign 进行配置时，优先考虑 YAML 配置方式，因其可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、服务调用方式对比&lt;br&gt;在 Spring Cloud 中，引入 OpenFeign 之前，常使用 Ribbon（负载均衡器）与 RestTemplate 进行服务间调用。但此方式代码耦合性强，维护性与可读性差，修改不便。而 Spring Cloud OpenFeign </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo 博客文章发布教程</title>
    <link href="https://goofysatoshi.github.io/2025/05/03/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/"/>
    <id>https://goofysatoshi.github.io/2025/05/03/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E6%95%99%E7%A8%8B/</id>
    <published>2025-05-03T19:30:00.000Z</published>
    <updated>2025-09-04T15:08:01.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客文章发布教程"><a href="#Hexo-博客文章发布教程" class="headerlink" title="Hexo 博客文章发布教程"></a>Hexo 博客文章发布教程</h1><p>本教程将详细介绍如何在 Hexo 博客中创建和发布文章，包括文章的基本结构、常用配置和发布流程。</p><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><h3 id="1-使用命令行创建"><a href="#1-使用命令行创建" class="headerlink" title="1. 使用命令行创建"></a>1. 使用命令行创建</h3><p>在博客根目录下，使用以下命令创建新文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>这将在 <code>source/_posts</code> 目录下创建一个新的 Markdown 文件，文件名格式为：<code>年-月-日-文章标题.md</code></p><h3 id="2-手动创建"><a href="#2-手动创建" class="headerlink" title="2. 手动创建"></a>2. 手动创建</h3><p>你也可以直接在 <code>source/_posts</code> 目录下手动创建 Markdown 文件，但需要确保文件名格式正确。</p><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>每篇文章都包含两个主要部分：</p><ol><li><strong>Front-matter</strong>：文章头部配置</li><li><strong>正文内容</strong>：文章主体内容</li></ol><h3 id="Front-matter-配置"><a href="#Front-matter-配置" class="headerlink" title="Front-matter 配置"></a>Front-matter 配置</h3><p>Front-matter 是文章开头的配置部分，使用 <code>---</code> 包裹。常用配置项包括：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">年-月-日</span> <span class="string">时:分:秒</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">封面图片路径</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>常用配置项说明：</p><ul><li><code>title</code>: 文章标题</li><li><code>date</code>: 文章创建时间</li><li><code>tags</code>: 文章标签，可以设置多个</li><li><code>categories</code>: 文章分类</li><li><code>cover</code>: 文章封面图片</li><li><code>comments</code>: 是否开启评论（默认为 true）</li></ul><h3 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h3><p>正文使用 Markdown 语法编写，支持：</p><ul><li>标题</li><li>段落</li><li>列表</li><li>代码块</li><li>图片</li><li>表格</li><li>等等</li></ul><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>在发布文章前，建议先在本地预览：</p><ol><li><p>启动本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</p></li></ol><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="1-生成静态文件"><a href="#1-生成静态文件" class="headerlink" title="1. 生成静态文件"></a>1. 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="2-部署到服务器"><a href="#2-部署到服务器" class="headerlink" title="2. 部署到服务器"></a>2. 部署到服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一键生成并部署</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="文章写作建议"><a href="#文章写作建议" class="headerlink" title="文章写作建议"></a>文章写作建议</h2><ol><li><strong>保持结构清晰</strong>：使用合适的标题层级</li><li><strong>添加适当的标签</strong>：便于文章分类和检索</li><li><strong>使用图片</strong>：适当添加图片使文章更生动</li><li><strong>代码格式化</strong>：使用代码块展示代码</li><li><strong>预览检查</strong>：发布前务必预览检查</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p><strong>文章不显示</strong>：</p><ul><li>检查文件名格式是否正确</li><li>确保 Front-matter 格式正确</li><li>尝试清理缓存后重新生成</li></ul></li><li><p><strong>图片不显示</strong>：</p><ul><li>检查图片路径是否正确</li><li>确保图片文件存在</li></ul></li><li><p><strong>格式问题</strong>：</p><ul><li>检查 Markdown 语法是否正确</li><li>确保缩进正确</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，你应该已经掌握了在 Hexo 博客中创建和发布文章的基本方法。记住，好的文章不仅需要好的内容，还需要正确的格式和配置。如果你有任何问题，欢迎在评论区留言讨论！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-博客文章发布教程&quot;&gt;&lt;a href=&quot;#Hexo-博客文章发布教程&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客文章发布教程&quot;&gt;&lt;/a&gt;Hexo 博客文章发布教程&lt;/h1&gt;&lt;p&gt;本教程将详细介绍如何在 Hexo 博客中创建和发布文</summary>
      
    
    
    
    <category term="博客" scheme="https://goofysatoshi.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="教程" scheme="https://goofysatoshi.github.io/categories/%E5%8D%9A%E5%AE%A2/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hexo" scheme="https://goofysatoshi.github.io/tags/Hexo/"/>
    
    <category term="博客" scheme="https://goofysatoshi.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="教程" scheme="https://goofysatoshi.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="工具" scheme="https://goofysatoshi.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel 拉模式实现：基于 SPI 扩展与客户端定时轮询</title>
    <link href="https://goofysatoshi.github.io/2024/10/15/sentinel%E6%8B%89%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://goofysatoshi.github.io/2024/10/15/sentinel%E6%8B%89%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2024-10-15T06:30:00.000Z</published>
    <updated>2025-09-04T15:08:01.038Z</updated>
    
    <content type="html"><![CDATA[<p> </p><p>一、为什么需要 Sentinel 拉模式？</p><p>Sentinel 默认的内存模式存在明显缺陷：限流规则仅存储在客户端内存中，应用重启后规则全部丢失，无法满足生产环境的规则持久化与统一管理需求。</p><p>拉模式是 Sentinel 规则持久化的核心方案之一，其核心逻辑是客户端主动通过定时轮询，从外部存储（如 MySQL、本地文件）拉取规则，并结合 SPI 扩展机制实现自定义数据源，彻底解决“重启失效”问题。本文将完整拆解拉模式的实现流程，基于 MySQL 存储规则，适配 Spring Boot 场景。</p><p>二、拉模式与 SPI 的关系</p><p>在动手实现前，先理清两个关键概念，避免与推模式混淆：</p><p>概念 作用说明<br>拉模式 客户端通过定时任务主动轮询外部存储（如 MySQL），获取最新规则并加载到 Sentinel，实时性取决于轮询间隔。<br>SPI 扩展机制 Sentinel 提供  ReadableDataSource  接口作为 SPI 扩展点，允许自定义“规则读取逻辑”，框架启动时自动扫描加载。 </p><p>三、完整实现步骤（基于 MySQL + Spring Boot）</p><ol><li>环境准备：引入依赖</li></ol><p>在  pom.xml  中添加 Sentinel 核心依赖、SPI 扩展依赖及 MySQL 连接依赖（使用 Druid 连接池简化操作）：</p><!-- 1. Sentinel 核心依赖 --><dependency>    <groupId>com.alibaba.csp</groupId>    <artifactId>sentinel-core</artifactId>    <version>1.8.6</version> <!-- 推荐稳定版，避免兼容性问题 --></dependency><!-- 2. Sentinel DataSource 扩展（SPI 扩展基础） --><dependency>    <groupId>com.alibaba.csp</groupId>    <artifactId>sentinel-datasource-extension</artifactId>    <version>1.8.6</version></dependency><!-- 3. MySQL 连接与连接池 --><dependency>    <groupId>mysql</groupId>    <artifactId>mysql-connector-java</artifactId>    <version>8.0.33</version></dependency><dependency>    <groupId>com.alibaba</groupId>    <artifactId>druid</artifactId>    <version>1.2.16</version></dependency><!-- 4. Spring Boot 基础（若已引入可忽略） --><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter</artifactId>    <version>2.7.15</version></dependency>  <ol start="2"><li>存储设计：创建 MySQL 规则表</li></ol><p>在 MySQL 中创建 Sentinel 限流规则表，用于持久化存储规则配置（支持后续扩展降级、热点规则等）：</p><p>– 数据库：sentinel_db（可自定义）<br>CREATE DATABASE IF NOT EXISTS sentinel_db DEFAULT CHARSET utf8mb4;<br>USE sentinel_db;</p><p>– 限流规则表<br>CREATE TABLE IF NOT EXISTS sentinel_flow_rule (<br>  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT COMMENT ‘主键ID’,<br>  <code>resource</code> varchar(255) NOT NULL COMMENT ‘限流资源名（如接口路径 &#x2F;order&#x2F;create）’,<br>  <code>limit_app</code> varchar(64) DEFAULT ‘default’ COMMENT ‘限制来源（默认所有来源）’,<br>  <code>grade</code> tinyint(1) NOT NULL COMMENT ‘限流类型：1&#x3D;QPS，0&#x3D;线程数’,<br>  <code>count</code> double NOT NULL COMMENT ‘限流阈值（如 QPS&#x3D;10）’,<br>  <code>strategy</code> tinyint(1) DEFAULT 0 COMMENT ‘流控策略：0&#x3D;直接模式，1&#x3D;关联模式，2&#x3D;链路模式’,<br>  <code>control_behavior</code> tinyint(1) DEFAULT 0 COMMENT ‘流控效果：0&#x3D;快速失败，1&#x3D;预热，2&#x3D;排队’,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT ‘Sentinel 限流规则表’;</p><p>– 插入测试数据：对 &#x2F;order&#x2F;create 接口限制 QPS&#x3D;10<br>INSERT INTO sentinel_flow_rule (resource, limit_app, grade, count, strategy, control_behavior)<br>VALUES (‘&#x2F;order&#x2F;create’, ‘default’, 1, 10, 0, 0); </p><ol start="3"><li>核心实现：自定义 SPI 数据源（DataSource）</li></ol><p>拉模式的核心是实现  ReadableDataSource  接口（Sentinel 的 SPI 扩展点），在类中封装“定时轮询逻辑”与“MySQL 规则读取逻辑”。</p><p>3.1 自定义 DataSource 代码</p><p>package com.example.sentinel.datasource;</p><p>import com.alibaba.csp.sentinel.datasource.ReadableDataSource;<br>import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br>import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br>import com.alibaba.druid.pool.DruidDataSource;</p><p>import java.sql.Connection;<br>import java.sql.PreparedStatement;<br>import java.sql.ResultSet;<br>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.ScheduledExecutorService;<br>import java.util.concurrent.TimeUnit;</p><p>&#x2F;**</p><ul><li><p>Sentinel 拉模式数据源：从 MySQL 定时拉取限流规则</p></li><li><p>实现 ReadableDataSource 接口，通过 SPI 被 Sentinel 自动加载<br> *&#x2F;<br>public class MysqlPullFlowRuleDataSource implements ReadableDataSource&lt;Void, List<FlowRule>&gt; {</p><p> &#x2F;&#x2F; 1. 配置参数（生产环境建议从配置文件注入，此处简化为硬编码）<br> private final String jdbcUrl &#x3D; “jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;sentinel_db?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC”;<br> private final String dbUsername &#x3D; “root”; &#x2F;&#x2F; 替换为你的 MySQL 账号<br> private final String dbPassword &#x3D; “123456”; &#x2F;&#x2F; 替换为你的 MySQL 密码<br> private final long pullInterval &#x3D; 5000; &#x2F;&#x2F; 定时轮询间隔：5秒（可根据需求调整）</p><p> &#x2F;&#x2F; 2. 数据库连接池（复用连接，避免频繁创建销毁）<br> private final DruidDataSource druidDataSource;<br> &#x2F;&#x2F; 3. 定时任务线程池（执行规则拉取任务）<br> private final ScheduledExecutorService scheduler;</p><p> &#x2F;**</p><ul><li>构造方法：初始化连接池 + 启动定时轮询<br>  *&#x2F;<br> public MysqlPullFlowRuleDataSource() {<br> &#x2F;&#x2F; 初始化 Druid 连接池<br> this.druidDataSource &#x3D; initDruidDataSource();<br> &#x2F;&#x2F; 初始化定时任务：项目启动立即拉取一次，之后每 5 秒拉取<br> this.scheduler &#x3D; Executors.newSingleThreadScheduledExecutor();<br> this.scheduler.scheduleAtFixedRate(<br>     this::loadRuleToSentinel, &#x2F;&#x2F; 轮询执行的方法：拉取并加载规则<br>     0, &#x2F;&#x2F; 初始延迟：0秒（立即执行）<br>     pullInterval, &#x2F;&#x2F; 轮询间隔<br>     TimeUnit.MILLISECONDS<br> );<br> }</li></ul><p> &#x2F;**</p><ul><li><p>核心1：从 MySQL 读取最新规则<br>  *&#x2F;<br> private List<FlowRule> readRuleFromMysql() {<br> List<FlowRule> flowRules &#x3D; new ArrayList&lt;&gt;();<br> String sql &#x3D; “SELECT resource, limit_app, grade, count, strategy, control_behavior FROM sentinel_flow_rule”;</p><p> &#x2F;&#x2F; try-with-resources 自动关闭连接、Statement<br> try (Connection conn &#x3D; druidDataSource.getConnection();<br>  PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);<br>  ResultSet rs &#x3D; pstmt.executeQuery()) {<br><br> &#x2F;&#x2F; 遍历结果集，转换为 Sentinel 识别的 FlowRule 对象<br> while (rs.next()) {<br>     FlowRule rule &#x3D; new FlowRule();<br>     rule.setResource(rs.getString(“resource”));       &#x2F;&#x2F; 限流资源（接口&#x2F;方法名）<br>     rule.setLimitApp(rs.getString(“limit_app”));     &#x2F;&#x2F; 限制来源<br>     rule.setGrade(rs.getInt(“grade”));               &#x2F;&#x2F; 限流类型（QPS&#x2F;线程数）<br>     rule.setCount(rs.getDouble(“count”));            &#x2F;&#x2F; 限流阈值<br>     rule.setStrategy(rs.getInt(“strategy”));         &#x2F;&#x2F; 流控策略<br>     rule.setControlBehavior(rs.getInt(“control_behavior”)); &#x2F;&#x2F; 流控效果<br>     flowRules.add(rule);<br> }<br> } catch (Exception e) {<br> throw new RuntimeException(“从 MySQL 拉取 Sentinel 规则失败”, e);<br> }<br> return flowRules;</p></li></ul><p> }</p><p> &#x2F;**</p><ul><li>核心2：将 MySQL 中的规则加载到 Sentinel 核心<br>  *&#x2F;<br> private void loadRuleToSentinel() {<br> List<FlowRule> rules &#x3D; readRuleFromMysql();<br> FlowRuleManager.loadRules(rules); &#x2F;&#x2F; 覆盖 Sentinel 本地规则<br> System.out.printf(“[Sentinel 拉模式] 规则加载完成：共 %d 条规则%n”, rules.size());<br> }</li></ul><p> &#x2F;**</p><ul><li>初始化 Druid 连接池（配置基础参数，生产环境需优化）<br>  *&#x2F;<br> private DruidDataSource initDruidDataSource() {<br> DruidDataSource dataSource &#x3D; new DruidDataSource();<br> dataSource.setUrl(jdbcUrl);<br> dataSource.setUsername(dbUsername);<br> dataSource.setPassword(dbPassword);<br> dataSource.setInitialSize(5); &#x2F;&#x2F; 初始连接数<br> dataSource.setMaxActive(20);  &#x2F;&#x2F; 最大连接数<br> dataSource.setMinIdle(3);     &#x2F;&#x2F; 最小空闲连接数<br> return dataSource;<br> }</li></ul><p> &#x2F;&#x2F; ——————- 实现 ReadableDataSource 接口（SPI 强制要求） ——————-<br> @Override<br> public List<FlowRule> readSource() throws Exception {<br>     &#x2F;&#x2F; SPI 机制会调用此方法获取最新规则，直接复用 MySQL 读取逻辑<br>     return readRuleFromMysql();<br> }</p><p> @Override<br> public void close() throws Exception {<br>     &#x2F;&#x2F; 资源销毁：关闭连接池 + 停止定时任务<br>     if (druidDataSource !&#x3D; null) {<br>         druidDataSource.close();<br>     }<br>     if (scheduler !&#x3D; null &amp;&amp; !scheduler.isShutdown()) {<br>         scheduler.shutdown();<br>     }<br> }</p></li></ul><p>} </p><ol start="4"><li>SPI 注册：让 Sentinel 识别自定义数据源</li></ol><p>Sentinel 启动时会扫描  META-INF&#x2F;services  目录下的 SPI 配置文件，自动加载  ReadableDataSource  的实现类。需手动创建配置文件：</p><p>4.1 创建 SPI 配置文件路径</p><p>在项目的  src&#x2F;main&#x2F;resources  目录下，新建路径：<br> META-INF&#x2F;services </p><p>4.2 创建 SPI 配置文件</p><p>在上述路径下创建文件，文件名必须为  com.alibaba.csp.sentinel.datasource.ReadableDataSource （即  ReadableDataSource  接口的全路径）。</p><p>4.3 写入自定义 DataSource 全类名</p><p>在配置文件中添加自定义 DataSource 的完整包名+类名（确保 Sentinel 能扫描到）：</p><p>com.example.sentinel.datasource.MysqlPullFlowRuleDataSource </p><ol start="5"><li>Spring Boot 集成：初始化数据源</li></ol><p>将自定义 DataSource 注册为 Spring Bean，确保项目启动时自动执行构造方法（初始化连接池与定时任务）：</p><p>package com.example.sentinel.config;</p><p>import com.example.sentinel.datasource.MysqlPullFlowRuleDataSource;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;</p><p>@Configuration<br>public class SentinelPullConfig {</p><pre><code>/** * 注册拉模式数据源为 Spring Bean * - initMethod：启动时执行规则加载 * - destroyMethod：关闭时销毁资源（连接池、定时任务） */@Bean(initMethod = &quot;loadRuleToSentinel&quot;, destroyMethod = &quot;close&quot;)public MysqlPullFlowRuleDataSource mysqlPullFlowRuleDataSource() &#123;    return new MysqlPullFlowRuleDataSource();&#125;</code></pre><p>} </p><ol start="6"><li>验证：拉模式是否生效</li></ol><p>1. 启动 Spring Boot 项目<br>控制台会打印  [Sentinel 拉模式] 规则加载完成：共 1 条规则 ，说明定时任务已启动，首次拉取规则成功。<br>2. 修改 MySQL 规则<br>执行 SQL 语句修改阈值（如将 QPS 从 10 改为 5）：<br>UPDATE sentinel_flow_rule SET count &#x3D; 5 WHERE resource &#x3D; ‘&#x2F;order&#x2F;create’;<br> <br>3. 等待轮询间隔<br>5 秒后，控制台会再次打印规则加载日志，说明规则已自动更新。<br>4. 测试接口限流<br>用 Postman 或 JMeter 压测  &#x2F;order&#x2F;create  接口，当 QPS 超过 5 时，接口会返回 Sentinel 限流提示（如  Blocked by Sentinel (flow limiting) ），验证规则生效。</p><p>四、拉模式的优势与注意事项</p><p>优势</p><p>1. 规则持久化：规则存储在 MySQL 中，应用重启后自动拉取，解决默认内存模式的痛点。<br>2. 实现成本低：无需依赖配置中心（如 Nacos、ZooKeeper），仅需定时轮询，适合中小项目。<br>3. 扩展灵活：可替换存储介质（如本地文件、Redis），只需修改  readRuleFromMysql()  中的读取逻辑。</p><p>注意事项</p><p>1. 实时性平衡：轮询间隔越小，实时性越高，但会增加数据库压力（建议设置 3-10 秒）。<br>2. 避免重复加载：确保 DataSource 仅初始化一次（如 Spring Bean 单例），避免多定时任务冲突。<br>3. 生产环境优化：</p><ul><li>数据库连接池参数需根据并发量调整（如最大连接数、超时时间）。</li><li>增加规则缓存，减少数据库查询次数。</li><li>对 SQL 执行异常添加重试机制。</li></ul><p>Sentinel 拉模式的核心是“SPI 扩展自定义 DataSource + 客户端定时轮询”：</p><p>1. 通过 SPI 机制让 Sentinel 加载自定义的“MySQL 规则读取逻辑”；<br>2. 通过定时任务主动拉取规则并注入 Sentinel 核心；<br>3. 最终实现规则的持久化与自动更新，解决默认内存模式的缺陷。</p><p>拉模式适合对规则实时性要求不高、不想依赖配置中心的场景，是中小项目实现 Sentinel 规则持久化的优选方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;/p&gt;
&lt;p&gt;一、为什么需要 Sentinel 拉模式？&lt;/p&gt;
&lt;p&gt;Sentinel 默认的内存模式存在明显缺陷：限流规则仅存储在客户端内存中，应用重启后规则全部丢失，无法满足生产环境的规则持久化与统一管理需求。&lt;/p&gt;
&lt;p&gt;拉模式是 Sentinel 规则持久化</summary>
      
    
    
    
    <category term="中间件" scheme="https://goofysatoshi.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/tags/Sentinel/"/>
    
    <category term="SPI 扩展" scheme="https://goofysatoshi.github.io/tags/SPI-%E6%89%A9%E5%B1%95/"/>
    
    <category term="限流" scheme="https://goofysatoshi.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
    <category term="规则持久化" scheme="https://goofysatoshi.github.io/tags/%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>今日学习笔记：Sentinel 核心原理与关键算法</title>
    <link href="https://goofysatoshi.github.io/2024/05/20/Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95/"/>
    <id>https://goofysatoshi.github.io/2024/05/20/Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95/</id>
    <published>2024-05-20T07:30:00.000Z</published>
    <updated>2025-09-04T15:08:01.038Z</updated>
    
    <content type="html"><![CDATA[<p>一、Sentinel 对外部请求的感知机制</p><p>Sentinel 对请求的感知依赖于 Web 框架适配与拦截器机制，核心是通过自动装配实现请求链路的透明化监控，为后续流量控制提供数据基础。</p><ol><li>实现基础：SPI 与 Spring Boot 自动装配</li></ol><p>Sentinel 提供  sentinel-spring-webmvc-adapter  等适配模块，基于 Spring Boot 的 SPI 机制（META-INF&#x2F;spring.factories） 实现自动配置，无需手动注入拦截器，降低集成成本。</p><ol start="2"><li>启动流程</li></ol><ul><li>Spring Boot 容器启动时，Sentinel 自动加载并注册配置类 SentinelWebAutoConfiguration（用户原表述中“config-auto configuration”修正为标准类名）。</li><li>该配置类向 Spring 容器注入 SentinelWebInterceptor（网络拦截器），拦截所有符合规则的 HTTP 请求（默认拦截 &#x2F;* 路径，可通过配置自定义）。</li></ul><ol start="3"><li>请求处理逻辑</li></ol><ul><li>拦截器的  preHandle  方法（请求处理前执行）会提取请求关键信息：URL 路径（如 &#x2F;api&#x2F;user）、请求来源（serviceName）、HTTP 方法（GET&#x2F;POST）等。</li><li>将提取的信息封装为 ResourceEntry 对象（Sentinel 中的“资源”载体，每个 ResourceEntry 对应一个可监控的请求节点），并将该资源的调用数据（如调用次数、耗时）上报至 Sentinel 核心引擎。</li><li>核心引擎基于 ResourceEntry 的数据感知请求链路，为后续的限流、熔断、降级规则提供“靶向监控”能力（仅针对已感知的资源生效规则）。</li></ul><p>二、Sentinel 核心算法</p><p>Sentinel 的流量控制、熔断降级功能依赖三大核心算法，分别对应“实时统计”“匀速排队”“突发流量兼容”三类场景，覆盖不同业务需求。</p><ol><li>滑动时间窗口算法（核心统计算法）</li></ol><p>核心思想</p><p>基于 前缀和思想 实现实时流量统计：将“一段时间区间”（如1秒）划分为多个连续的“小格子”（如10个100ms的格子），每个格子存储该时间段内的请求数、QPS、异常数等指标；统计时通过“当前时间对应的格子数据 + 未过期格子数据总和”计算总流量，避免传统“固定时间窗口”的统计偏差（如1秒窗口在0:59和1:01的瞬时高流量无法识别）。</p><p>底层实现</p><ul><li>数据存储：将时间窗口抽象为  MetricBucket  类（存储 pass&#x2F;block&#x2F;exception 等指标），用数组（ MetricArray ）存储多个  MetricBucket ，每个数组元素对应一个“小格子”（格子粒度可配置，粒度越细统计越精准，但内存消耗略高）。</li><li>初始化逻辑：首次有请求进入时，初始化时间窗口数组，确定每个格子的时间范围（如第1个格子对应 0-100ms，第2个对应 100-200ms）。</li><li>时钟回拨处理：若服务器时钟发生回拨（如窗口终止时间 &lt; 当前时间），直接丢弃过期格子数据并创建新窗口，避免因时钟异常导致的统计错误（正常生产环境极少触发，属于容错机制）。</li><li>适用场景：所有需要实时统计流量的场景（如 QPS 限流、并发数控制），是 Sentinel 最基础的算法。</li></ul><ol start="2"><li>漏桶算法（匀速排队机制）</li></ol><p>核心思想</p><p>模拟“漏桶倒水”过程：请求像“水流”一样进入漏桶，漏桶以 固定速率（如每秒100个请求）将请求“漏出”到业务系统；若请求进入速率超过漏桶漏出速率，多余请求会在桶内排队（或直接丢弃，取决于配置），确保业务系统接收的请求速率平稳，避免瞬时高负载。</p><p>处理逻辑</p><ul><li>计算请求等待时间：根据“当前桶内排队请求数”和“漏出速率”，计算当前请求需等待的最小时间（如桶内有5个请求，漏出速率100个&#x2F;秒，则需等待 5*10ms&#x3D;50ms）。</li><li>等待与放行：若等待时间在“最大排队时间”（如100ms）内，请求会睡眠至等待时间结束后放行；若等待时间超出最大排队时间，直接放行（避免请求排队过久导致超时）。</li><li>超时拦截：校验“请求到达时间 + 等待时间”是否超过“请求超时时间”，若已超时则直接拦截（返回 block 信号），避免无效等待。</li><li>适用场景：要求请求严格匀速处理的场景（如数据库写入、第三方接口调用，避免瞬时请求压垮下游服务）。</li></ul><ol start="3"><li>令牌桶算法（缓存预热机制）</li></ol><p>核心思想</p><p>模拟“令牌生成与消耗”过程：Sentinel 按 预设速率（可配置） 定时向“令牌桶”中放入令牌（如每秒生成100个令牌），请求必须从桶中获取1个令牌才能放行；若桶内无令牌，请求会被限流（返回降级&#x2F;熔断信息）。同时支持“缓存预热（冷启动）”，避免服务刚启动时令牌生成过多导致的瞬时高负载。</p><p>处理逻辑</p><ul><li>令牌生成：令牌桶有固定容量（如200个令牌），当桶内令牌数未达容量时，按“预热速率”生成令牌（预热阶段速率从低到高逐步提升，如初始50个&#x2F;秒，10秒后升至100个&#x2F;秒）；当桶满时，新生成的令牌直接丢弃。</li><li>请求处理：请求到达时，先检查桶内是否有剩余令牌：</li><li>若有令牌：获取1个令牌，请求正常放行，并记录请求数据。</li><li>若无令牌：触发限流逻辑，返回降级响应（如默认提示“系统繁忙，请稍后再试”，可自定义降级页面）。</li><li>突发流量兼容：令牌桶的容量决定了最大突发流量处理能力（如桶容量200，当瞬时有200个请求时，可一次性消耗所有令牌，后续请求需等待新令牌生成）。</li><li>适用场景：允许一定突发流量的场景（如 API 网关、用户登录接口，既控制长期流量，又兼容短时间内的流量峰值）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Sentinel 对外部请求的感知机制&lt;/p&gt;
&lt;p&gt;Sentinel 对请求的感知依赖于 Web 框架适配与拦截器机制，核心是通过自动装配实现请求链路的透明化监控，为后续流量控制提供数据基础。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现基础：SPI 与 Spring Boot 自</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://goofysatoshi.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Sentinel" scheme="https://goofysatoshi.github.io/tags/Sentinel/"/>
    
    <category term="流量控制" scheme="https://goofysatoshi.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
    <category term="微服务" scheme="https://goofysatoshi.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Java" scheme="https://goofysatoshi.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
