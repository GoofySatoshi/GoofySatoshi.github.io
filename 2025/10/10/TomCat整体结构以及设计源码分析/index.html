<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tomcat 整体结构以及设计源码分析 | GoofySatoshi's Blog</title><meta name="author" content="GoofySatoshi"><meta name="copyright" content="GoofySatoshi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Tomcat是什么？Tomcat 是一款开源的 Java Web 服务器 + Servlet 容器，由 Apache 软件基金会开发维护，主要用于部署和运行 Java Web 应用程序（如基于 Servlet、JSP、Spring MVC 等技术的应用）。它是 Java 生态中最流行的 Web 容器之一，兼具轻量性、稳定性和易扩展性，广泛用于开发和生产环境。 123456789apache-">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat 整体结构以及设计源码分析">
<meta property="og:url" content="https://icarus-blog.top/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="GoofySatoshi&#39;s Blog">
<meta property="og:description" content="1. Tomcat是什么？Tomcat 是一款开源的 Java Web 服务器 + Servlet 容器，由 Apache 软件基金会开发维护，主要用于部署和运行 Java Web 应用程序（如基于 Servlet、JSP、Spring MVC 等技术的应用）。它是 Java 生态中最流行的 Web 容器之一，兼具轻量性、稳定性和易扩展性，广泛用于开发和生产环境。 123456789apache-">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icarus-blog.top/img/avatar.jpg">
<meta property="article:published_time" content="2025-10-10T00:00:00.000Z">
<meta property="article:modified_time" content="2025-10-21T15:16:32.628Z">
<meta property="article:author" content="GoofySatoshi">
<meta property="article:tag" content="Tomcat">
<meta property="article:tag" content="Tomcat 架构">
<meta property="article:tag" content="Servlet 容器">
<meta property="article:tag" content="Pipeline-Valve 模式">
<meta property="article:tag" content="LifeCycle 接口">
<meta property="article:tag" content="Tomcat 源码分析">
<meta property="article:tag" content="Web 应用部署">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icarus-blog.top/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tomcat 整体结构以及设计源码分析",
  "url": "https://icarus-blog.top/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/",
  "image": "https://icarus-blog.top/img/avatar.jpg",
  "datePublished": "2025-10-10T00:00:00.000Z",
  "dateModified": "2025-10-21T15:16:32.628Z",
  "author": [
    {
      "@type": "Person",
      "name": "GoofySatoshi",
      "url": "https://icarus-blog.top"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://icarus-blog.top/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tomcat 整体结构以及设计源码分析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style>
  /* 1. 禁用侧边栏头像旋转（核心） */
  .sidebar-card .card-author .author-avatar img,
  .sidebar-card .card-author .author-avatar img:hover {
    transform: none !important;
    transition: none !important;
  }
  /* 2. 兼容移动端/其他头像容器 */
  .author-avatar img,
  .author-avatar img:hover {
    transform: none !important;
    transition: none !important;
  }
  /* 3. 避免主题其他样式干扰 */
  [class*="avatar"] img,
  [class*="avatar"] img:hover {
    transform: none !important;
    transition: none !important;
  }
  /* 针对id="page-header"的头部区域设置透明 */
  #page-header {
    background-color: transparent !important; /* 强制透明背景 */
    background-image: none !important; /* 清除可能的背景图 */
    box-shadow: none !important; /* 去除阴影（若有） */
  }

  /* 修复头部内部元素的背景（如导航栏） */
  #page-header .header-inner {
    background-color: transparent !important;
  }

  /* 调整头部文字颜色（根据你的背景图明暗度修改） */
  #page-header .nav-item a,
  #page-header .site-title,
  #page-header .site-subtitle {
    color: #333 !important; /* 深色文字，背景浅时用；反之用#fff */
  }
    /* 确保背景图显示样式正确 */
  body {
  background-repeat: no-repeat !important;
  background-attachment: fixed !important;
  background-size: cover !important;
  background-position: center !important;
  }
</style>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="GoofySatoshi's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.png" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GoofySatoshi's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Tomcat 整体结构以及设计源码分析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Tomcat 整体结构以及设计源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-10T00:00:00.000Z" title="发表于 2025-10-10 08:00:00">2025-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-21T15:16:32.628Z" title="更新于 2025-10-21 23:16:32">2025-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Web/">Java Web</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Web/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Web/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat/">Tomcat</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-Tomcat是什么？"><a href="#1-Tomcat是什么？" class="headerlink" title="1. Tomcat是什么？"></a>1. Tomcat是什么？</h1><p>Tomcat 是一款<strong>开源的 Java Web 服务器 + Servlet 容器</strong>，由 Apache 软件基金会开发维护，主要用于部署和运行 Java Web 应用程序（如基于 Servlet、JSP、Spring MVC 等技术的应用）。它是 Java 生态中最流行的 Web 容器之一，兼具轻量性、稳定性和易扩展性，广泛用于开发和生产环境。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-<span class="number">10.0</span><span class="number">.0</span>/</span><br><span class="line">├── <span class="built_in">bin</span>/                <span class="comment"># 脚本与可执行文件目录</span></span><br><span class="line">├── conf/               <span class="comment"># 配置文件目录</span></span><br><span class="line">├── lib/                <span class="comment"># 核心依赖库目录</span></span><br><span class="line">├── webapps/            <span class="comment"># Web 应用部署目录</span></span><br><span class="line">├── logs/               <span class="comment"># 日志文件目录</span></span><br><span class="line">├── temp/               <span class="comment"># 临时文件目录</span></span><br><span class="line">├── work/               <span class="comment"># JSP 编译缓存目录</span></span><br><span class="line">└── LICENSE、NOTICE 等  <span class="comment"># 许可证和说明文件</span></span><br></pre></td></tr></table></figure>
<img width="3182" height="870" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/d66e17b1-c5e5-4c58-b54e-464dc92b3c83" />



<h1 id="2-WEB应用部署的三种方式"><a href="#2-WEB应用部署的三种方式" class="headerlink" title="2. WEB应用部署的三种方式"></a>2. WEB应用部署的三种方式</h1><h3 id="2-1-自动部署（Webapps-目录部署）"><a href="#2-1-自动部署（Webapps-目录部署）" class="headerlink" title="2.1 自动部署（Webapps 目录部署）"></a>2.1 自动部署（Webapps 目录部署）</h3><p>这是最简便、最常用的部署方式，适合开发环境或简单场景，依赖 Tomcat 的自动检测机制。</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>Tomcat 启动时会自动扫描 <code>webapps/</code> 目录（默认部署目录），对目录中的 Web 应用（包括 <strong>WAR 包</strong> 或 <strong>解压后的应用目录</strong>）进行部署；运行过程中，若向 <code>webapps/</code> 目录添加新的应用（如复制 WAR 包），Tomcat 也会自动检测并部署（需开启自动部署配置，默认开启）。</p>
<h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p>将 Web 应用打包为 WAR 包（如 <code>myapp.war</code>），或直接获取解压后的应用目录（如 <code>myapp/</code>）。</p>
</li>
<li><p>将 WAR 包或目录复制到 Tomcat 的 <code>webapps/</code> 目录下。</p>
</li>
<li><p>启动 Tomcat（<code>bin/startup.sh</code> 或 <code>startup.bat</code>），Tomcat 会自动处理：</p>
<ul>
<li><p>若为 WAR 包：自动解压为同名目录（如 <code>myapp.war</code> → <code>myapp/</code>）。</p>
</li>
<li><p>若为目录：直接识别为 Web 应用。</p>
</li>
</ul>
</li>
<li><p>访问应用：通过 <code>http://localhost:8080/应用名</code> 访问（如 <code>http://localhost:8080/myapp</code>）。</p>
</li>
</ol>
<h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul>
<li><p><strong>优点</strong>：操作简单，无需手动配置，适合开发调试或快速部署。</p>
</li>
<li><p><strong>缺点</strong>：灵活性低（应用必须放在 <code>webapps/</code> 目录）；若需修改应用路径或配置，需额外操作。</p>
</li>
</ul>
<h3 id="2-2-配置文件部署（Context-配置部署）"><a href="#2-2-配置文件部署（Context-配置部署）" class="headerlink" title="2.2 配置文件部署（Context 配置部署）"></a>2.2 配置文件部署（Context 配置部署）</h3><p>通过手动配置 Tomcat 的 XML 配置文件，指定应用的部署路径和实际存储位置，适合需要自定义部署路径（非 <code>webapps/</code> 目录）或复杂配置的场景。</p>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>Tomcat 通过 <strong>Context 元素</strong> 定义 Web 应用的映射关系（访问路径 → 实际目录）。Context 配置可放在两个位置：</p>
<ul>
<li>在 <code>conf/server.xml</code> 中配置（不推荐）</li>
</ul>
<p>在 <code>server.xml</code> 的 <code>&lt;Host&gt;</code> 标签内添加 <code>&lt;Context&gt;</code> 元素，指定应用的访问路径和实际位置。</p>
<p><strong>示例</strong>：</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Service</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">...</span>&gt;</span><span class="comment">&lt;!-- 配置 myapp 应用：访问路径为 /myapp，实际目录为 /opt/apps/myapp --&gt;</span><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/myapp&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;/opt/apps/myapp&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">Host</span>&gt;</span><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span><span class="tag">&lt;/<span class="name">Service</span>&gt;</span><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>path</code>：应用的访问路径（如 <code>/myapp</code> 对应 <code>http://localhost:8080/myapp</code>）。</p>
</li>
<li><p><code>docBase</code>：应用的实际存储路径（可绝对路径或相对 <code>appBase</code> 的路径）。</p>
</li>
<li><p><code>reloadable</code>：是否自动重载（<code>true</code> 表示当应用类文件变化时，Tomcat 自动重启应用，适合开发环境）。</p>
</li>
</ul>
<ul>
<li>在 <code>conf/Catalina/localhost/</code> 下创建独立 XML 文件（推荐）</li>
</ul>
<p>在 <code>conf/Catalina/localhost/</code> 目录下创建以 <strong>应用访问路径</strong> 命名的 XML 文件（如 <code>myapp.xml</code>），文件内容为 <code>&lt;Context&gt;</code> 元素。</p>
<p><strong>示例</strong>：创建 <code>conf/Catalina/localhost/myapp.xml</code>，内容：</p>
<p>xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 访问路径为 /myapp，实际目录为 /opt/apps/myapp --&gt;</span><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;/opt/apps/myapp&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>此时应用的访问路径由 XML 文件名决定（<code>myapp.xml</code> → 访问路径 <code>/myapp</code>）。</p>
</li>
<li><p>无需重启 Tomcat，添加 &#x2F; 修改此文件后，Tomcat 会自动部署 &#x2F; 更新应用（热部署）。</p>
</li>
</ul>
<h4 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h4><ul>
<li><p><strong>优点</strong>：灵活（应用可放在任意目录）、支持热部署（独立 XML 文件方式）、便于集中管理配置。</p>
</li>
<li><p><strong>缺点</strong>：需手动编写配置文件，对新手稍复杂。</p>
</li>
</ul>
<h3 id="2-3-Manager-应用部署（远程管理部署）"><a href="#2-3-Manager-应用部署（远程管理部署）" class="headerlink" title="2.3 Manager 应用部署（远程管理部署）"></a>2.3 Manager 应用部署（远程管理部署）</h3><p>通过 Tomcat 自带的 <strong>Manager 应用</strong>（网页或 API）远程部署应用，适合生产环境中无需直接操作服务器文件系统的场景（如运维人员远程部署）。</p>
<h4 id="前提：配置-Manager-访问权限"><a href="#前提：配置-Manager-访问权限" class="headerlink" title="前提：配置 Manager 访问权限"></a>前提：配置 Manager 访问权限</h4><ol>
<li><p>编辑 <code>conf/tomcat-users.xml</code>，添加具有 <code>manager-gui</code>（网页管理）或 <code>manager-script</code>（API 管理）权限的用户：</p>
</li>
<li><p>xml</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span>&gt;</span><span class="comment">&lt;!-- 允许通过网页管理部署 --&gt;</span><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>重启 Tomcat 使配置生效。</li>
</ol>
<h4 id="操作步骤（网页方式）："><a href="#操作步骤（网页方式）：" class="headerlink" title="操作步骤（网页方式）："></a>操作步骤（网页方式）：</h4><ol>
<li><p>访问 Manager 应用：<code>http://localhost:8080/manager/html</code>，输入配置的用户名 &#x2F; 密码登录。</p>
</li>
<li><p>在 “Deploy” 区域部署应用：</p>
<ul>
<li><p><strong>方式 1（上传 WAR 包）</strong>：点击 “Browse” 选择本地 WAR 包，点击 “Deploy” 上传并部署。</p>
</li>
<li><p><strong>方式 2（指定 URL）</strong>：在 “Context path” 输入访问路径（如 <code>/myapp</code>），在 “WAR or Directory URL” 输入远程 WAR 包的 URL（如 <code>http://example.com/myapp.war</code>），点击 “Deploy”。</p>
</li>
</ul>
</li>
<li><p>部署成功后，可在 “Applications” 列表中看到应用，支持启动、停止、卸载等操作。</p>
</li>
</ol>
<h1 id="3-Tomcat整体架构分析"><a href="#3-Tomcat整体架构分析" class="headerlink" title="3. Tomcat整体架构分析"></a>3. Tomcat整体架构分析</h1><p><strong>Tomcat</strong>本质上只<strong>需要</strong>实现两个核心功能：</p>
<ul>
<li><p>处理Socket连接，负责网络字节流Request和Response对象的转化</p>
</li>
<li><p>加载和管理Servlet，以及具体处理Request请求</p>
</li>
</ul>
<p>因此Tomcat设计两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情，连接器负责对外交流，容器负责内部处理</p>
<img width="2760" height="1400" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/cae9cc54-f3d8-4dba-8875-0deba0771b48" />




<h2 id="3-1-Tom核心组件详解"><a href="#3-1-Tom核心组件详解" class="headerlink" title="3.1 Tom核心组件详解"></a>3.1 Tom核心组件详解</h2><table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Server</strong></td>
<td>整个 Tomcat 实例的顶层容器，代表一个运行的 Tomcat 服务器，可包含多个 Service。</td>
</tr>
<tr>
<td><strong>Service</strong></td>
<td>关联一个或多个 Connector 与一个 Container，负责将请求从 Connector 传递到 Container。</td>
</tr>
<tr>
<td><strong>Connector</strong></td>
<td>监听指定端口（如 8080），接收客户端 HTTP 请求，解析请求数据并传递给 Container，同时将 Container 的响应返回给客户端。支持 HTTP、HTTPS、AJP 等协议。</td>
</tr>
<tr>
<td><strong>Container</strong></td>
<td>负责处理请求的核心组件，内部采用层级结构：</td>
</tr>
<tr>
<td><strong>Servlet</strong></td>
<td>业务逻辑组件，由 Container 调用，处理具体的 HTTP 请求（如接收参数、访问数据库、生成响应）。</td>
</tr>
</tbody></table>
<h3 id="Server组件"><a href="#Server组件" class="headerlink" title="Server组件"></a>Server组件</h3><p>整个 Tomcat 实例的顶层容器，代表一个运行的 Tomcat 服务器，可包含多组服务（ Service ）。负责管理和启动各个Service，同时监听8005端口发送过来的shutdown命令</p>
<h3 id="Service组件"><a href="#Service组件" class="headerlink" title="Service组件"></a>Service组件</h3><p>每个service组件都包含了若干用于接收客户端消息的Connector组件和处理请求的Engine组件，Service组件还包含了若干Executor组件，每个Executor都是一个线程池，它可以为Service内部所有组件提供线程池执行任务。Tomcat内部可能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat内部配置多个Service，可以实现通过不同端口号来访问同一台机器上部署的不同应用</p>
<img width="2760" height="1400" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/e3d8b4e6-f43e-4c1d-a933-1636a6947687" />


<h3 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h3><p>Tomcat与外部世界的连接器，监听固定端口接收外部请求，传递给Container,并将Container处理的结果返回给外部。连接器对Servlet容器屏蔽了不同的应用层协议以及IO模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象</p>
<h3 id="Container组件"><a href="#Container组件" class="headerlink" title="Container组件"></a>Container组件</h3><p>容器，顾名思义就是用来装载对象的器具，在Tomcat里，容器就是用了装载servlet的。tomcat通过分层架构，使得Servlet容器具有很好的灵活性。Tomcat设计了四种容器，分别是Engine、Host、Context和Wrapper。这四种容器并不是平行关系，而是父子关系。</p>
<ul>
<li><p><strong>Engine</strong>：引擎，Servlet的顶层容器，用来管理多个虚拟站点，一个Service最多只能有一个Engine</p>
</li>
<li><p><strong>Host</strong>:虚拟主机，负责web应用的部署和context的创建。可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机可以部署多个Web应用程序</p>
</li>
<li><p><strong>Context</strong>：Web应用程序上下文，包含多个Wrapper，负责Web配置的解析，管理所有的Web资源。一个Context对应一个Web应用程序</p>
</li>
<li><p><strong>Wrapper</strong>:表示一个Servlet,最底层的容器，是对Servlet的封装，负责Servlet实例的创建、执行和销毁</p>
</li>
</ul>
<img width="289" height="290" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/7abb6b51-c53a-4f70-b8b1-90947b6fe8d0" />


<h2 id="3-2-请求定位Servlet的过程"><a href="#3-2-请求定位Servlet的过程" class="headerlink" title="3.2 请求定位Servlet的过程"></a>3.2 请求定位Servlet的过程</h2><p>网络请求先到达 Connector，也就是连接器，它负责监听端口，接收 HTTP 请求。然后，Connector 会把请求封装成 Request 对象，可能还有 Response 对象，然后传递给 Engine 处理。接下来，Engine 会根据请求的 Host 头找到对应的 Host 虚拟主机。Host 再根据请求的上下文路径（Context Path）找到对应的 Context，也就是 Web 应用。然后，Context 内部需要根据请求的 Servlet 路径（Servlet Path）来匹配对应的 Servlet。这里可能涉及到 Web 应用的 web.xml 配置或者注解定义的 Servlet 映射。</p>
<h1 id="4-Tomcat架构设计"><a href="#4-Tomcat架构设计" class="headerlink" title="4. Tomcat架构设计"></a>4. Tomcat架构设计</h1><h2 id="4-1-Connector高内聚低耦合设计"><a href="#4-1-Connector高内聚低耦合设计" class="headerlink" title="4.1 Connector高内聚低耦合设计"></a>4.1 Connector高内聚低耦合设计</h2><p>Tomcat连接器需要实现的功能：</p>
<ul>
<li><p>监听网络端口</p>
</li>
<li><p>接受网络连接请求</p>
</li>
<li><p>读取请求网络字节流</p>
</li>
<li><p>根据具体应用层协议解析字节流，生成统一的TomcatRequest对象</p>
</li>
<li><p>将TomcatRequest对象转化成ServletRequest对象</p>
</li>
<li><p>调用Servlet容器，得到ServletResponse对象</p>
</li>
<li><p>将ServletResponse对象转化成TomcatResponse对象</p>
</li>
<li><p>将TomcatResponse转成网络字节流</p>
</li>
<li><p>将响应字节流写回浏览器</p>
</li>
</ul>
<p>通过连接器需要实现的功能列表，会发现连接器需要实现3个高内聚的功能：</p>
<ul>
<li><p>网络通信</p>
</li>
<li><p>应用层协议解析</p>
</li>
<li><p>Tomcat Request&#x2F;Response 与 Servlet Request&#x2F;Response相互转化</p>
</li>
</ul>
<h3 id="ProtocolHandler"><a href="#ProtocolHandler" class="headerlink" title="ProtocolHandler"></a>ProtocolHandler</h3><blockquote>
<p>因此Tomcat设计者设计了3个组件来实现这3个核心功能，分别是EndPoint、Processor和Adapter</p>
</blockquote>
<ul>
<li><p><strong>Endpoint：</strong>&#x8D1F;责提供字节流给Processor</p>
</li>
<li><p><strong>Processor：</strong>&#x8D1F;责提供TomcatRequest对象给Adapter</p>
</li>
<li><p><strong>Adapter</strong>：负责提供ServletRequest对象给容器</p>
</li>
</ul>
<blockquote>
<p>组件之间通过抽象接口交互，这样的好处是封装变化。这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加系统的复用性，并降低系统耦合度</p>
</blockquote>
<img width="4698" height="1430" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/78713cf6-af9e-4b54-9133-bf2cd6f8e859" />






<p>由于IO模型和应用层协议之间可以自由组合，比如NIO+HTTP或者NIO2+NJP。Tomcat设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫做ProtocolHandler的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类，比如：Http11NioProtocol和AjpNioProtocol</p>
<p>除了这些变化点，系统也存在一些相对稳定的部分，因此tomcat设计了一系列抽象基类来封装这些稳定的部分，抽象基类AbstractProtocol实现类ProtocolHandler接口。每一种应用层协议有自己的抽象基类，比如AbstractAjpProtocol和AbstractHttp11Protocol，具体协议的实现类扩展了协议层抽象基类。</p>
<img width="821" height="468" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/ef9a7208-6550-4783-a507-72d1427b4e17" />


<h4 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h4><p>endpoint是通信端点，即监听通信的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此EndPoint是用来实现TCP&#x2F;IP协议的。endpoint是一个接口，对应的抽象实现类是AbstractEndpoint，其子类中，例如NioEndpoint和Nio2Endpoint中，有两个重要的子组件：Acceptor和SocketProcessor.其中Acceptor用于监听Socket连接请求。SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理，为了提高处理能力，SocketProcessor被提交到线程池来执行，而这个线程池叫做执行器（Executor）</p>
<h4 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h4><p>Processor用来实现HTTP&#x2F;AJP协议，Processor接收来自Endpoint的Socket,读取字节流解析成TomcatRequset和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象，Processor是一个接口，定义了请求的处理等方法，它的抽象实现类AbstractProcessor对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有AJPProcessor\HTTP11Processor等，这些具体实现类实现了特定协议的解析方法和请求处理方式。EndPoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池去处理，SocketProcessor的Run方法会调用Processor组件去解析应用层协议，Processor通过解析生成Request对象后没回调有Adapter的Service方法。</p>
<img width="4950" height="1430" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/7a2eef46-6b54-4baf-abf2-0cf376bcbb12" />


<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h4><p>由于协议不同，客户端发过来的请求信息也不相同，Tomcat定义了自己的Request类来存放这些请求信息。ProtocolHandler接口负责解析请求并生成TomcatRequest类。但是这个Request对象不是标准的ServletRequest，也就是意味着，不能使用TomcatRequest作为参数来调用容器。Tomcat的设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Service方法，传入的是TomcatRequest对象CoyoteAdapter负责将TomcatRequest和ServletRequest进行传化，再调用容器的Service方法。</p>
<p>设计复杂系统的思路：</p>
<p>首先分析需求，列出功能点，根据功能以及高内聚、低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，再抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。tomcat的父子容器组合模式设计，tomcat通过组合模式来管理这些容器。具体的实现方法是，所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象具有使用的一致性。</p>
<h2 id="4-2-Pipeline-Valve责任链模式设计"><a href="#4-2-Pipeline-Valve责任链模式设计" class="headerlink" title="4.2 Pipeline-Valve责任链模式设计"></a>4.2 Pipeline-Valve责任链模式设计</h2><p>连接器中的Adapter会调用容器的Service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host继续处理，依次类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet处理，这个过程中使用了Pipeline-Valve管道责任链模式</p>
<p>这种设计模式是指再一个请求处理的过程中有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完成之后再调用下一个处理者继续处理。</p>
<img width="3620" height="2316" alt="image" src= "/img/loading.png" data-lazy-src="https://github.com/user-attachments/assets/c8d0c35e-e97e-46ba-8687-e1fe0cce5e82" />


<h2 id="4-3-Tomcat生命周期设计"><a href="#4-3-Tomcat生命周期设计" class="headerlink" title="4.3 Tomcat生命周期设计"></a>4.3 Tomcat生命周期设计</h2><p>通过对Tomcat架构的分析，我们知道了Tomcat都有哪些组件，以及组件之间的关系，处理http请求的流程，如果想让tomcat能够对外提供服务，我们需要创建、组装并启动Tomcat组件，在服务停止的时候，我们还需要释放资源，销毁Tomcat组件，这是一个动态的过程。Tomcat需要动态地管理这些组件的生命周期。</p>
<h3 id="一键式启停：LifeCycle接口"><a href="#一键式启停：LifeCycle接口" class="headerlink" title="一键式启停：LifeCycle接口"></a>一键式启停：LifeCycle接口</h3><p>Tomcat 组件层级复杂（如 <code>Server → Service → Engine → Host → Context</code>），若每个组件各自实现启停逻辑，会导致：</p>
<ul>
<li><p>组件间依赖混乱（如必须先启动 <code>Connector</code> 才能接收请求，但 <code>Connector</code> 依赖 <code>Service</code> 初始化）；</p>
</li>
<li><p>无法统一控制（启动 &#x2F; 停止操作需逐个处理组件，无法 “一键操作”）。</p>
</li>
</ul>
<p><code>LifeCycle</code> 接口通过以下方式解决问题：</p>
<ol>
<li><p><strong>统一生命周期方法</strong>：定义所有组件必须实现的初始化、启动、停止、销毁方法；</p>
</li>
<li><p><strong>状态管理</strong>：规范组件的生命周期状态（如 “未初始化”“启动中”“已启动” 等）及状态转换规则；</p>
</li>
<li><p><strong>事件监听</strong>：支持通过监听器感知组件状态变化，实现扩展逻辑（如启动前初始化资源、停止后释放连接）。</p>
</li>
</ol>
<h4 id="1-核心方法（定义在-org-apache-catalina-Lifecycle-接口中）"><a href="#1-核心方法（定义在-org-apache-catalina-Lifecycle-接口中）" class="headerlink" title="1. 核心方法（定义在 org.apache.catalina.Lifecycle 接口中）"></a>1. 核心方法（定义在 <code>org.apache.catalina.Lifecycle</code> 接口中）</h4><h4 id="2-生命周期状态流转（关键状态）"><a href="#2-生命周期状态流转（关键状态）" class="headerlink" title="2. 生命周期状态流转（关键状态）"></a>2. 生命周期状态流转（关键状态）</h4><p>Tomcat 定义了严格的状态转换规则（通过 <code>LifecycleState</code> 枚举），确保组件按顺序执行生命周期操作，核心状态流转如下：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW（新建未初始化）→ INITIALIZING（初始化中）→ INITIALIZED（已初始化）</span><br><span class="line">→ STARTING_PREP（启动准备）→ STARTING（启动中）→ STARTED（已启动）</span><br><span class="line">→ STOPPING_PREP（停止准备）→ STOPPING（停止中）→ STOPPED（已停止）</span><br><span class="line">→ DESTROYING（销毁中）→ DESTROYED（已销毁）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个状态转换只能通过特定方法触发（如 <code>start()</code> 触发从 <code>INITIALIZED</code> 到 <code>STARTED</code> 的转换）；</p>
</li>
<li><p>状态转换不可逆（如 <code>STARTED</code> 不能直接回到 <code>INITIALIZED</code>，必须先 <code>stop()</code> 到 <code>STOPPED</code>）。</p>
</li>
</ul>
<h4 id="3-“一键式启停”-的实现逻辑"><a href="#3-“一键式启停”-的实现逻辑" class="headerlink" title="3. “一键式启停” 的实现逻辑"></a>3. “一键式启停” 的实现逻辑</h4><p><code>LifeCycle</code> 接口的层级联动机制，是 “一键式启停” 的核心：<strong>顶层组件的生命周期方法会自动触发所有子组件的对应方法</strong>。</p>
<p>以 Tomcat 启动为例（从 <code>Server</code> 到子组件）：</p>
<ol>
<li><p>用户执行 <code>startup.sh</code> 或点击启动按钮，最终调用 <strong><code>Server</code> 的 <code>start()</code> 方法</strong>；</p>
</li>
<li><p><code>Server</code> 的 <code>start()</code> 会先执行自身启动逻辑，然后遍历所有子组件（<code>Service</code>），调用每个 <code>Service</code> 的 <code>start()</code> 方法；</p>
</li>
<li><p><code>Service</code> 的 <code>start()</code> 会启动自身，再调用子组件 <code>Engine</code> 和 <code>Connector</code> 的 <code>start()</code> 方法；</p>
</li>
<li><p><code>Engine</code> 的 <code>start()</code> 会启动自身，再调用子组件 <code>Host</code> 的 <code>start()</code> 方法；</p>
</li>
<li><p>以此类推，直到最底层的 <code>Context</code>（Web 应用）和 <code>Wrapper</code>（Servlet）启动完成。</p>
</li>
</ol>
<p>停止过程同理：调用 <code>Server</code> 的 <code>stop()</code> 方法，会逐级触发所有子组件的 <code>stop()</code> 方法，最终实现 “一键停止”。</p>
<h4 id="4-3-4-监听器机制：扩展生命周期行为"><a href="#4-3-4-监听器机制：扩展生命周期行为" class="headerlink" title="4.3.4 监听器机制：扩展生命周期行为"></a>4.3.4 监听器机制：扩展生命周期行为</h4><p><code>LifeCycle</code> 接口通过 <strong><code>LifecycleListener</code> 监听器</strong>支持扩展，允许在组件状态变化时执行自定义逻辑（如日志记录、资源预热）。</p>
<p>示例：给 <code>Host</code> 组件添加启动监听器，在 Host 启动后打印日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostStartListener</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 当事件类型为“已启动”时触发</span></span><br><span class="line">        <span class="keyword">if</span> (Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">            <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> (Host) event.getSource();</span><br><span class="line">            System.out.println(<span class="string">&quot;Host &quot;</span> + host.getName() + <span class="string">&quot; 已启动，准备处理请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Host 组件中注册监听器（通常在 server.xml 或代码中配置）</span></span><br><span class="line"><span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">host.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">HostStartListener</span>());</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://icarus-blog.top">GoofySatoshi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://icarus-blog.top/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://icarus-blog.top/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://icarus-blog.top" target="_blank">GoofySatoshi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tomcat/">Tomcat</a><a class="post-meta__tags" href="/tags/Tomcat-%E6%9E%B6%E6%9E%84/">Tomcat 架构</a><a class="post-meta__tags" href="/tags/Servlet-%E5%AE%B9%E5%99%A8/">Servlet 容器</a><a class="post-meta__tags" href="/tags/Pipeline-Valve-%E6%A8%A1%E5%BC%8F/">Pipeline-Valve 模式</a><a class="post-meta__tags" href="/tags/LifeCycle-%E6%8E%A5%E5%8F%A3/">LifeCycle 接口</a><a class="post-meta__tags" href="/tags/Tomcat-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Tomcat 源码分析</a><a class="post-meta__tags" href="/tags/Web-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/">Web 应用部署</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/12/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="Tomcat类加载机制与热部署原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Tomcat类加载机制与热部署原理详解</div></div><div class="info-2"><div class="info-item-1">1.Tomcat类加载机制详解1.1 JVM类加载器Java中有3种类加载器，当然你也可以自定义类加载器  引导类加载器（启动类加载器）：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar 扩展类加载器：负责加载支撑JVM运行的JRE的lib目录下ext扩展目录中的核心jar包 应用程序类加载器（系统类加载器）：负责ClassPath路径下的类包，主要就是加载你自己写的类 自定义类加载器：自己实现，负责加载自定义路径下的类包1234567891011121314151617public class ClassLoaderDemo&#123;  public static void main(String[] args)&#123;    // BootStrapClassLoader c/c++实现，java层面是获取不到的，会输出null    System.out.println(ReentrantLock.class.getClassLoader());    // ExtClassLoader    System.out...</div></div></div></a><a class="pagination-related" href="/2025/09/22/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="G1 垃圾收集器学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">G1 垃圾收集器学习笔记</div></div><div class="info-2"><div class="info-item-1">G1垃圾收集器学习笔记2025-09-23一、G1垃圾收集器概述G1（Garbage-First）是Java 9默认的垃圾收集器，核心特性如下：    取消物理分代：将内存划分为2048个逻辑Region（默认值）   动态分区管理：年轻代&#x2F;老年代区域可相互转化   巨型对象处理：新增Humongous区存储超Region 50%的大对象  二、内存管理机制1. 内存分区 逻辑分区：保留年轻代（Eden&#x2F;Survivor）、老年代概念   物理结构：   默认2048个Region（通过-XX:G1HeapRegionSize调整）   年轻代初始占比5%（动态调整，上限60%）   Eden:Survivor默认比例8:1:1    2. 特殊区域 Humongous区：   存储超过Region 50%的大对象   若对象超过单个Region大小，会被分割存储于多个连续Region    三、垃圾回收流程G1回收分为四个阶段：    初始标记（Stop The World）   标记GC Roots直接引用对象   并发标记（Concurrent）   与...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/12/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="Tomcat类加载机制与热部署原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="info-item-2">Tomcat类加载机制与热部署原理详解</div></div><div class="info-2"><div class="info-item-1">1.Tomcat类加载机制详解1.1 JVM类加载器Java中有3种类加载器，当然你也可以自定义类加载器  引导类加载器（启动类加载器）：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar 扩展类加载器：负责加载支撑JVM运行的JRE的lib目录下ext扩展目录中的核心jar包 应用程序类加载器（系统类加载器）：负责ClassPath路径下的类包，主要就是加载你自己写的类 自定义类加载器：自己实现，负责加载自定义路径下的类包1234567891011121314151617public class ClassLoaderDemo&#123;  public static void main(String[] args)&#123;    // BootStrapClassLoader c/c++实现，java层面是获取不到的，会输出null    System.out.println(ReentrantLock.class.getClassLoader());    // ExtClassLoader    System.out...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.png" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GoofySatoshi</div><div class="author-info-description">分享技术、读书笔记和生活点滴</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GoofySatoshi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GoofySatoshi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">连雨不知春归去，一晴方觉夏已深</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Tomcat%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. Tomcat是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-WEB%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2. WEB应用部署的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%EF%BC%88Webapps-%E7%9B%AE%E5%BD%95%E9%83%A8%E7%BD%B2%EF%BC%89"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1 自动部署（Webapps 目录部署）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">操作步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%83%A8%E7%BD%B2%EF%BC%88Context-%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%EF%BC%89"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.2 配置文件部署（Context 配置部署）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A-1"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Manager-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%EF%BC%88%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E9%83%A8%E7%BD%B2%EF%BC%89"><span class="toc-number">2.0.3.</span> <span class="toc-text">2.3 Manager 应用部署（远程管理部署）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%EF%BC%9A%E9%85%8D%E7%BD%AE-Manager-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">前提：配置 Manager 访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%88%E7%BD%91%E9%A1%B5%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">操作步骤（网页方式）：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">3. Tomcat整体架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Tom%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Tom核心组件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Server%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">Server组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">Service组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connector%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.3.</span> <span class="toc-text">Connector组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">Container组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%AF%B7%E6%B1%82%E5%AE%9A%E4%BD%8DServlet%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 请求定位Servlet的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Tomcat%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">4. Tomcat架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Connector%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Connector高内聚低耦合设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ProtocolHandler"><span class="toc-number">4.1.1.</span> <span class="toc-text">ProtocolHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Endpoint"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Endpoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Processor"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">Processor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adapter"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Adapter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Pipeline-Valve%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Pipeline-Valve责任链模式设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Tomcat%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Tomcat生命周期设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%94%AE%E5%BC%8F%E5%90%AF%E5%81%9C%EF%BC%9ALifeCycle%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.1.</span> <span class="toc-text">一键式启停：LifeCycle接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%88%E5%AE%9A%E4%B9%89%E5%9C%A8-org-apache-catalina-Lifecycle-%E6%8E%A5%E5%8F%A3%E4%B8%AD%EF%BC%89"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">1. 核心方法（定义在 org.apache.catalina.Lifecycle 接口中）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC%EF%BC%88%E5%85%B3%E9%94%AE%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">2. 生命周期状态流转（关键状态）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E2%80%9C%E4%B8%80%E9%94%AE%E5%BC%8F%E5%90%AF%E5%81%9C%E2%80%9D-%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">3. “一键式启停” 的实现逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E7%9B%91%E5%90%AC%E5%99%A8%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%89%A9%E5%B1%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">4.3.4 监听器机制：扩展生命周期行为</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/" title="无标题">无标题</a><time datetime="2025-10-21T15:16:32.629Z" title="发表于 2025-10-21 23:16:32">2025-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/15/sentinel%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/" title="深入理解 Sentinel 限流组件推模式实现">深入理解 Sentinel 限流组件推模式实现</a><time datetime="2025-10-15T23:30:00.000Z" title="发表于 2025-10-16 07:30:00">2025-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/13/Tomcat%E7%9A%84IO%E6%A8%A1%E5%9E%8B/" title="Tomcat的IO模型与性能调优">Tomcat的IO模型与性能调优</a><time datetime="2025-10-13T07:30:00.000Z" title="发表于 2025-10-13 15:30:00">2025-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="Tomcat类加载机制与热部署原理详解">Tomcat类加载机制与热部署原理详解</a><time datetime="2025-10-12T17:07:00.000Z" title="发表于 2025-10-13 01:07:00">2025-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/10/TomCat%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Tomcat 整体结构以及设计源码分析">Tomcat 整体结构以及设计源码分析</a><time datetime="2025-10-10T00:00:00.000Z" title="发表于 2025-10-10 08:00:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By GoofySatoshi</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'github-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'GoofySatoshi/GoofySatoshi.github.io',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script>
  // 背景图片列表（替换为你的图片路径）
  const backgroundImages = [
    '/img/background1.jpg',
    '/img/background2.png',
    '/img/background3.jpg',
    '/img/background4.jpg',
    '/img/background5.jpg',
    '/img/background6.jpg',
    '/img/background7.jpg',
    '/img/background8.jpg',
    '/img/background9.jpg',
    '/img/background10.jpg',
    '/img/background11.jpg',
    '/img/background12.jpg',
    '/img/background13.jpg',
    '/img/background14.jpg',
    '/img/background15.jpg',
    '/img/background16.jpg',
    '/img/background17.jpg',
    '/img/background18.jpg',
    '/img/background19.jpg',
    '/img/background20.jpg'
  ];
  // 随机选择一张图片
  const randomImg = backgroundImages[Math.floor(Math.random() * backgroundImages.length)];
  // 设置为背景
  document.body.style.backgroundImage = `url(${randomImg})`;
</script>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/search/local-search.min.js"></script></div></div></body></html>